# 网络简介

网络通信模型大致分为5种类型:

* 阻塞IO
* 非阻塞IO
* I/O多路复用
* 信号驱动I/O
* 异步IO

不同网络模型中客户端与服务器端采用不同的通信方式进行有效的通信，后面的内容中会逐一描述这些I/O模型的通信过程。

I/O多路复用包含了两种IO复用模型:

* Reactor模式
* Proactor模式

## 1. IO网络模型

### 1.1 阻塞IO
阻塞IO的通信方式中`client/server`都会创建阻塞的套接字，当调用IO函数来进行消息传递，只有当等待的消息到来时，对应的函数才会返回正常往下运行。其工作模式如下图所示:

![阻塞IO流程图示](/images/阻塞IO.jpg)

通过上图可以看出阻塞IO网络通信模型中，应用程序调用时的套接字都是阻塞的。应用程序调用IO函数后，只有当需要事件发生后，才会从内核态返回用户态，继续执行后续程序。

### 1.2 非阻塞IO
非阻塞IO的通信方式中`client/server`一般都是采用轮询的方式来进行消息传递，只有当合适的消息返回时，对应的函数才会处理接收或者发送的信息。其工作模式如下图所示:

![非阻塞IO流程图示](/images/非阻塞IO.jpg)

通过上图可以看出非阻塞IO网络通信模型中，应用程序调用时的套接字都是非阻塞的。应用程序调用IO函数进行消息传递，当数据未准备好和已准备完毕返回值不同，根据不同的返回值来进行处理。

### 1.3 IO复用
阻塞与非阻塞IO的通信方式中，都是对单独的一个套接字进行处理。这样效率比较低，并且浪费大量的系统资源来处理IO事件，相比来说采用IO复用的函数来进行处理多个套接字，节省系统资源，提高效率。其工作模式如下图所示:

![IO复用流程图示](/images/IO复用.jpg)

IO复用中有多种函数可以使用，例如`select\poll\epoll(linux)\kqueue(mac)\ICOP(window)`。这些函数都是同时监控多个套接字，当某个套接字有事件发生时，会会传给应用程序进行进一步处理。

### 1.4 信号驱动IO
上面都是通过套接字来进行IO网络通信，当然应用程序也可以采用信号来进行消息传递。其工作模式如下图所示:

![信号驱动IO流程图示](/images/信号驱动IO.jpg)

通过上图可见，应用程序通过设置信号及处理事件与内核进行交互。当内核准备好数据后，通过信号处理函数来提示应用程序来进行处理数据。

### 1.5 异步IO
相对于上述的4种模型，都是采用的同步IO来进行处理。本小节将介绍异步IO模型其流程，其如下图所示:

![异步IO流程图示](/images/异步IO.jpg)

通过上图可以看出，应用程序完全不用关心数据准备过程。内核将数据拷贝完毕后，再通知应用进程来处理相应的数据。

### 1.6 五种IO模型的对比

![IO模型流程对比图示](/images/IO模型对比.jpg)

## 2. IO多路复用模式
目前流程的IO多路复用模型有`Reactor`和`Proactor`两种情况。其中`Reactor`是使用最多的IO复用模式，其中`libevent`和`netty`都将其作为主要的网络模式，所以本小节将作为重点介绍对象。

面临的问题:

在网络服务器采用事件驱动模型，虽然网络请求会被序列化处理，但是必须时刻准备处理多个同时到达的服务请求。
在实际应用过程中，这些请求都会通过事件来表示(connection事件/read事件/write事件等)。
在有序处理这些服务请求之前，服务器必须将这些事件能够分离并且调度这些事件对应的处理程序。

处理这些问题时需要注意以下四个方面:
1. 为了提高系统反应时间，应用程序不能够长时间阻塞在某个事件处理上。
2. 为了提高系统吞吐量，需要避免不必要的任何数据移动操作。
3. 尽量提高事件分离以及事件分发的效率。
4. 应用代码需要隐藏在多线程和同步机制之后。

解决方案:

1. 多个事件源上等待事件到来。
2. 将事件分离和调度整合到它的服务中，但与应用程序无关。
3. 事件处理器都需要事先注册到Reactor管理器中。
4. Reactor管理器使用同步事件分离器在多个事件源中等待事件发生。
5. 当事件发生后，同步事件分离器通知Reactor管理器，最后由Reactor管理器调度和该事件相关的事件处理器来完成请求。

### 2.1 Reactor模式
Reactor模式中四种重要的角色，分别为`文件描述符`、`同步事件分离器`、`事件处理器`、`Reactor管理器`。下面将逐一介绍这四种角色的含义。

#### `文件描述符`
由操作系统提供，用于识别每一个网络接口。

#### `同步事件分离器`
同步事件分离器是一个阻塞函数，用于等待事件发生。

#### `事件处理器`
事件处理器是由一个或多个函数模版组成的接口。这些模版函数用于处理某种事件发生时的操作。

#### `Reactor管理器`
Reactor管理器定义了一系列的接口，用于应用程序控制事件调度，以及应用程序注册\删除事件处理器和相关的文件描述符。它是事件处理器的调度核心，使用同步事件分离器来等待事件的发生。一旦事件发生，Reactor管理器先是分离每个事件，然后调度事件处理器，最后调用相关的事件处理器。

#### `Reactor`模式

##### 1 单线程模式
单线程模式其图示如下:

![Reactor单线程模式图示](/images/reactor单线程模式.jpg)

通过上图可以看出，所有套接字都使用同一个Reactor来实现事件分发和处理。

##### 2 多线程单Reactor模式
多线程模式其图示如下:

![Reactor多线程模式图示](/images/reactor多线程模式.jpg)

通过上图可以看出，所有套接字使用同一个Reactor来实现事件分发，对于耗时比较长的操作，可以分配给`ThreadPool`去进行处理。

###### 3 多线程多Reactor模式
多线程模式其图示如下:

![多Reactor多线程模式图示](/images/多reactor多线程.jpg)

通过上图可以看出，模式中采用了多个Reactor来实现事件的处理。MainReactor来实现链接的接收，然后将链接的结果分发给SubReactor进行事件处理操作。

### 2.2 Proactor模式
在Proactor模式种，事件处理者直接发起一个异步读写操作。而实际的工作是由操作系统来完成的。发起时，需要提供的参数包括用于存放数据的缓存区，以及请求完成后的回调函数等信息。事件分离着得知请求后，它就等待请求完成，然后转发完成事件给相应的事件处理者或者回调。

### 2.3 Reactor和Proactor区别
Reactor是在事件发生时就通知事先注册的事件处理器进行处理；Proactor是在事件发生时进行异步IO(由OS完成)，待IO完成后事件分离器才调度事件处理器。
