网络子线程命令解析
==================================
前面介绍了4种`conn`的状态，其中`conn_parse_cmd`状态用来解析客户端发送过来的命令(`process_command`函数)。本文将详细介绍此函数，并根据`process_command`函数设置`conn`状态来介绍剩下的`conn`状态的处理过程。

#1. `process_command`函数体
首先来查看`process_command`的源代码，从而进一步介绍`memcached`种常用的几个命令，例如`get/gets/add/set/replace/delete`等操作。

```
static void process_command(conn *c, char *command) {
	
	token_t tokens[MAX_TOKENS];		// 命令以及其参数
	size_t ntokens;						// 解析出来参数的个数
	int comm;
	
	assert(c != NULL);
	
	MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
	
	if (settings.verbose > 1)
		fprintf(stderr, "<%d %s\n", c->sfd, command);
		
	/**
	 * for commands set/add/replace, we build an item and read the data
	 * directly into it, then continue in nread_complete().
	 */
	
	// 初始化需要发送的数组
	c->msgcurr = 0;	
	c->msgused = 0;
	c->iovused = 0;
	if (add_msg(c) != 0) {		// 如果是UDP网络协议，空余出发送数据头
		out_of_memory(c, "SERVER_ERROR out of memory preparing response");
		return;
	}
	
	ntokens = tokenize_command(command, tokens, MAX_TOKENS);  // 从接受字节中解析命令
	if (ntokens >= 3 &&
			((strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "bget") == 0))) { // get命令
		
		process_get_command(c, tokens, ntokens, false, false);
		
	} else if ((ntokens == 6 || ntokens == 7) &&
			((strcmp(tokens[COMMAND_TOKEN].value, "add") == 0 && (comm = NREAD_ADD)) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "set") == 0 && (comm = NREAD_SET)) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) )) {
		// 注意这里comm是设置操作
		process_update_command(c, tokens, ntokens, comm, false);
	
	} else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, "cas") == 0 && (comm = NREAD_CAS))) {
		// 注意这里comm是设置操作
		process_update_command(c, tokens, ntokens, comm, ture);
	
	} else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0)) {
		
		process_arithmetic_command(c, tokens, ntokens, 1);
		
	} else if ((ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0)) {
	
		process_get_command(c, tokens, ntokens, true, false);
	
	} else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "decr") == 0)) {
	
		process_arithmetic_command(c, tokens, ntokens, 0);
	
	} else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, "delete") == 0)) {
	
		process_delete_command(c, tokens, ntokens, 0);
		
	} else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "touch") == 0)) {
		
		process_touch_command(c, tokens, ntokens);
	 
	} else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gat") == 0) {
	
		process_get_command(c, tokens, ntokens, false, true);
	
	} else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gats" == 0)) {
	
		process_get_command(c, tokens, ntokens, true, true);
	
	} else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "stats") == 0)) {
	
		process_stat(c, tokens, ntokens);
	
	} else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "flush_all") == 0)) {
		// 删除所有item
		time_t exptime = 0;
		rel_time_t new_oldest = 0;
		
		set_noreply_maybe(c, tokens, ntokens); // 设置是否需要返回值
		
		pthread_mutex_lock(&c->thread->stats.mutex);
		c->thread->stats.flush_cmds++;
		pthread_mutex_unlock(&c->thread->stats.mutex);
		
		if (!setttings.flush_enabled) {
			// flush_all is not allowed but we log it an stats
			out_string(c, "CLIENT_ERROR flush_all not allowed"); // 输出字符串
			return;
		}
		
		if (ntokens != (c->noreply ? 3 : 2)) {
			exptime = strtol(tokens[1].value, NULL, 10); // 获取设置的超时时间
			if (errno == ERANGE) {
				out_string(c, "CLIENT_ERROR bad command line format");
				return;
			}
		}
		
		/**
		 * If exptime is zero realtime() would return zero too, and
		 * realtime(exptime) - 1 would overflow to the max unsigned
		 * value. So we process exptime == 0 the same way we do when
		 * no delay is given at all.
		 */
		if (exptime > 0) {
			new_oldest = realtime(exptime); // 设置最老item的时间
		} else { // exptime == 0
			new_oldest = current_time;
		}
	
		if (settings.use_cas) {
			settings.oldest_live = new_oldest - 1;
			if (settings.oldest_live <= current_time)
				settings.oldest_cas = get_cas_id();
		} else {
			settings.oldest_live = new_oldest;
		}
		out_string(c, "OK");
		return;
		
	} else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "version") == 0)) {
		
		out_string(c, "VERSION " VERSION);
		
	} else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "quit") == 0)) {
	
		conn_set_state(c, conn_closing);
		
	} else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "shutdown") == 0)) {
	
		if (settings.shutdown_command) {
			conn_set_state(c, conn_closing);
			raise(SIGINT);
		} else {
			out_string(c, "ERROR: shutdown not enabled");
		}
	
	} else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "slabs") == 0) {
		// 对于slab管理的操作
		if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, "reassign") == 0) {
			// 调用slab reassign操作
			int src, dst, rv;
			
			if (settings.slab_reassign == false) {
				out_string(c, "CLIENT_ERROR slab reassignment disabled");
				return;
			}
			
			src = strtol(tokens[2].value, NULL, 10);
			dst = strtol(tokens[3].value, NULL, 10);
			
			if (errno == ERANGE) {
				out_string(c, "CLIENT_ERROR bad command line format");
				return;
			}
			
			rv = slabs_reassign(src, dst);
			switch (rv) {
			case REASSIGN_OK:
				out_string(c, "OK");
				break;
			case REASSIGN_RUNNING:
				out_string(c, "BUSY currently processing reassign request");
				break;
			case REASSIGN_BADCLASS:
				out_string(c, "BADCLASS invalid src or dst class id");
				break;
			case REASSIGN_NOSPARE:
				out_string(c, "NOSPARE source class has no spare pages");
				break;
			case REASSIGN_SRC_DST_SAME:
				out_string(c, "SAME src and dst class are identical");
				break;
			}
			return;
		
		} else if (ntokens >= 4 && 
				(strcmp(tokens[COMMAND_TOKEN + 1].value, "automove") == 0)) {
			process_slabs_automove_command(c, tokens, ntokens); // 设置automove的参数
		} else {
			out_string(c, "ERROR");
		}
	
	} else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "lru_crawler") == 0) {
		// 对lru_crawler线程的设置
		if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "crawl") == 0) {
			int rv;
			if (settings.lru_crawler == false) {
				out_string(c, "CLIENT_ERROR lru crawler disabled");
				return;
			}
			
			rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0, settings.lru_crawler_tocrawl); // 开启扫描某一个slab链表
			switch (rv) {
			case CRAWLER_OK:
				out_string(c, "OK");
				break;
			case CRAWLER_RUNNING:
				out_string(c, "BUSY currently processing crawler request");
				break;
			case CRAWLER_BADCLASS:
				out_string(c, "BADCLASS invalid class id");
				break;
			case CRAWLER_NOTSTARTED:
				out_string(c, "NOTSTRTED no items to crawl");
				break;
			case CRAWLER_ERROR:
				out_string(c, "ERROR on unknown error happened");
				break;
			}
			return;
		} else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "metadump") == 0) {
			if (settings.lru_crawler == false) {
				out_string(c, "CLIENT_ERROR lru crawler disabled");
				return;
			}
			if (!settings.dump_enabled) {
				out_string(c, "ERROR metadump not allowed");
				return;
			}
			
			int rv = lru_crawler_crawl(tokens[2].value, CRAWLER_METADUMP, c, c->sfd, LRU_CRAWLER_CAP_REMAINING);
			switch(rv) {
			case CRAWLER_OK:
				out_string(c, "OK");
				conn_set_state(c, conn_watch);
				event_del(&c->event);		// 先将conn从Reactor管理器中去除掉
				break;
			case CRAWLER_RUNNING:
				out_string(c, "BUSY currently processing crawler request");
				break;
			case CRAWLER_BADCLASS:
				out_string(c, "BADCLASS invalid class id");
				break;
			case CRAWLER_NOTSTARTED:
				out_string(c, "NOTSTARTED no items to crawl");
				break;
			case CRAWLER_ERROR:
				out_string(c, "ERROR an unknown error happended");
				break;
			}
			return;
		} else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "tocrawl") == 0) {
			uint32_t tocrawl;
			if (!safe_strtoul(tokens[2].value, &tocrawl)) {
				out_string(c, "CLIENT_ERROR bad command line format");
				return;
			}
			settings.lru_crawler_tocrawl = tocrawl;
			out_string(c, "OK");
			return;
		} else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "sleep") == 0) {
			uint32_t tosleep;
			if (!safe_strtoul(tokens[2].value, &tosleep)) {
				out_string(c, "CLIENT_ERROR bad command line format");
				return;
			}
			if (tosleep > 1000000) {
				out_string(c, "CLIENT_ERROR sleep must be one second or less");
				return;
			}
			settings.lru_crawler_sleep = tosleep;
			out_string(c, "OK");
			return;
		} else if (ntokens == 2) {
			if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "enable") == 0)) {
				if (start_item_crawler_thread() == 0) {
					out_string(c, "OK");
				} else {
					out_string(c, "ERROR failed to start lru crawler thread");
				}
			} else if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "disable") == 0)) {
				if (stop_item_crawler_thread() == 0) {
					out_string(c, "OK");
				} else {
					out_string(c, "ERROR failed to stop lru crawler thread");
				}
			} else {
				out_string(c, "ERROR");
			}
			return;
		} else {
			out_string(c, "ERROR");
		}
	
	} else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "watch") == 0) {
		process_watch_command(c, tokens, ntokens);
		
	} else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "cache_memlimit") == 0)) {
		process_memlimit_command(c, tokens, ntokens);
		
	} else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "verbosity") == 0)) {
		process_verbosity_command(c, tokens, ntokens);
		
	} else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "lru") == 0) {
#ifdef MEMCACHED_DEBUG
	// commands which exist only for testing the memcached's security protection
	} else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "misbehave") == 0)) {
		process_misbehave_command(c);
#endif
#ifdef EXTSTORE
	} else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "extstore") == 0) {
		process_extstore_command(c, tokens, ntokens);
#endif
#ifdef TLS
	} else if (ntokens == 2 && strcmp(tokens[COMMAND_TOKEN].value, "refresh_certs") == 0) {
		set_noreply_maybe(c, tokens, ntokens);
		char *errmsg = NULL;
		if (refresh_certs(&errmsg)) {
			out_string(c, "OK");
		} else {
			write_and_free(c, errmsg, strlen(errmsg));
		}
		return;
#endif
	} else {
		if (ntokens >= 2 && strcmp(tokens[ntokens - 2].value, "HTTP/", 5) == 0) {
			conn_set_state(c, conn_closing);
		} else {
			out_string(c, "ERROR");
		}
	}
	return;
}

// 命令解析函数
typedef struct token_s {
	char *value;
	size_t length;
} token_t;

#define COMMAND_TOKEN 0
#define SUBCOMMAND_TOKEN 1
#define KEY_TOKEN 1

#define MAX_TOKENS 8

/**
 * Tokenize the command string by replacing whitespace with '\0' and update
 * the token array tokens with pointer to start of each token and length.
 * Returns total number of tokens. The last valid token is the terminal
 * token (value points to the first unprocessed character of the string and
 * length zero).
 */
// 理解此段代码需要详细了解client发送过来命令的格式，请读者自行谷歌
static size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {
	char *s, *e;
	size_t ntokens = 0;
	size_t len = strlen(command);	// 上面文章介绍过在try_read_command_ascii函数中将命令截止符\n替换为\0
	unsigned int i = 0;
	
	assert(command != NULL && tokens != NULL && max_tokens > 1);
	
	s = e = command;
	for (i = 0; i < len; i++) {			// 从原字符串中记录对应的命令以及参数等信息
		if (*e == ' ') {
			if (s != e) {
				tokens[ntokens].value = s;
				tokens[ntokens].length = e - s;
				ntokens++;
				*e = '\0';
				if (ntokens == max_tokens - 1) {
					e++;
					s = e;	// so we don't add an extra token
					break;
				}
			}
			s = e + 1;
		}
		e++;
	}
	
	if (s != e) {
		tokens[ntokens].value = s;
		tokens[ntokens].length = e - s;
		ntokens++;
	}
	
	/**
	 * If we scanned the whole string, the terminal value pointer is null,
	 * otherwise it is the first unprocessed character.
	 */
	tokens[ntokens].value = *e == '\0' ? NULL : e;
	tokens[ntokens].length = 0;
	ntokens++;
	
	return ntokens;
}
```
从上面的源代码可看出，命令可分为如下几类:

* 存储命令,例如`add/set/replace/prepend/append/delete`等命令。
* 查找命令,例如`get/gets/incr/decr`等敏玲。
* 统计命令,例如`stats`命令。
* 控制命令,例如`flush_all/quit/shutdown`等命令。

本文将重点介绍存储命令和查找命令，对于其他命令需要读者自行分析。

#2 公用的基础函数
在很多命令中都需要向客户端返回信息处理的结果，那么相应的读写函数有必要详细介绍一下。其源代码如下:

```
// 初始化写出msghdr数组中的空间,读者可以一边查看上篇文章对应的conn结构体，一边读本文
/**
 * Adds a message header to a connection.
 * Returns 0 on success, -1 on out-of-memory.
 */
static int add_msghdr(conn *c) {
	struct msghdr *msg;
	
	assert(c != NULL);
	
	if (c->msgsize == c->msgused) {		// 判断是否还有空间
		msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));
		if (!msg) {
			STATS_LOCK();
			stats.malloc_fails++;
			STATS_UNLOCK();
			return -1;
		}
		c->msglist = msg;
		c->msgsize *= 2;
	}
	
	msg = c->msglist + c->msgused;
	
	/* this wipes msg_iovlen, msg_control, msg_controllen, and
		msg_flags, the last 3 of which aren't defined on solaris: */
	memset(msg, 0, sizeof(struct msgdhr));
	
	msg->msg_iov = &c->iov[c->iovused];	// msghdr指向iovec数组中的成员
	
	if (IS_UDP(c->transport) && c->request_addr_size > 0) { // 对于UDP协议，设置发送的目的地址
		msg->msg_name = &c->request_addr;
		msg->msg_namelen = c->request_addr_size;
	}
	
	c->msgbytes = 0;
	c->msgused++;				//msghdr数组和iovec数组都是当作栈在使用
	
	if (IS_UDP(c->transport)) { 	// UDP添加上协议头
		/* Leave room for the UDP header, which we'll fill in later.*/
		return add_iov(c, NULL, UDP_HEADER_SIZE);
	}
	
	return 0;
}

// 记录需要写出地址和长度的函数
/**
 * Adds data to the list of pending data that will be written out to a connection.
 * Returns 0 on success, -1 on out-of-memory.
 * Note: This is a hot path for at least ASCII protocol. While there is 
 * redundant code in splitting TCP/UDP handling, any reduction is steps has a
 * large impact for TCP connections.
 */
static int add_iov(conn *c, const void *buf, int len) {
	struct msghdr *m;
	int leftover;
	
	assert(c != NULL);
	
	if (IS_UDP(c->transport)) {		// UDP网络协议
		do {
			m = &c->msglist[c->msgused - 1];   // 获取栈顶位置
			
			/*
			 * limit UDP packets to UDP_MAX_PAYLOAD_SIZE bytes.
			 */
			
			// we may need to start a new msghdr if this one is full
			if (m->msg_iovlen == IOV_MAX ||
					(c->msbytes >= UDP_MAX_PAYLOAD_SIZE)) { // 判断此msghdr是否已经满了
				add_msghdr(c);
				m = &c->msglist[c->msgused - 1];
			}
			
			if (ensure_iov_space(c) != 0) // 判断c->iovec数组是否需要扩展
				return -1;
			
			// If the fragment is too big to fit in the datagram, split it up
			if (len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {
				leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;
				len -= leftover;
			} else {
				leftover = 0;
			}
			
			m = &c->msglist[c->msgused - 1];
			m->msg_iov[m->msg_iovlen].iov_base = (void *)buf; //记录需要发送数据的地址
			m->msg_iov[m->msg_iovlen].iov_len = len; // 记录需要发送数据长度
			
			c->msgbytes += len;		// 记录需要发送数据的总长度
			c->iovused++;				// iovec数组栈指针加1
			m->msg_iovlen++;			// msghdr中指向的iovec结构的长度加1
			
			buf = ((char *)buf) + len;
			len = leftover;
		} while (leftover > 0);
	} else {
		// Optimized path for TCP connections
		m = &c->msglist[c->msgused - 1];	  // 使用栈顶的msghdr
		if (m->msg_iovlen == IOV_MAX) {	  // msghdr数组满时调用
			add_msghdr(c);
			m = &c->msglist[c->msgused - 1];
		}
		
		if (ensure_iov_space(c) != 0) // 判断c->iovec数组是否需要扩展
			return -1;
		
		// 注意此时不涉及字符串的拷贝，仅仅是指针记录地址
		m->msg_iov[m->msg_iovlen].iov_base = (void *)buf; //记录需要发送数据的地址
		m->msg_iov[m->msg_iovlen].iov_len = len; // 记录需要发送数据长度
		c->msgbytes += len; // 记录需要发送数据的总长度
		c->iovused++;			// iovec数组栈指针加1
		m->msg_iovlen++;		// msghdr结构中记录的iovec个数加1
	}
	
	return 0;
}

// 用于输出少量字符时使用
static void out_string(conn *c, const char *str) {
	size_t len;
	
	assert(c != NULL);
	
	if (c->noreply) {
		if (settings.verbose > 1)
			fprintf(stderr, ">%d NOREPLY %s\n", c->sfd, str);
		c->noreply = false;
		conn_set_state(c, conn_new_cmd);
		return;
	}
	
	if (settings.verbose > 1)
		fprintf(stderr, ">%d %s\n", c->sfd, str);
	
	/* Nuke a partial output.... */
	// 重新初始化输出变量，用于下次命令的输出
	c->msgcurr = 0;
	c->msgused = 0;
	c->iovused = 0;
	add_msghdr(c);
	
	len = strlen(str);	// 记录需要输出字符串的长度
	if ((len + 2) > c->wsize) {
		/* ought to be always enough, just fail for simplicity */
		str = "SERVER_ERROR output line too long";
		len = strlen(str);
	}
	
	// 拷贝需要输出的字符串到写出空间
	memcpy(c->wbuf, str, len);
	memcpy(c->wbuf + len, "\r\n", 2);
	c->wbytes = len + 2;			// 记录写出字符串的大小
	c->wcurr = c->wbuf;				// 记录能够存放后续写出字符串的位置
	
	conn_set_state(c, conn_write);	// 将conn的状态置为conn_write
	c->write_and_go = conn_new_cmd;	// 记录写出后跳转的状态
	return;
}

/**
 * Outputs a protocol-specific "out of memory" error. For ASCII clients,
 * this is equivalent to out_string()
 */
static void out_of_memory(conn *c, char *ascii_error) {
	const static char error_prefix[] = "SERVER_ERROR ";
	const static int error_prefix_len = sizeof(error_prefix) - 1;
	
	if (c->protocol == binary_prot) {
		/* Strip off the generic error prefix; it's irrelevant in binary */
		if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
			ascii_error += error_len_len;
		}
		write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
	} else {
		out_string(c, ascii_error);
	}
}
```
上面的源代码全面的展示了所有涉及到写出的公共函数，后续介绍的命令中会大量使用这些函数。

#3 命令函数解析
本小节将进入主题，介绍`ASCII`解析协议时使用的函数命令。首先将各个命令使用的函数以及其对应的参数进行汇总，从而进行统一介绍。

| 命令 | 使用的函数 | 函数的参数 | 备注 |
| ---  | ------- | -------- | -----|
| `get/bget` | `process_get_command` | `process_get_command(c, tokens, ntokens, false, false)` | 无 |
| `gets` | `process_get_command` | `process_get_command(c, tokens, ntokens, true, false)` | 无 |
| `gat` | `process_get_command` | `process_get_command(c, tokens, ntokens, false, true)` | 无 |
| `gats` | `process_get_command` | `process_get_command(c, tokens, ntokens, true, true)` | 无 |
| `add/set/replace/prepend/append` | `process_update_command` | `process_update_command(c, tokens, ntokens, comm, false)` | 无 |
| `cas` | `process_update_command` | `process_update_command(c, tokens, ntokens, comm, true)` | 无 |
| `incr` | `process_arithmetic_command` | `process_arithmetic_command(c, tokens, ntokens, 1)` | 无 |
| `decr` | `process_arithmetic_command` | `process_arithmetic_command(c, tokens, ntokens, 0)` | 无 |
| `delete` | `process_delete_command` | `process_delete_command(c, tokens, ntokens)` | 无 |
| `touch` | `process_touch_command` | `process_touch_command(c, tokens, ntokens)` | 无 |
| `stats` | `process_stat` | `process_stat(c, tokens, ntokens)` | 无 |
| `flush_all` | 无函数  | 无函数  | 主要用来设置`item`过期 |
| `version` | `out_string` | `out_string(c, "VERSION " VERSION)` | 查看版本信息 |
| `quit` | `conn_set_state` | `conn_set_state(c, conn_closing)` | 设置`conn`状态 |
| `shutdown` | `conn_set_state` | `conn_set_state(c, conn_closing)` | 设置`conn`状态 |
| `slabs` | 无函数 | 无函数 | 对于`slabs`相关函数的操作 |
| `lru_crawler` | 无函数 | 无函数 | 对于`lru`相关函数的操作 |
| `watch` | `process_watch_command` | `process_watch_command(c, tokens, ntokens)` | 无 |
| `cache_memlimit` | `process_memlimit_command` | `process_memlimit_command(c, tokens, ntokens)` | 设置使用的内存大小 |
| `verbosity` | `process_verbosity_command` | `process_verbosity_command(c, tokens, ntokens)` | 设置日志的输出级别 |
| `lru` | `process_lru_command` | `process_lru_command(c, tokens, ntokens)` | 设置`lru  maintainer`线程的参数 |
| `extstore` | `process_extstore_command` | `process_extstore_command(c, tokens, ntokens)` | 外存设置 |
| `refresh_certs` | 无函数 | 无函数 | 认证证书的设置 |

通过上表集中体现了各种命令及其对应的函数，本文主要介绍如下几个函数(其他函数读者自行学习,对于`extstore`的处理函数后续有文档会详细描述):

* `process_get_command`
* `process_update_command`
* `process_arithmetic_command`
* `process_delete_command`
* `process_touch_command`
* `process_stat`


## 3.1 `process_get_command`函数
此函数主要用于获取存放`item`的`value`值，其源代码如下:

```
static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {
	char *key;
	size_t nkey;
	int i = 0;
	int si = 0;
	item *it;			// 指向操作的item
	token_t *key_token = &tokens[KEY_TOKEN];  // 获取key值
	char *suffix;		// 指向操作item的标志位
	int32_t exptime_int = 0;
	rel_time_t exptime = 0;
	bool fail_length = false;
	assert(c != NULL);
	
	if (should_touch) {		// 判断是否需要设置有效时间
		// For get and touch commands, use first token as exptime
		if (!safe_strtol(tokens[1].value, &exptime_int)) {
			out_string(c, "CLIENT_ERROR invalid exptime argument");
			return;
		}
		key_token++;
		exptime = realtime(exptime_int);
	}
	
	do { 	// 获取所有key对应的item
		while (key_token->length != 0) {
		
			key = key_token->value;
			nkey = key_token->length;
			
			if (nkey > KEY_MAX_LENGTH) {
				fail_length = true;
				goto stop;
			}
			
			it = limited_get(key, nkey, c, exptime, should_touch);  // 获取key对应的item
			if (settings.detail_enabled) {
				stats_prefix_record_get(key, nkey, NULL != it);
			}
			if (it) {
				if (_ascii_get_expand_ilist(c, i) != 0) {
					item_remove(it);
					goto stop;
				}
				
				/*
				 * Construct the response. Each hit adds three elements to the
				 * outgoing data list:
				 * 		"VALUE"
				 * 	 	key
				 * 	  	" " + flags + " " + data length + "\r\n" + data (with \r\n)
				 */
				{
					MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey, it->nbytes, ITEM_get_cas(it));
					int nbytes;
					suffix = _ascii_get_suffix_buf(c, si);
					if (suffix == NULL) {
						item_remove(it);
						goto stop;
					}
					si++;
					nbytes = it->nbytes;	// 获取item的value值长度
					int suffix_len = make_ascii_get_suffix(suffix, it, return_cas, nbytes);
					// 组装返回的值
					if (add_iov(c, "VALUE ", 6) != 0 ||
						 add_iov(c, ITEM_key(it), it->nkey) != 0 ||
						 add_iov(c, suffix, suffix_len) != 0) {
						 
						item_remove(it);
						goto stop;
					}
#ifdef EXTSTORE
					if (it->it_flags & ITEM_HDR) {
						if (_get_extstore(c, it, c->iovused-3, 4) != 0) {
							pthread_mutex_lock(&c->thread->stats.mutex);
							c->thread->stats.get_oom_extstore++;
							pthread_mutex_unlock(&c->thread->stats.mutex);
							
							item_remove(it);
							goto stop;
						}
					} else if ((it->it_flags & ITEM_CHUNKED) == 0) {
#else
					if ((it->it_flags & ITEM_CHUNKED) == 0) {
#endif
						add_iov(c, ITEM_data(it), it->nbytes);
					} else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {
						item_remove(it);
						goto stop;
					}
				}
				
				if (settings.verbose > 1) {
					int ii;
					fprintf(stderr, ">%d sending key ", c->sfd);
					for (ii = 0; ii < it->nkey; ++ii) {
						fprintf(stderr, "%c", key[ii]);
					}
					fprintf(stderr, "\n");
				}
				
				/* item_get() has incremented it->refcount for us */
				pthread_mutex_lock(&c->thread->stats.mutex);
				if (should_touch) {
					c->thread->stats.touch_cmds++;
					c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
				} else {
					c->thread->stats.lru_hits[it->slabs_clsid]++;
					c->thread->stats.get_cmds++;
				}
				pthread_mutex_unlock(&c->thread->stats.mutex);
				
				// 将item加入到conn的item链表中
#ifdef EXTSTORE
				/* If ITEM_HDR, an io_wrap owns the reference */
				if ((it->it_flags & ITEM_HDR) == 0) {
					*(c->ilist + i) = it;
					i++;
				}
#else
				*(c->ilist + i) = it;
				i++;
#endif
			} else {		// 此key值无对应的item
				pthread_mutex_lock(&c->thread->stats.mutex);
				if (should_touch) {
					c->thread->stats.touch_cmds++;
					c->thread->stats.touch_misses++;
				} else {
					c->thread->stats.get_misses++;
					c->thread->stats.get_cmds++;
				}
				MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
				pthread_mutex_unlock(&c->thread->stats.mutex);
			}
			
			key_token++;
		}
		
		/**
		 * If the command string hasn't been fully processed, get the next set
		 * of tokens
		 */
		if (key_token->value != NULL) {
			ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
			key_token = tokens;
		}
		
	} while(key_token->value != NULL);
stop:
	
	c->icurr = c->ilist;
	c->ileft = i;
	c->suffixcurr = c->suffixlist;
	c->suffixleft = si;
	
	if (settings.verbose > 1)
		fprintf(stderr, ">%d END\n", c->sfd);
		
	/*
	 * If the loop was terminated because of out-of-memory, it is not
	 * reliable to add END\r\n to the buffer, because it might not end
	 * in \r\n. So we send SERVER_ERROR instread.
	 */
	if (key_token->value != NULL || add_iov(c, "END\r\n", 5) != 0
			|| (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {
		if (fail_length) {
			out_string(c, "CLIENT_ERROR bad command line format");
		} else {
			out_of_memory(c, "SERVER_ERROR out of memory writring get response");
		}
		conn_release_items(c);
	} else {
		conn_set_stats(c, conn_mwrite);
		c->msgcurr = 0;
	}
}

// 根据key来获取item
#define IT_REFCOUNT_LIMIT 60000
static inline item* limited_get(char *key, size_t nkey, conn *c, uint32_t exptime, bool should_touch) {
	item *it;
	if (should_touch) {
		it = item_touch(key, nkey, exptime, c); 
	} else {
		it = item_get(key, nkey, c, DO_UPDATE);
	}
	if (it && it->refcount > IT_REFCOUNT_LIMIT) {    // 此处防止某个item过热
		item_remove(it);
		it = NULL;
	}
	return it;
}

// 判断ilist是否需要扩展函数,用于记录获取的item的数组
static inline int _ascii_get_expand_ilist(conn *c, int i) {
	if (i >= c->isize) {
		item **new_list = realloc(c->ilist, sizeof(item *) * c->isize * 2);
		if (new_list) {
			c->isize *= 2;
			c->ilist = new_list;
		} else {
			STATS_LOCK();
			stats.malloc_fails++;
			STATS_UNLOCK();
			return -1;
		}
	}
	return 0;
}

// 获取item的flag保存的内存地址
static inline char *_ascii_get_suffix_buf(conn *c, int i) {
	char *suffix;
	// Goofy mid-flight realloc.
	if (i >= c->suffixsize) {
		char **new_suffix_list = realloc(c->suffixlist, sizeof(char *) * c->suffixsize * 2);
		if (new_suffix_list) {
			c->suffixsize *= 2;
			c->suffixlist = new_suffix_list;
		} else {
			STATS_LOCK();
			stats.malloc_fails++;
			STATS_UNLOCK();
			return NULL;
		}
	}
	
	suffix = do_cache_alloc(c->thread->suffix_cache);  // 从thread线程的suffix cache中分配内存
	if (suffix == NULL) {
		STATS_LOCK();
		stats.malloc_fails++;
		STATS_UNLOCK();
		out_of_memory(c, "SERVER_ERROR out of memory making CAS suffix");
		return NULL;
	}
	*(c->suffixlist + i) = suffix;
	return suffix;
}

// 将item的标识位写入到申请的内存中
/* client flags == 0 means use no storage for client flags */
static inline int make_ascii_get_suffix(char *suffix, item *it, bool return_cas, int nbytes) {
	char *p = suffix;
	*p = ' ';
	p++;
	if (FLAGS_SIZE(it) == 0) {
		*p = '0';
		p++;
	} else {
		p = itoa_u32(*((uint32_t *) ITEM_suffix(it)), p);
	}
	*p = ' ';
	p = itoa_u32(nbytes-2, p+1);
	
	if (return_cas) {
		*p = ' ';
		p = itoa_u64(ITEM_get_cas(it), p+1);
	}
	
	*p = '\r';
	*(p+1) = '\n';
	*(p+2) = '\0';
	return (p - suffix) + 2;
}

// 将item中value长度超过settings.slab_chunk_size_max时，将value值写入到返回结构中
static int add_chunked_item_iovs(conn *c, item *it, int len) {
	assert(it->it_flags & ITEM_CHUNKED);
	item_chunk *ch = (item_chunk *) ITEM_schunk(it);
	while (ch) {			// 依次遍历将value值写入到iov数组中
		int todo = (len > ch->used) ? ch->used : len;
		if (add_iov(c, ch->data, todo) != 0) {
			return -1;
		}
		ch = ch->next;
		len -= todo;
	}
	return 0;
}
```
### 3.1.1 修改`struct conn`结构体成员
上述代码是`process_get_command`函数的相关代码，从代码中可知其修改了`struct conn`结构体中的如下几个结构体成员(对于`extstore`成员暂不介绍):

1. `iov`数组及相关的`iovused`等，用于记录需要写出的字符串位置以及长度。
2. `msglist`数组及相关的`msgused`等，用于记录需要写出的`iov`数组位置等。
3. `msgcurr`指针，指向`msglist`数组中需要发送的`msghdr`的位置。
2. `ilist`数组，用于记录已经获取的`item`。
3. `icurr`指针，记录`ilist`数组中`item`的开始位置。
4. `ileft`值，用于记录`ilist`中已经记录的`item`个数。
5. `suffixlist`数组，用于记录获取`item`的`suffix`值。
5. `suffixcurr`指针，指向`suffixlist`中本次操作开始的位置。
6. `suffixleft`值，用于记录已经保存好的`item`的`suffix`的个数。

### 3.1.2 记录`item`中`value`值的过程
对于`item`中`value`的长度是否超过`settings.slab_chunk_size_max`进行不同的处理:

* 小于`settings.slab_chunk_size_max`时，调用`add_iov(c, ITEM_data(it), it->nbytes)`将`item`的`value`值加入到返回数据结构中。
* 大于`settings.slab_chunk_size_max`时，调用`add_chunked_item_iovs(c, it, it->nbytes)`函数将`item`的`value`值加入到返回数据结构中。

### 3.1.3 后续操作
通过源代码可以看出来，最终将`conn`的状态置为`conn_mwrite`发送信息。其中`conn_mwrite`状态的处理函数如下:

```
	case conn_mwrite:
#ifdef EXTSTORE
		/** have side IO's that must process before transmit() can run.
		 * remove the connection from the worker thread and dispatch the 
		 * IO queue
		 */
		if (c->io_wrapleft) {				// 判断是否需要从外存读取数据
			assert(c->io_queued == false);
			assert(c->io_wraplist != NULL);
			// TODO: create proper state for this condition
			conn_set_state(c, conn_watch);  // 等待IO读取完成
			event_del(&c->event);
			c->io_queued = true;
			extstore_submit(c->thread->storage, &c->io_wraplist->io);  // 提交IO任务
			stop = true;
			break;
		}
#endif
		if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {
			if (settings.verbose > 0) 
				fprintf(stderr, "Failed to build UDP headers\n");
			conn_set_state(c, conn_closing);
			break;
		}
		switch (transmit(c)) {		// 发送信息
		case TRANSMIT_COMPLETE:		// 发送完成
			if (c->state == conn_mwrite) {
				conn_release_items(c);		// 释放item
				if (c->protocol == binary_prot) {
					conn_set_state(c, c->write_and_go);
				} else {
					conn_set_state(c, conn_new_cmd); // 解析处理新命令
				}
			} else if (c->state == conn_write) {
				if (c->write_and_free) {
					free(c->write_and_free);  // 释放临时空间
					c->write_and_free = 0;
				}
				conn_set_state(c, c->write_and_go);
			} else {
				if (settings.verbose > 0)
					fprintf(stderr, "Unexpected state %d\n", c->state);
				conn_set_state(c, conn_closing);
			}
			break;
		
		// 保持conn状态继续发送信息
		case TRANSMIT_INCOMPLETE:
		case TRANSMIT_HARD_ERROR:
			break;				// Continue in state machine.
		
		case TRANSMIT_SOFT_ERROR:
			stop = true;
			break;
		}
		break;
		
// conn_mwrite中调用的函数
// 发送消息的函数
/*
 * Transmit the next chunk of data from out list of msgbuf structures
 * Returns:
 * 		TRANSMIT_COMPLETE				All done writing.
 * 	 	TRANSMIT_INCOMPLETE				More data remaining to write.
 * 	  	TRANSMIT_SOFT_ERROR				Can't write any more right now.
 * 		TRANSMIT_HARD_ERROR				Can't write (c->state is set to conn_closing).
 */
 static enum transmit_result transmit(conn *c) {
 	assert(c != null);
 	
 	// 对于二进制通信协议或者UDP网络协议存在回复头，进行处理
 	if (c->msgcurr < c->msgused &&
 			c->msglist[c->msgcurr].msg_iovlen == 0) {
 		/* Finished writing the current msg; advance to the next */
 		c->msgcurr++;
 	}
 	if (c->msgcurr < c->msgused) {	// 判断是否发送完毕
 		ssize_t res;
 		struct msgdhr *m = &c->msglist[c->msgcurr]; // 获取需要发送的msghdr
 		
 		res = c->sendmsg(c, m, 0);   // 调用对应的发送信息函数
 		if (res > 0) {
 			pthread_mutex_lock(&c->thread->stats.mutex);
 			c->thread->stats.bytes_written += res;
 			pthread_mutex_unlock(&c->thread->stats.mutex);
 			
 			/* We've written some of the data. Remove the completed
 			 * iovec entries from the list of pending writes. */
 			// 从msghdr中去除已经发送的iov数组数据
 			while (m->msg_iovlen > 0 && res >= m->msg_iov->iov_len) {
 				res -= m->msg_iov->iov_len;
 				m->msg_iovlen--;
 				m->msg_iov++;
 			}
 			
 			/* Might have written just part of the last iovec entry;
 			 * adjust it so the next write will do the rest.
 			 */
 			// 如果最后一个iov发送了一部分数据时，需要调整下次发送的开始位置
 			if (res > 0) {
 				m->msg_iov->iov_base = (caddr_t)m->msg_iov->iov_base + res;
 				m->msg_iov->iov_len -= res;
 			}
 			return TRANSMIT_INCOMPLETE;
 		}
 		if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
 			if (!update_event(c, EV_WRITE | EV_PERSIST)) {
 				if (settings.verbose > 0) 
 					fprintf(stderr, "Couldn't update event\n");
 				conn_set_state(c, conn_closing);
 				return TRANSMIT_HARD_ERROR;
 			}
 			return TRANSMIT_SOFT_ERROR;
 		}
 		/* if res == 0 or res == -1 and error is not EAGAIN or EWOULDBLOCK,
 			we have a real error, on which we close the connection */
 		if (settings.verbose > 0)
 			perror("Failed to write, and not due to blocking");
 			
 		if (IS_UDP(c->transport))
 			conn_set_state(c, conn_read);	 // 设置conn状态为conn_read
 		else
 			conn_set_state(c, conn_closing); // 设置conn状态为conn_closing
 		return TRANSMIT_HARD_ERROR;
 	} else {
 		return TRANSMIT_COMPLETE;
 	}
 }
 
// 发送完成后，conn的成员进行清空处理的函数
static void conn_release_items(conn *c) {
	assert(c != NULL);
	
	if (c->item) {					// 清空set/add/replace操作的item
		item_remove(c->item);
		c->item = 0;
	}
	
	while (c->ileft > 0) {			// 清空process_get_command函数处理的item
		item *it = *(c->icurr);
		assert((it->it_flags & ITEM_SLABBED) == 0);
		item_remove(it);
		c->icurr++;
		c->ileft--;
	}
	
	if (c->suffixleft != 0) {		// 清空process_get_command函数处理的item的suffix结构
		for (; c->suffixleft > 0; c->suffixleft--, c->suffixcurr++) {
			do_cache_free(c->thread->suffix_cache, *(c->suffixcurr));
		}
	}
#ifdef EXTSTORE
	if (c->io_wraplist) {			// 对外存进行清空处理，后续介绍
		io_wrap *tmp = c->io_wraplist;
		while (tmp) {
			io_wrap *next = tmp->next;
			recache_or_free(c, tmp);
			do_cache_free(c->thread->io_cache, tmp); // lockless
			tmp = next;
		}
		c->io_wraplist = NULL;
	}
#endif
	c->icurr = c->ilist;				// 设置开始位置
	c->suffixcurr = c->suffixlist;	// 设置开始位置
}
```
通过介绍`conn_mwrite`状态的操作可以发现在`process_get_command`函数中使用的`conn`结构体成员都在发送数据完成后进行清空。对于`iov\msglist`的恢复操作在`process_command`函数中进行。

## 3.2 `process_update_command`函数
前面介绍完毕`get`等相关操作的函数，本小节将详细介绍客户端向`memcached`写入`item`的整个过程。其源代码如下:

```
static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
	char *key;					// 用于记录key
	size_t nkey;					// key length
	unsigned int flags;			// 记录item的flags值
	int32_t exptime_int = 0;	// 记录item的有效期
	time_t exptime;
	int vlen;						// 用于记录value值的长度
	uint64_t req_cas_id = 0;
	item *it;						// 操作的item
	
	assert(c != NULL);
	
	set_noreply_maybe(c, tokens, ntokens); // 判断是否需要回复信息
	
	if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {   // 判断key长度
		out_string(c, "CLIENT_ERROR bad command line format");
		return;
	}
	
	key = tokens[KEY_TOKENS].value;	// 操作的key值
	nkey = tokens[KEY_TOKENS].length;
	
	if (! (safe_strtoul(tokens[2].value, (uint32_t *)&flags)
			&& safe_strtol(tokens[3].value, &exptime_int)
			&& safe_strtol(tokens[4].value, (int32_t *)&vlen))) {
		out_string(c, "CLIENT_ERROR bad command line format");
		return;
	}
	
	exptime = exptime_int;
	
	/* Negative exptimes can underflow and end up immortal. realtime() will
	   immediately expire values that are greater than REALTIME_MAXDELTA,but less
	   than process_started, so lets aim for that. */
	if (exptime < 0)
		exptime = REALTIME_MAXDELTA + 1;

	// does cas value exist?
	if (handle_cas) {
		if (!safe_strtoull(tokens[5].value, &req_cas_id)) {
			out_string(c, "CLIENT_ERROR bad command line format");
			return;
		}
	}
	
	if (vlen < 0 || vlen > (INT_MAX - 2)) {
		out_string(c, "CLIENT_ERROR bad command line format");
		return;
	}
	vlen += 2;
	
	if (settings.detail_enabled) {
		stats_prefix_record_set(key, nkey);
	}
	
	it = item_alloc(key, nkey, flags,realtime(exptime), vlen);  // 分配item的空间
	
	if (it == 0) {
		enum store_item_type status;
		if (! item_size_ok(nkey, flags, vlen)) {     // 判断item长度是否合适
			out_string(c, "SERVER_ERROR object too large for cache");
			status = TOO_LARGE;
		} else {
			out_of_memory(c, "SERVER_ERROR out of memory storing object");
			status = NO_MEMORY;
		}
		LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE,
				NULL, status, comm, key, nkey, 0, 0);
		/* swallow the data line */
		// 此item无法存储，因此需要丢弃后续发送过来的item value的字节
		c->write_and_go = conn_swallow;
		c->sbytes = vlen;
		
		/* Avoid stale data persisting in cache because we failed alloc.
		   Unacceptable for SET. Anywhere else too? */
		if (comm == NREAD_SET) {			// 判断是否为set操作
			it = item_get(key, nkey, c, DONT_UPDATE);  // 获取key原先的对应的item
			if (it) {				// 去除key对应的陈旧信息
				item_unlink(it);
				STORAGE_delete(c->thread->storage, it);
				item_remove(it);
			}
		}
		
		return;
	}
	ITEM_set_cas(it, req_cas_id);
	
	c->item = it;		// 此处设置conn结构体中item，用于后续操作
	//设置conn结构体中的ritem，用于记录需要读入数据的存放的开始位置
#ifdef NEED_ALIGN
	if (it->it_flags & ITEM_CHUNKED) {
		c->ritem = ITEM_schunk(it);
	} else {
		c->ritem = ITEM_data(it);
	}
#else
	c->ritem = ITEM_data(it);
#endif
	c->rlbytes = it->nbytes;			// 记录需要读取的value数据长度
	c->cmd = comm;						// 记录操作的命令
	conn_set_state(c, conn_nread);   // 设置conn的状态为conn_nread
}
```
### 3.2.1 修改`conn`的结构体成员
通过上述的源代码可知，对`conn`结构体的修改主要有以下几个成员:

1. `write_and_go`,用于指定写操作完成后，设置`conn`的状态值。
2. `sbytes`,需要丢弃的字节长度。
3. `item`,用于记录需要操作的`item`。
4. `ritem`,用于记录后续需要写入字节的起始位置。
5. `rlbytes`,后续需要读取字节的长度。
6. `cmd`,操作的类型(例如:`NREAD_ADD|NREAD_SET`等)。

### 3.2.2 后续操作
在`process_update_command`函数中，根据`item`的空间是否能够申请到或者`value`值是否合适来进行下一步操作。根据`process_update_command`函数调用`item_alloc`的结果，其情况如下:

1. 失败时，设置`write_and_go`为`conn_swallow`。
2. 成功时，设置`conn`的状态为`conn_nread`。

**调用失败时**，后续`conn`的`conn_swallow`状态操作的源代码如下:

```
// 注意此处break操作过程中，没有改变conn的状态
case conn_swallow:
	/* we are reading sbytes and throwing them away */
	if (c->sbytes <= 0) {		// 判断是否还有需要丢弃的字符
		conn_set_state(c, conn_new_cmd);	 // 设置后续操作状态
		break;
	}
	
	/* first check if we have leftovers in the conn_read buffer */
	if (c->rbytes > 0) {		// 判断上次读取空间rbuf中是否还有value数据
		int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;
		c->sbytes -= tocopy;	// 减少需要丢弃的字节数
		c->rcurr += tocopy;		// 设置rbuf中新的需要处理的字节开始位置
		c->rbytes -= tocopy;	// 计算还能够解析的字节个数
		break;
	}
	
	/* now try reading from the socket */
	res = c->read(c, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize); // 从网络套接字读取需要丢弃的数据
	if (res > 0) {
		pthread_mutex_lock(&c->thread->stats.mutex);
		c->thread->stats.bytes_read += res;
		pthread_mutex_unlock(&c->thread->stats.mutex);
		c->sbytes -= res;		// 减少需要丢弃的字节个数
		break;
	}
	if (res == 0) {	// end of stream
		conn_set_state(c, conn_closing);	 // 设置通信结束
		break;
	}
	if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
		if (!update_event(c, EV_READ | EV_PERSIST)) {
			if (settings.verbose > 0)
				fprintf(stderr, "Couldn't update event\n");
			conn_set_state(c, conn_closing);
			break;
		}
		stop = true;
		break;
	}
	/* otherwise we have a real error, on which we close the connection */
	if (settings.verbose > 0)
		fprintf(stderr, "Failed to read, and not due to blocking\n");
	conn_set_state(c, conn_closing);
	break;
```
通过上述源代码可知其操作很简单，就是根据`sbytes`(需要丢弃的字节个数)来反复读取文件描述符中发送过来的数据，直到不需要丢弃字节为止，然后设置`conn`的状态为`conn_new_cmd`，进行下一个命令的读取执行。

**调用成功时**，后续`conn`的`conn_nread`状态操作的源代码如下:

```
case conn_nread:
	if (c->rlbytes == 0) {		// 判断是否读取完成,c->rlbytes用于记录需要读取的字节数
		complete_nread(c);		// 读取完成调用的函数
		break;
	}
	
	/* Check if rbytes < 0, to prevent crash */
	if (c->rlbytes < 0) {
		if (settings.verbose) {
			fprintf(stderr, "Invalid rlbytes to read: len %d\n", c->rlbytes);
		}
		conn_set_state(c, conn_closing);
		break;
	}
	// 开始读取数据，存放在ritem位置
	if (!c->item || (((item *)c->item)->it_flags & ITEM_CHUNKED) == 0) {
		// 当item的value值长度小于settings.slab_chunk_size_max时
		if (c->rbytes > 0) {   // 判断rbuf是否存在未被读取属于value的字节
			int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes; // 判断能够拷贝的字节个数
			if (c->ritem != c->rcurr) {
				memmove(c->ritem, c->rcurr, tocopy); // 将值拷贝到item的value位置上
			}
			c->ritem += tocopy;		// value值需要写入的开始位置
			c->rlbytes -= tocopy;	// 还需要读取的value值长度
			c->rcurr += tocopy;		// 记录未处理的已读取字节的开始位置
			c->rbytes -= tocopy;	// 还需要处理的字节个数
			if (c->rlbytes == 0) {	// 判断是否还需要继续读取
				break;
			}
		}
		
		/* now try reading from the socket */
		res = c->read(c, c->ritem, c->rlbytes);  // 此处直接读取到item value的位置上
		if (res > 0) {
			pthread_mutex_lock(&c->thread->stats.mutex);
			c->thread->stats.bytes_read += res;
			pthread_mutex_unlock(&c->thread->stats.mutex);
			if (c->rcurr == c->ritem) {
				c->rcurr += res;
			}
			c->ritem += res;				// value值需要写入的开始位置
			c->rlbytes -= res;			// 还需要读取的value值长度
			break;
		}
	} else {
		res = read_into_chunked_item(c);	  // 读取item value值长度大于settings.slab_chunk_size_max时调用
		if (res > 0)
			break;
	}
	
	if (res == 0) {		// end of stream
		conn_set_state(c, conn_closing);	// 将conn状态设置为conn_closing
		break;
	}
	
	// 当读取出问题时
	if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
		if (!update_event(c, EV_READ | EV_PERSIST)) {
			if (settings.verbose > 0)
				fprintf(stderr, "Couldn't update event\n");
			conn_set_state(c, conn_closing);
			break;
		}
		stop = true;
		break;
	}
	
	// 当内存不够时，将丢弃后续字符
	// Memory allocation failure
	if (res == -2) {
		out_of_memory(c, "SERVER_ERROR Out of memory during read");
		c->sbytes = c->rlbytes;		// 需要丢弃的字符个数
		c->write_and_go = conn_swallow;	// 写出后，conn将要置为的状态
		break;
	}
	// otherwise we have a real error, on which we close the connection
	if (settings.verbose > 0) {
		fprintf(stderr, "Failed to read, and not due to blocking:\n"
				"errno: %d %s \n"
				"rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\n",
				errno, strerror(errno),
				(long)c->rcurr, (long)c->ritem, (long)c->rbuf,
				(int)c->rlbytes, (int)c->rsize);
	}
	conn_set_state(c, conn_closing);		// 将conn的状态设置为conn_closing
	break;
	
// 读取item value值长度大于settings.slab_chunk_size_max时调用的函数
/* Does a looped read to fill data chunks
 * TODO: restrict number of times this can loop
 * Also, benchmark using readv's
 */
// 根据需要读取的字符个数，申请chunk空间，将读取数据存放在chunk空间中，直到读取完毕
static int read_into_chunked_item(conn *c) {
	int total = 0;
	int res;
	assert(c->rcurr != c->ritem);
	
	while (c->rlbytes > 0) {
		item_chunk *ch = (item_chunk *)c->ritem;  // 将item的value值开始的位置变成item_chunk结构体，用来记录后续的value数据存放位置
		if (ch->size == ch->used) {	// 判断可用与已用的大小
			// FIXME: ch->next is currently always 0. remove this?
			if (ch->next) {
				c->ritem = (char *)ch->next;
			} else {
				/* Allocate next chunk. Binary protocol needs 2b for \r\n */
				// 分配新的chunk空间来存放value值,分配的内存仅在item中进行记录，不会体现在hash链表和lru链表中
				c->ritem = (char*) do_item_alloc_chunk(ch, c->rlbytes + ((c->protocol == binary_prot) ? 2 : 0));
				if (!c->ritem) {
					// we failed an allocation. Let caller handle cleanup.
					// 内存分配失败
					total = -2;
					break;
				}
				// ritem has new chunk, restart the loop
				continue;
				// assert(c->rlbytes == 0);
			}
		}
		
		int unused = ch->size - ch->used;	   // 判断还能够存放多少字节
		// first check if we have leftovers in the conn_read buffer
		if (c->rbytes > 0) {	// 判断rbuf中是否还有未被消化的value值数据
			total = 0;
			int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
			tocopy = tocopy > unused ? unused : tocopy;
			if (c->ritem != c->rcurr) {
				memmove(ch->data + ch->used, c->rcurr, tocopy);
			}
			total += tocopy;
			c->rlbytes -= tocopy;		// 还需要读取多少个字节
			c->rcurr += tocopy;			// rbuf数组中未被处理的字节开始位置
			c->rbytes -= tocopy;		// 减少未被处理字节的个数
			ch->used += tocopy;			// chunk中使用的字节个数
			if (c->rlbytes == 0) {
				break;
			}
		} else {
			/* now try reading from the socket */
			res = c->read(c, ch->data + ch->used,
						(unused > c->rlbytes ? c->rlbytes : unused); // 将数据直接读取到chunk中
			if (res > 0) {
				pthread_mutex_lock(&c->thread->stats.mutex);
				c->thread->stats.bytes_read += res;
				pthread_mutex_unlock(&c->thread->stats.mutex);
				ch->used += res;		// chunk中使用的字节个数
				total += res;
				c->rlbytes -= res;	// 还需要读取多少个字节
			} else {
				/* Reset total to the latest result so caller can handle it */
				total = res;
				break;
			}
		}
	}
	
	/* At some point I will be able to ditch the \r\n from item stroage and
	 * remove all of these kludges.
	 * The above binprot check ensures inline space for \r\n, but if we do
	 * exactly enough allocs these will be no additional chunk for \r\n.
	 */
	if (c->rlbytes == 0 && c->protocol == binary_prot && total >= 0) {
		item_chunk *ch = (item_chunk *)c->ritem;
		if (ch->size - ch->used < 2) {
			c->ritem = (char *)do_item_alloc_chunk(ch, 2);
			if (!c->ritem) {
				total = -2;
			}
		}
	}
	return total;
}

// 申请chunk空间的函数
/* Chain another chunk onto this chunk. */
/* slab mover: if it finds a chunk without ITEM_CHUNK flag, and no ITEM_LINKED
 * flag, it counts as busy and skips.
 * I think it might still not be safe to do linking outside of the slab lock
 */
item_chunk *do_item_alloc_chunk(item_chunk *ch, const size_t bytes_remain) {
	// TODO: Should be a cleaner way of finding real size with slabber calls
	size_t size = bytes_remain + sizeof(item_chunk); // 需要申请空间的大小
	if (size > settings.slab_chunk_size_max)
		size = settings.slab_chunk_size_max;
	unsigned int id = slabs_clsid(size);	 // 根据大小判断使用哪个slab
	
	item_chunk *nch = (item_chunk *)do_item_alloc_pull(size, id); //申请chunk空间，无item头，仅有item_chunk头
	if (nch == NULL)
		return NULL;
	
	// link in. 仅链接在value存放在的item value字段中item_chunk链表中
	// ITEM_CHUNK[ED] bits need to be protected by the slabs lock.
	slabs_mlock();
	// 初始化item_chunk头部信息
	nch->head = ch->head;
	ch->next = nch;
	nch->prev = ch;
	nch->next = 0;
	nch->used = 0;
	nch->slabs_clsid = id;
	nch->size = size - sizeof(item_chunk);
	nch->it_flags |= ITEM_CHUNK;
	slabs_munlock();
	return nch;
}

// 当item的value值读取完毕后，进行调用的函数
static void complete_nread(conn *c) {
	assert(c != NULL);
	assert(c->protocol == ascii_prot
			|| c->protocol == binary_prot);
			
	if (c->protocol == ascii_prot) {		// ASCII解析协议
		complete_nread_ascii(c);			// 当读取item value值完毕时调用
	} else if (c->protocol == binary_prot) {  // 二进制解析协议
		complete_nread_binary(c);			 // 本文不做介绍，可以自行阅读(类比ASCII即可)
	}
}

/*
 * we get here after reading the value in set/add/replace commands. The command
 * has been stored in c->cmd, and the item is ready in c->item.
 */
static void complete_nread_ascii(conn *c) {
	assert(c != NULL);
	
	item *it = c->item;			// 记录操作的item
	int comm = c->cmd;			// 记录执行的命令
	enum store_item_type ret;
	bool is_valid = false;		// 判断是否有效,即最后两个字符是否为\r\n
	
	pthread_mutex_lock(&c->thread->stats.mutex);
	c->thread->stats.slab_stats[ITEM_clsid(it)].set_cmds++;
	pthread_mutex_unlock(&c->thread->stats.mutex);
	
	if ((it->it_flags & ITEM_CHUNKED) == 0) {
		if (strncmp(ITEM_data(it) + it->nbytes - 2, "\r\n", 2) == 0) {
			is_valid = true;
		}
	} else {
		char buf[2];
		/* should point to the final item chunk */
		item_chunk *ch = (item_chunk *)c->ritem; // 注意此处为ritem，即最后的写入位置
		assert(ch->used != 0);
		/* :( We need to look at the last two bytes. This could span two
		 * chunks.
		 */
		 // 可能横跨两个chunk
		if (ch->used > 1) {
			buf[0] = ch->data[ch->used - 2];
			buf[1] = ch->data[ch->used - 1];
		} else {
			assert(ch->prev);
			assert(ch->used == 1);
			buf[0] = ch->prev->data[ch->prev->used - 1];
			buf[1] = ch->data[ch->used - 1];
		}
		if (strncmp(buf, "\r\n", 2) == 0) {
			is_valid = true;
		} else {
			assert(1 == 0);
		}
	}
	
	// 判断是否有效
	if (!is_valid) {
		out_string(c, "CLIENT_ERROR bad data chunk");
	} else {
		ret = store_item(it, comm, c);	// 根据命令对item进行后续操作
		
		// 其他代码
		
		switch (ret) {
		case STORED:
			out_string(c, "STORED");
			break;
		case EXISTS:
			out_string(c, "EXISTS");
			break;
		case NOT_FOUND:
			out_string(c, "NOT_FOUND");
			break;
		case NOT_STORED:
			out_string(c, "NOT_STORED");
			break;
		default:
			out_string(c, "SERVER_ERROR Unhandled storage type.");
		}
	}
	
	item_remove(c->item);		// release the c->item reference
	c->item = 0;					// 置空操作的item
}

// 根据命令进行item存储的操作
/*
 * Stores on item in the cache (high level, obeys set/add/replace sematics)
 */
enum store_item_type store_item(item *item, int comm, conn* c) {
	enum store_item_type ret;
	uint32_t hv;
	
	hv = hash(ITEM_key(item), item->nkey);
	item_lock(hv);
	ret = do_store_item(item, comm, c, hv);
	item_unlock(hv);
	return ret;
}

/*
 * Stores an item in the cache according to the sematics of one of the set
 * commands. In threaded mode, this is protected by the cache lock.
 * Returns the state of storage.
 */
// 根据命令来进行后续的处理操作
enum store_item_type do_store_item(item *it, int comm, conn *c, const uint32_t hv) {
	char *key = ITEM_key(it);
	item *old_it = do_item_get(key, it->nkey, hv, c, DONT_UPDATE); // 获取原来的item
	enum store_item_type stored = NOT_STORED;  // 返回值
	
	item *new_it = NULL;
	uint32_t flags;
	
	if (old_it != NULL && comm == NREAD_ADD) { // 当命令是add操作时
		// add only adds a nonexistent item, but promote to head of LRU
		do_item_update(old_it);				// 今更新原来的item的热度，不会进行修改操作
	} else if (!old_it && (comm == NREAD_REPLACE
			|| comm == NREAD_APPEND || comm == NREAD_PREPEND)) {
		// replace only replaces an existing value; don't store
	} else if (comm == NREAD_CAS) {
		// validate cas operation
		if (old_it == NULL) {
			// LRU expired
			stored = NOT_FOUND;
			pthread_mutex_lock(&c->thread->stats.mutex);
			c->thread->stats.cas_misses++;
			pthread_mutex_unlock(&c->thread->stats.mutex);
		} else if (ITEM_get_cas(it) == ITEM_get_cas(old_it)) {
			// cas validates
			// it and old_it may belong to different classes
			// I‘m updating the stats for the one that's getting pushed out.
			pthread_mutex_lock(&c->thread->stats.mutex);
			c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_hits++;
			pthread_mutex_unlock(&c->thread->stats.mutex);
			
			STORAGE_delete(c->thread->storage, old_it);
			item_replace(old_it, it, hv);	 // 进行替换操作
			stored = STORED;
		} else {
			pthread_mutex_lock(&c->thread->stats.mutex);
			c->thread->stats.slab_stats[ITEM_clsid(old_it)].cas_badval++;
			pthread_mutex_unlock(&c->thread->stats.mutex);
			
			if (settings.verbose > 1) {
				fprintf(stderr, "CAS: failure: expected %llu, got %llu\n",
							(unsigned long long)ITEM_get_cas(old_it),
							(unsigned long long)ITEM_get_cas(it));
			}
			stored = EXISTS;
		}
	} else {
		int failed_alloc = 0;
		/*
		 * Append - combine new and old record into single one. Here it's
		 * atomic and thread-safe.
		 */
		if (comm == NREAD_APPEND || comm == NREAD_PREPEND) {
			if (ITEM_get_cas(it) != 0) {
				// CAS much be equal
				if (ITEM_get_cas(it) != ITEM_get_cas(old_it)) {
					stored = EXISTS;
				}
			}
#ifdef EXTSTORE
			if ((old_it->it_flags & ITEM_HDR) != 0) {
				/* block append/prepend from working with extstore-d items.
				 * also don't replace the header with the append chunk
				 * accidentally, so mark as a failed_alloc.
				 */
				 failed_alloc = 1;
			} else
#endif
			if (stored == NOT_STORED) {
				/* we have it and old_it here - alloc memory to hold both
				 * flags was already lost - so recover them from ITEM_suffix(it) */
				FLAGS_CONV(old_it, flags);
				new_it = do_item_alloc(key, it->nkey, flags, old_it->exptime, it->nbytes + old_it->nbytes - 2 /* CRLF */); // 分配新存储空间
				// copy data form it and old_it to new_it
				// 用于向item的value前后插入数据
				if (new_it == NULL || _store_item_copy_data(comm, old_it, new_it, it) == -1) {
					failed_alloc = 1;
					stored = NOT_STOREAD;
					// failed data copy, free up
					if (new_it != NULL)
						item_remove(new_it);
				} else {
					it = new_it;		// it指向新空间
				}
			}
		}
		
		if (stored == NOT_STORED && failed_alloc == 0) {
			if (old_it != NULL) {
				STORAGE_delete(c->thread->storage, old_it);
				item_replace(old_it, it, hv);
			} else {
				do_item_link(it, hv);
			}
			
			c->cas = ITEM_get_cas(it);
			
			stored = STORED;
		}
	}
	
	if (old_it != NULL)
		do_item_remove(old_it);		// release our reference
	if (new_it != NULL)
		do_item_remove(new_it);
		
	if (stored = STORED) {
		c->cas = ITEM_get_cas(it);
	}
	LOGGER_LOG(c->thread->l, LOG_MUTATIONS, LOGGER_ITEM_STORE, NULL,
		stored, comm, ITEM_key(it), it->nkey, it->exptime, ITEM_clsid(it));
	
	return stored;
}
```
整个后续操作的流程比较长，下面用图示来描述整个流程(`item`在`do_store_item`函数中链接入`LRU`链表和`Hash`链表中):

![process_update_command函数流程](https://github.com/whynotAC/analysis_memcached/blob/master/thread/process_update_command流程.png)

根据`process_update_command`函数流程中可知当`item`的`value`值长度超过`settings.slab_chunk_size_max`时，其存储情况如下所示:

![item_chunk存储方式](https://github.com/whynotAC/analysis_memcached/blob/master/thread/item_chunk存储方式.png)

## 3.3 `process_arithmetic_command`函数
针对`incr`和`decr`命令的处理源代码如下:

```
static void process_arithmetic_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
	char temp[INCR_MAX_STORAGE_LEN];
	uint64_t delta;
	char *key;
	size_t nkey;
	
	assert(c != NULL);
	
	set_noreply_maybe(c, tokens, ntokens);
	
	if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
		out_string(c, "CLIENT_ERROR bad command line format");
		return;
	}
	
	key = tokens[KEY_TOKEN].value;
	nkey = tokens[KEY_TOKEN].length;
	
	if (!safe_strtoull(tokens[2].value, &delta)) {
		out_string(c, "CLIENT_ERROR invalid numeric delta argument");
		return;
	}
	
	switch(add_delta(c, key, nkey, incr, delta, temp, NULL)) {  // 对item进行操作
	case OK:
		out_string(c, temp);
		break;
	case NON_NUMERIC:
		out_string(c, "CLIENT_ERROR cannot increment or decrement non-numeric value");
		break;
	case EOM:
		out_of_memory(c, "SERVER_ERROR out of memory");
		break;
	case DELTA_ITEM_NOT_FOUND:
		pthread_mutex_lock(&c->thread->stats.mutex);
		if (incr) {
			c->thread->stats.incr_misses++;
		} else {
			c->thread->stats.decr_misses++;
		}
		pthread_mutex_unlock(&c->thread->stats.mutex);
		
		out_string(c, "NOT_FOUND");
		break;
	case DELTA_ITEM_CAS_MISMATCH:
		break;		// Should never get here
	}
}

/*
 * Does arithmetic on a numeric item value.
 */
enum delta_result_type add_delta(conn *c, const char *key,
						const size_t nkey, bool incr,
						const int64_t delta, char *buf,
						uint64_t *cas) {
	enum delta_result_type ret;
	uint32_t hv;
	
	hv = hash(key, nkey);
	item_lock(hv);
	ret = do_add_delta(c, key, nkey, incr, delta, buf, cas, hv);   // 具体操作
	item_unlock(hv);
	return ret;
}

/*
 * adds a delta value to a numeric item.
 * c 		connection requesting the operation
 * it 		item to adjust
 * incr	true to increment value, false to decrement
 * delta	amonut to adjust value by
 * buf		buffer for response string
 * returns a response string to send back to the client.
 */
enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
					const bool incr, const int64_t delta,
					char *buf, uint64_t *cas,
					const uint32_t hv) {
	char *ptr;
	uint64_t value;
	int res;
	item *it;
	
	it = do_item_get(key, nkey, hv, c, DONT_UPDATE);   // 获取原来存储的item
	if (!it) {								 // 当item不存在时
		return DELTA_ITEM_NOT_FOUND;
	}
	
	// Can't delta zero byte values. 2-bytes are the "\r\n"
	// Also can't delta for chunked items. Too large to be a number
	// 不能为数字的情况
#ifdef EXTSTORE
	if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {
#else
	if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) !=0) {
#endif
		do_item_remove(it);
		return NON_NUMERIC;
	}
	
	if (cas != NULL && *cas != 0 && ITEM_get_cas(it) != *cas) {
		do_item_remove(it);
		return DELTA_ITEM_CAS_MISMATCH;
	}
	
	ptr = ITEM_data(it);		// 获取value值
	
	if (!safe_strtoull(ptr, &value)) {
		do_item_remove(it);
		return NON_NUMERIC;
	}
	
	if (incr) {					// 对值进行操作
		value += delta;
		MEMCACHED_COMMAND_INCR(c->sfd, ITEM_key(it), it->nkey, value);
	} else {
		if (delta > value) {
			value = 0;
		} else {
			value -= delta;
		}
		MEMCACHED_COMMAND_DECR(c->sfd, ITEM_key(it), it->nkey, value);
	}
	
	pthread_mutex_lock(&c->thread->stats.mutex);
	if (incr) {
		c->thread->stats.slab_stats[ITEM_clsid(it)].incr_hits++;
	} else {
		c->thread->stats.slab_stats[ITEM_clsid(it)].decr_hits++;
	}
	pthread_mutex_unlock(&c->thread->stats.mutex);
	
	itoa_u64(value, buf);		// 获取最终结果
	res = strlen(buf);
	/* refcount == 2 means we are the only ones holding the item, and it is
	 * linked. We hold the item's lock in this function, so refcount cannot
	 * increase. */
	if (res + 2 <= it->nbytes && it->refcount == 2) {  // replace in-place
		// 当只有当前线程在操作此item时进行的操作
		/* When changing the value without replacing the item, we
		 * need to update the CAS on the existing item.
		 * We also need to fiddle it in the sizes tracker in case the tracking
		 * was enabled at rentime, since it relies on the CAS value to know
		 * whether to remove an item or not.
		 */
		item_stats_sizes_remove(it);
		ITEM_set_cas(it, (settings.use_cas) ? get_cas_id() : 0);
		item_stats_sizes_add(it);
		memcpy(ITEM_data(it),buf, res);
		memset(ITEM_data(it) + res, ' ', it->nbytes - res - 2);
		do_item_update(it);
	} else if (it->refcount > 1) {
		// 当有多个线程操作此item时进行操作
		item *new_it;
		uint32_t flags;
		FLAGS_CONV(it, flags);
		// 申请新空间后，复制原有数据标识
		new_it = do_item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, res + 2);
		if (new_it == 0) {
			do_item_remove(it);
			return EOM;
		}
		memcpy(ITEM_data(new_it), buf, res);
		memcpy(ITEM_data(new_it) + res, "\r\n", 2);
		item_replace(it, new_it, hv);		// 进行替换操作
		// Overwrite the older item's CAS with our new CAS since we're
		// returning the CAS of the old item below.
		ITEM_set_cas(it, (settings.use_cas ? ITEM_get_cas(new_it) : 0);
		do_item_remove(new_it);			// release out reference
	} else {
		// Should never get here. This means we somehow fetched an unlinked
		// item.
		if (settings.verbose) {
			fprintf(stderr, "Tried to do incr/decr on invalid item\n");
		}
		if (it->refcount == 1)
			do_item_remove(it);
		return DELTA_ITEM_NOT_FOUND;
	}
	
	if (cas) {
		*cas = ITEM_get_cas(it);	// swap the incoming CAS value
	}
	do_item_remove(it);			// release out reference
	return OK;
}
```
### 3.3.1 函数执行的流程
由函数的源代码可以看出，`process_arithmetic_command`函数执行过程中并没有改变`conn`结构中的重要成员。其流程执行过程如下:

![process_arithmetic_command函数流程](https://github.com/whynotAC/analysis_memcached/blob/master/thread/process_arithmetic_command函数流程.png)

### 3.3.2 后续执行过程
通过`process_arithmetic_command`函数的返回是由`out_string`函数产生，其将`conn`的状态置为`conn_write`。此状态对应的操作的源代码如下:

```
case conn_write:
	/*
	 * We want to write out a simple response. If we haven't already,
	 * assemble it into a smgbuf list (this will be a single-entry
	 * list for TCP or a two-entry list for UDP).
	 */
	if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {
		if (add_iov(c, c->wcurr, c->wbytes) != 0) {
			if (settings.verbose > 0)
				fprintf(stderr, "Couldn't build response\n");
			conn_set_state(c, conn_closing);
			break;
		}
	}
	
	// fall through
	// 注意这里没有break

case conn_mwrite:
	// conn_mwrite操作
```
由源代码可以看出来，对于`conn_write`操作是把需要发送的字符加入到`iov`数组中，然后通过`conn_mwrite`状态的操作把数据发送出去。

## 3.4 `process_delete_command`函数
此函数针对于`delete`操作，其源代码如下:

```
static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
	char *key;
	size_t nkey;
	item *it;
	uint32_t hv;
	
	assert(c != NULL);
	
	if (ntokens > 3) {
		bool hold_is_zero = strcmp(tokens[KEY_TOKEN+1].value, "0") == 0;
		bool sets_noreply = set_noreply_maybe(c, tokens, ntokens);
		bool valid = (ntokens == 4 && (hold_is_zero || sets_noreply))
				|| (ntokens == 5 && hold_is_zero && sets_noreply);
		if (!valid) {
			out_string(c, "CLIENT_ERROR bad command line format.  "
							"Usage: delete <key> [noreply]";
			return;
		}
	}
	
	key = tokens[KEY_TOKEN].value;
	nkey = tokens[KEY_TOKEN].length;
	
	if (nkey > KEY_MAX_LENGTH) {
		out_string(c, "CLIENT_ERROR bad command line format");
		return;
	}
	
	if (settings.detail_enabled) {
		stats_prefix_record_delete(key, nkey);
	}
	// 注意item锁定和解锁的时间
	it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);  // 获取并锁定item
	if (it) {
		MEMCACHED_COMMAND_DELETE(c->sfd, ITEM_key(it), it->nkey);
		
		pthread_mutex_lock(&c->thread->stats.mutex);
		c->thread->stats.slab_stats[ITEM_clsid(it)].delete_hits++;
		pthread_mutex_unlock(&c->thread->stats.mutex);
		
		do_item_unlink(it, hv);			// 此处解除item的hash链表和LRU链表
		STORAGE_delete(c->thread->storage, it);
		do_item_remove(it);				// release our reference
		out_string(c, "DELETED");
	} else {
		pthread_mutex_lock(&c->thread->stats.mutex);
		c->thread->stats.delete_misses++;
		pthread_mutex_unlock(&c->thread->stats.mutex);
		
		out_string(c, "NOT_FOUND");	
	}
	item_unlock(hv);
}
```
### 3.4.1 函数执行的流程
由源代码可知其操作较为简单，仅将`item`从`LRU`链表和`Hash`链表中去除掉，然后返回操作结果。

## 3.5 `process_touch_command`函数
此函数针对的是`touch`操作，其源代码如下:

```
static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
	char *key;
	size_t nkey;
	int32_t exptime_int = 0;
	item *it;
	
	assert(c != NULL);
	
	set_noreply_maybe(c, tokens, ntokens);
	
	if (tokens[KEY_TOKEN].length > KEY_MAX_LENGTH) {
		out_string(c, "CLIENT_ERROR bad command line format");
		return;
	}
	
	key = tokens[KEY_TOKEN].value;
	nkey = tokens[KEY_TOKEN].length;
	
	if (!safe_strtol(tokens[2].value, &exptime_int)) {
		out_string(c, "CLIENT_ERROR invalid exptime argument");
		return;
	}
	
	it = item_touch(key, nkey, realtime(exptime_int), c);  // 更新item的有效期
	if (it) {
		pthread_mutex_lock(&c->thread->stats.mutex);
		c->thread->stats.touch_cmds++;
		c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
		pthread_mutex_unlock(&c->thread->stats.mutex);
		
		out_string(c, "TOUCHED");
		item_remove(it);
	} else {
		pthread_mutex_lock(&c->thread->stats.mutex);
		c->thread->stats.touch_cmds++;
		c->thread->stats.toush_misses++;
		pthread_mutex_unlock(&c->thread->stats.mutex);
		
		out_string(c, "NOT_FOUND");
	}
}
```
此函数的过程较为简单，读者自行阅读。

## 3.6 `process_stat`函数
这个函数的操作针对于`stat`操作，用于统计`memcached`的所有信息。其源代码如下:

```
static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {
	const char *subcommand = tokens[SUBCOMMAND_TOKEN].value;
	assert(c != NULL);
	
	if (ntokens < 2) {
		out_string(c, "CLIENT_ERROR bad command line");
		return;
	}
	
	if (ntokens == 2) {				// 获取主要统计信息
		server_stats(&append_stats, c);
		(void)get_stats(NULL, 0, &append_stats, c);
	} else if (strcmp(subcommand, "reset") == 0) { // 重新进行统计
		stats_reset();
		out_string(c, "RESET");
		return;
	} else if (strcmp(subcommand, "detail") == 0) { // 详细信息统计
		if (ntokens < 4)
			process_stats_detail(c, "");
		else
			process_stats_detail(c, tokens[2].value);
		return;
	} else if (strcmp(subcommand, "settings") == 0) { // 设置信息统计
		process_stat_settings(&append_stats, c);
	} else if (strcmp(subcommand, "cachedump") == 0) { // cachedump统计
		char *buf;
		unsigned int bytes, id, limit = 0;
		
		if (!settings.dump_enabled) {
			out_string(c, "CLIENT_ERROR stats cachedump not allowed");
			return;
		}
		
		if (ntokens < 5) {
			out_string(c, "CLIENT_ERROR bad command line");
			return;
		}
		
		if (!safe_strtoul(tokens[2].value, &id) ||
		 		!safe_strtoul(tokens[3].value, &limit)) {
			out_string(c, "CLIENT_ERROR bad command line format");
			return; 
		}
		
		if (id >= MAX_NUMBER_OF_SLAB_CLASSES) {
			out_string(c, "CLIENT_ERROR Illegal slab id");
			return;
		}
		
		buf = item_cachedump(id, limit, &bytes);
		write_and_free(c, buf, bytes);
		return;
	} else if (strcmp(subcommand, "conns") == 0) {  // conn状态统计
		process_stats_conns(&append_stats, c);
#ifdef EXTSTORE
	} else if (strcmp(subcommand, "extstore") == 0) { // 外存信息统计
		process_extstore_stats(&append_stats, c);
#endif
	} else {
		/* getting here means that the subcommand is either engine specific or
		   is invalid. query the engine and see */
		if (get_stats(subcommand, strlen(subcommand), &append_stats, c)) {
			if (c->stats.buffer == NULL) {
				out_of_memory(c, "SERVER_ERROR out of memory writing stats");
			} else {
				write_and_free(c, c->stats.buffer, c->stats.offset);
				c->stats.buffer = NULL;
			}
		} else {
			out_string(c, "ERROR");
		}
		return;
	}
	
	/* append terminator and start the transfer */
	append_stats(NULL, 0, NULL, 0, c);
	
	if (c->stats.buffer == NULL) {
		out_of_memory(c, "SERVER_ERROR out of memory writring stats");
	} else {
		write_and_free(c, c->stats.buffer, c->stats.offset);
		c->stats.buffer = NULL;
	}
}
```
上述代码也较为简单，不做详细介绍了。

# 4. 总结
至此所有命令以及`conn`的状态都介绍完毕。通过`process_get_command`命令和`process_update_command`命令的处理过程，我们可以看出`memcached`在处理过程中尽量少的使用字符拷贝操作，从而提高效率。
