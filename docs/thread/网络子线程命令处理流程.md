网络子线程命令处理流程
============================
前面介绍了`memcached`的网络模型，以及对应网络套接字的整个生命周期。本文将详细介绍，`memcached`网络子线程在处理网络套接字发送过来命令信息的处理流程，以及如何跟原来介绍过的`slab`、`hash`和`item`相结合。`memcached`处理套接字命令的流程都被封装在`memcached.c`文件中的`dirve_machine`函数中，主要使用的结构体为`struct conn`，这将成为重点的介绍对象。

## 0.基础命令介绍
首先介绍一下，`memcached`支持的通信协议有一下三种:

* `local_transport`,本地通信
* `tcp_transport`,tcp通信协议(重点介绍对象)
* `udp_transport`,udp通信协议(处理较为简单，自行学习)

三种通信协议由`network_transport`枚举来定义，其在`memcached`中的定义如下:

```
enum network_transport {
	local_transport,
	tcp_transport,
	udp_transport
};
```

其次，`memcached`支持的命令解析协议由一下三种:

* `ascii_prot`,ASCII字节码命令解析
* `binary_prot`,二进制命令解析
* `negotiating_prot`,根据发送过来命令的字节解析是`ascii_prot`还是`binary_prot`命令

三种命令解析协议由`protocol`枚举来定义，其在`memcached`中的定义如下:

```
enum protocol {
	ascii_prot = 3,
	binary_prot,
	negotiating_prot
};
```
备注:命令解析协议仅在命令解析时不同，在`item`获取处理层面达成统一，后续会介绍。

`memcached`常用的命令有一下几种(以`ASCII`命令为例):

| 命令类型 | 命令集合 |
| ------- | -------|
| 存储命令 | `add/set/repalce/append/prepend/cas` |
| 查找命令 | `get/gets/delete/incr/decr` |
| 统计命令 | `stats/stats item/stats slabs/stats size/flush_all`|

每种命令的更加详细的使用方式、具体的参数，可以点击[传送门](https://www.runoob.com/memcached/memcached-add-data.html)（虽然传送门里面的命令不是都正确，但是也能大致了解一下命令）。

**补充知识点:**

`memcached`中在发送数据时，使用了两种系统自带的结构体，从而减少发送内容在用户态和系统态之间的拷贝，加速网络信息发送。其结构体如下:

```
struct msghdr {
	void 			*msg_name;		// optional address
	socklen_t 	msg_namelen;		// size of address
	struct	iovec 	*msg_iov;			// scatter/gather array
	int 			msg_iovlen;		// # elements in msg_iov
	void			*msg_control;		// ancillary data, see below
	socklen_t 	msg_controllen;	// ancillary data buffer len
	int				msg_flags;		// flags on received message
};
// 详细的成员介绍可以在linux机器上shell中执行 man recv

struct iovec {
	char 		*iov_base;		// Base address
	size_t		iov_len;			// length
};
// 详细的成员介绍可以man 2 read
```
对于`struct msghdr`结构体可以使用系统的`sendmsg`函数来发送出去。

## 1.结构体与枚举值
任何程序都离不开合适的结构体来实现其相应的算法或者函数，本小节将详细介绍`memcached`使用的结构体，从而更加清楚的介绍后面的函数处理流程。

网络套接的使用的结构体`staruct conn`(在`memcached.h`文件中):

```
/**
 * The structure representing a connection into memcached.
 */
struct conn {
	int sfd;	// 使用的文件描述符/网络套接字
#ifdef TLS	// 使用SSL安全时需要注意的结构体成员，本文将不做介绍
	SSL *ssl;
	char *ssl_wbuf;
	bool ssl_enabled;
#endif
	sasl_conn_t *sasl_conn;	// 有关认证一类的安全，本文都不做介绍
	bool sasl_started; // 有关认证一类的安全，本文都不做介绍
	bool authenticated;	// 有关认证一类的安全，本文都不做介绍
	
	enum conn_states state;		// 链接字处于的状态，drive_machine函数处理struct conn的主要状态依据
	enum bin_substates substate; // 二进制命令处理时的命令头
	
	rel_time_t last_cmd_time;	// 最后处理命令的时间戳，用于判断是否空闲超时
	
	struct event event;	 // 用于libevent的结构体成员
	short ev_flags;
	short which;		/** which events were just in triggered */
	
	// struct conn读入命令的重要结构体成员
	char 	*rbuf; /** buffer to read commands into */
	char 	*rcurr; /** but if we parsed some already, this is where we stopped */
	int 	rsize; /** total allocated size of rbuf */
	int 	rbytes; /** how much data, starting from curr, do we have unparsed */
	// rbuf --- 用于保存从套接字读取发送过来的数据。
	// rcurr --- 用于保存现在读取到的位置,在rbuf中的位置
	// rsize --- 用于保存rbuf的大小
	// rbytes --- 用于保存读入的字节中，还有多少字节未被处理
	// struct conn读入命令的重要结构体成员
	
	// struct conn用于简单写出的结构体成员,类似于`out_string`函数写出或者组装二进制写出头
	char *wbuf;		// 预先申请的写出空间
	char *wcurr; 		// 用于指向写出的位置，最终将加入msglist后传输到
	int wsize;		// wbuf预先分配的大小
	int wbytes;		// 需要写出的大小，即wcurr指向的大小
	// struct conn用于简单写出的结构体成员
	
	/** which state to go into after finishing current write */
	enum conn_states write_and_go;	// 写出数据后，需要跳转到conn_xxx状态
	void *write_and_free;	// free this memory after finishing writing
	// write_and_free 用于其它时刻申请的写出缓冲区，写出完成后释放其空间
	
	// ritem 用于指向读入存放的位置，二进制与ASCII指向不同
	char *ritem;	// when we read in a item's value, it goes here
	int	  rlbytes; // 需要读入数据的字节个数
	
	/* dat for the nread state */
	
	/**
	 * item is used to hold an item structure created after reading the command
	 * line of set/add/replace commands, but before we finished reading the actual
	 * data. The data is read into ITEM_data(item) to avoid extra copying.
	 */
	 void *item;	// for commands set/add/replace
	 // item用于指向操作的item结构体
	 
	 /* data for the swallow state */
	 int sbytes;		// how many bytes to swallow
	 // sbytes --- 用于保存需要放弃的字节个数，当出现信息无法即时处理时，会丢弃读入的字节信息
	 
	 /* data for the mwrite state */
	 struct iovec *iov;
	 int	iovsize;	// number of elements allocated in iov[]
	 int 	iovussed;	// number of elements used in iov[]
	 
	 struct msghdr *msglist;
	 int	msgsize;	// number of elements allocated in msglist[]
	 int	msgused;	// number of elements used in msglist[]
	 int 	msgcurr;	// element of msglist[] being transmitted now
	 int 	msgbytes;	// number of bytes in current msg
	 // 上面两个结构体都是关于conn写出数据时使用，后面写出时会有详细介绍
	 
	 item	**ilist;	// list of items to write out
	 int	isize;
	 item	**icurr;
	 int	ileft;
	 // 这四个成员用于记录需要发送的item信息
	 
	 char	**suffixlist;
	 int	suffixsize;
	 char	**suffixcurr;
	 int	suffixleft;
	 // 这四个成员在函数_ascii_get_suffix_buf中分配，在make_ascii_get_suffix中使用。
	 // suffixlist指向thread的suffix_cache,用于存放函数process_get_command处理的
	 // item的标志位信息。例如:位于哪一个slab、item的value大小等
	 
#ifdef EXTSTORE	//用于外存,后面有一章节单独介绍,这几个成员主要用于从外存读取item
	 int io_wrapleft;	// 还有多少item的value值需要读取
	 unsigned int recache_counter;
	 io_wrap *io_wraplist;	// 需要读取item的处理列表
	 bool	io_queued;	// FIXME: debugging flag
#endif

	 enum protocol protocol;		// which protocol this connection speaks
	 enum network_transport transport;	// what transport is used by this connection
	 
	 /* data for UDP clients */
	 // 用于UDP协议,本文不做详细介绍(有需要的同学自行分析，理解TCP就觉得UDP较为简单)
	 int	request_id;	// Incoming UDP request iD, if this is a UDP "connection" */
	 struct sockaddr_in6 request_addr;	// udp: who sent the most recent request
	 socklen_t request_addr_size;
	 unsigned char *hdrbuf;	// udp packet headers
	 int	hdrsize;	// number of headers' worth of space is allocated
	 
	 // 用于记录是否需要返回操作状态
	 bool	noreply;	// True if the reply should not be sent.

	 // 状态查看
	 // current stats command
	 struct {
		char *buffer;
		size_t size;
		size_t offset;	
	 } stats;
	 
	 /* Binary protocol stuff */
	 /* This is where the binary header goes */
	 protocol_binary_request_header binary_header; // 二进制协议的命令头
	 uint64_t cas;	// the cas to return
	 short cmd;		// current comand being processed 二进制协议的处理命令
	 int opaque;
	 int keylen;
	 // 上面的成员都与二进制命令相关
	 
	 conn *next;	// Used for generating a list of conn structures
	 LIBEVENT_THREAD *thread;	// Pointer to the thread object serving this connection
	 
	 // 函数指针，对于不同的网络协议使用不同的函数
	 int (*try_read_command)(conn *c); // pointer for top level input parser
	 ssize_t (*read)(conn *c, void *buf, size_t count);
	 ssize_t (*sendmsg)(conn *c, struct msghdr *msg, int flags);
	 ssize_t (*wirte)(conn *c, void *buf, size_t count);
};
```
其结构图示如下:

![memcached中conn结构体图示](https://github.com/whynotAC/analysis_memcached/blob/master/thread/conn结构体图示.png)

前面介绍过了`memcached`的网络模型，由此可知新的`struct conn`结构体的初始化是在`conn_new`函数中进行(忘记的同学再去复习网络那一部分)。起初始化代码如下:

```
conn *conn_new(const int sfd, enum conn_states init_state,
					const int event_flags,
					const int read_buffer_size, enum network_transport transport,
					struct event_base *base, void *ssl) {
	conn *c;	// 用来关联网络套接字的struct conn结构体
	
	assert(sfd >= 0 && sfd < max_fds);	// 判断是否超出了最大套接字的值
	c = conns[sfd];	// 判断原先这个套接字对应的struct conn是否被申请过
		
	if (NULL == c) {
		if (!(c = (conn *)calloc(1, sizeof(conn)))) {
			STATS_LOCK();
			stats.malloc_fails++;
			STATS_UNLOCK();
			fprintf(stderr, "Failed to allocate connection object\n");
			return NULL;
		}
		MEMCACHED_CONN_CREATE(c);
		// 下面进入了struct conn成员的初始化过程
		// 函数指针初始化，用于不同的网络通信协议
		c->read = NULL;
		c->sendmsg = NULL;
		c->write = NULL;
		
		c->rbuf = c->wbuf = 0;
		c->ilist = 0;
		c->suffixlist = 0;
		c->iov = 0;
		c->msglist = 0;
		c->hdrbuf = 0;
		
		c->rsize = read_buffer_size;	// 读取缓冲区大小
		c->wsize = DATA_BUFFER_SIZE;	// 写出缓冲区大小
		c->isize = ITEM_LIST_INITIAL;	// 初始化写出item数组的大小
		c->suffixsize = SUFFIX_LIST_INITIAL; // 写出item的标志位的数组大小
		c->iovsize = IOV_LIST_INITIAL; // 写出的struct iovec结构体的数组大小
		c->msgsize = MSG_LIST_INTITAL; // 写出的struct msghdr结构体的数组大小
		c->hdrsize = 0; // 用于UDP，不做介绍
		
		// 根据上面初始化的大小，申请空间
		c->rbuf = (char *)malloc((size_t)c->rsize); // 读取空间
		c->wbuf = (char *)malloc((size_t)c->wsize); // 写出空间
		c->ilist = (item **)malloc(sizeof(item *) * c->isize); // 用于保存需要写出的item
		c->suffixlist = (char **)malloc(sizeof(char *) * c->suffixsize); // 用于保存item中标志位的位置数组
		c->iov = (struct iovec*)malloc(sizeof(struct iovec) * c->iovsize); // 用于写出的struct iovec结构的数组
		c->msglist = (struct msghdr*)malloc(sizeof(struct msghdr *) * c->msgsize); // 用于写出的struct msghdr结构的数组
		
		if (c->rbuf == 0 || c->wbuf == 0 || c->ilist == 0 || c->iov == 0 ||
				c->msglist == 0 || c->suffixlist == 0) {
			conn_free(c);
			STATS_LOCK();
			stats.malloc_fails++;
			STATS_UNLOCK();
			fprintf(stderr, "Failed to allocate buffers for connection\n");
			return NULL;
		}
		
		STATS_LOCK();
		stats_state.conn_structs++;
		STATS_UNLOCK();
		
		// 记录此struct conn结构体
		c->sfd = sfd;
		conns[sfd] = c;
	}
	
	// 设置使用的协议
	c->transport = transport;	// 传输协议
	c->protocol = settings.binding_protocol; // 命令解析协议
	
	/* unix socket mode doesn't need this, so zeroed out. but why
	 * is this done for every command? prsumably for UDP 
	 * mode. */
   	if (!settings.socketpath) {
   		c->request_addr_size = sizeof(c->request_addr);
   	} else {
   		c->request_addr_size = 0;
   	}
   	
   	if (transport == tcp_transport && init_state == conn_new_cmd) {
   		if (getpeername(sfd, (struct sockaddr *) &c->request_addr,
   								&c->request_addr_size)) {
   			perror("getpeername");
   			memset(&c->request_addr, 0, sizeof(c->request_addr));
   		}
   	}
   	
   	// 日志代码
   	
#ifdef TLS
	c->ssl = NULL;
	c->ssl_wbuf = NULL;
	c->ssl_enabled = false;
#endif
	c->state = init_state;	// 初始化struct conn的状态，新struct conn的状态为conn_new_cmd
	c->rlbytes = 0; // 还需要读取多少字节的标志位
	c->cmd = -1;		// 用于二进制命令的解析
	c->rbytes = c->wbytes = 0; // 分别表示有多少字节未被处理或者未被写出
	c->wcurr = c->wbuf;	// 用于标示需要写出的字节位置
	c->rcurr = c->rbuf;	// 用于标示需要解析的读入字节的开始位置
	c->ritem = 0;		// 记录用于读入value数据的位置
	c->icurr = c->ilist;	// 用于记录需要写出item数组的可以存放的开始位置
	c->suffixcurr = c->suffixlist; // 用于记录写出item的标示位的存放开始位置
	c->ileft = 0;		// 用于记录还有多少item需要发送
	c->suffixleft = 0; // 用于记录item的标示位还有多少需要发送
	c->iovused = 0; // struct iovec数组中使用的位置也是个数
	c->msgcurr = 0; // struct msghdr数组中可以使用的位置
	c->msgused = 0; // struct msghdr数组中已使用的大小
	c->sasl_started = false;
	c->last_cmd_time = current_time;	// 链接最后执行命令时间，跟生命周期有关，前面已介绍过
#ifdef EXTSTORE	// 外存(后续会有单独介绍)
	c->io_wraplist = NULL; // 读取外存item的IO命令列表
	c->io_wrapleft = 0; // 已经处理完的IO命令的个数
#endif

	c->wirte_and_go = init_state;	// 当写出后，设置conn的状态
	c->write_and_free = 0; // 用于记录临时申请的写出空间，写出后需要释放
	c->item = 0; // add/set/replace操作的item
	
	c->noreply = false;	// 是否需要回复信息
	
	// TLS的相关设置,不做重点介绍
	
	{
		// 设置struct conn的函数指针
		c->read = tcp_read;
		c->sendmsg = tcp_sendmsg;
		c->write = tcp_write;
	}
	
	// 设置try_read_command函数指针
	if (IS_UDP(transport)) {
		c->try_read_command = try_read_command_udp;
	} else {
		switch (c->protocol) {
			case ascii_prot:
				if (settings.auth_file == NULL) {
					c->authenticated = true;
					c->try_read_command = try_read_command_ascii;
				} else {
					c->authenticated = false;
					c->try_read_command = try_read_command_asciiauth;
				}
				break;
			case binary_prot:
				// binprot handles its own authentication via SASL parsing.
				c->authenticated = false;
				c->try_read_command = try_read_command_binary;
				break;
			case negotiating_prot:
				c->try_read_command = try_read_command_negotiate;
				break;
		}
	}
	
	// 设置strcut conn的处理函数event_handler
	event_set(&c->event, sfd, event_flags, event_handler, (void *)c);
	event_base_set(base, &c->event);
	c->ev_flags = event_flags;
	
	// 其他统计信息
	
	return c;
}
```
有上面的代码可知`struct conn`结构体中函数指针的初始化如下:

| 函数指针 |  对应的函数体 | 通信协议 | 解析协议 | 备注 |
| ------- | ----------- | ------- | ------ | ----|
| `ssize_t (*read)(conn *c, void *buf, size_t count)` | `ssize_t tcp_read(conn *c, void *buf, size_t count)` | 所有协议 | 所有协议 | 读取消息内容 |
| `ssize_t (*sendmsg)(conn *c, struct msghdr *msg, int flags)` | `ssize_t tcp_sendmsg(conn *c, struct msghdr *msg, int flags)` | 所有协议 | 所有协议 | 发送数据 |
| `ssize_t (*write)(conn *c, void *buf, size_t count)` | `ssize_t tcp_write(conn *c, void *buf, size_t count)` | 所有协议 | 所有协议 | 系统暂无使用 |
| `int (*try_read_command)(conn *c)` | `int try_read_command_udp(conn *c)` | `UDP`链接 | 所有协议 | 解析UDP接收内容 |
| `int (*try_read_command)(conn *c)` | `int try_read_command_ascii(conn *c)` | `TCP`链接 | `ascii`协议 | 解析TCP接收内容|
| `int (*try_read_command)(conn *c)` | `int try_read_command_binary(conn *c)` | `TCP`链接 | 二进制协议 | 解析TCP接收内容|
| `int (*try_read_command)(conn *c)` | `int try_read_command_asciiauth(conn *c)` | `TCP`链接 | `ascii`协议 | 解析有认证TCP接收内容 |
| `int (*try_read_command)(conn *c)` | `int try_read_command_negotiate(conn *c)` | `TCP`链接 | 所有协议 | 解析TCP接收内容|

由上面的表格可以看出，对于`read`、`sendmsg`、`write`函数使用相同的函数进行处理，而对于`try_read_command`函数则根据网络协议和解析协议进行区分。

## 2.链接信息处理状态机
由`struct conn`设置的函数`conn_new`代码可知，处理`struct conn`传递过来的消息是由`event_handler`来进行处理。`event_handler`函数的源代码如下:

```
// 链接信息处理器
void event_handler(const int fd, const short which, void *arg) {
	conn *c;
	
	c = (conn *)arg;		// 需要处理的struct conn
	assert(c != NULL);
	
	/* sanity */
	if (fd != c->sfd) {
		if (settings.verbose > 0)
			fprintf(stderr, "Catastrophic: event fd doesn't match conn fd!\n");
		conn_close(c);
		return;
	}
	
	drive_machine(c);	// 状态机
	
	/* wait for next event */
	return;
}
```
有上述的代码可知处理发送过来的消息由状态机函数`drive_machine`来进行处理。其代码骨架如下:

```
// 状态机
static void drive_machine(conn *c) {
	bool stop = false;
	int sfd;
	socklen_t addrlen;
	struct sockaddr_storage addr;
	int nreqs = settings.reqs_per_event;
	int res;
	const char *str;
#ifdef HAVE_ACCEPT4
	static int use_accept4 = 1;
#else
	static int use_accept4 = 0;
#endif

	assert(c != NULL);
	
	while (!stop) {
		switch(c->state) {
		case conn_listening:
			// 接收新链接的代码
			stop = true;
			break;
		
		case conn_waiting:
			// 等待发送过来的消息
			stop = true;
			break;
		
		case conn_read:
			// 读取发送过来的消息
			break;
		
		case conn_parse_cmd:
			// 用于解析读取过来的消息内容
			break;
		case conn_new_cmd:
			// 用于处理解析出来的命令
			break;
		
		case conn_nread:
			// 用于读取value内容
			break;
			
		case conn_swallow:
			// 当消息过多时，用于丢弃部分信息内容
			break;
			
		case conn_write:
			// 写出位于wbuf或者临时空间的发送内容
			// 注意这里没有break
		case conn_mwrite:
			// 使用struct msghdr结构体来写出需要发送的消息
			break;
			
		case conn_closing:
			// 关闭连接
			stop = true;
			break;
			
		case conn_closed:
			// 链接已经关闭
			break;
		
		case conn_watch:
			// 此状态用于特殊的struct conn等待时候的状态
			stop = true;
			break;
		
		casse conn_max_state:
			break;
		}
	}
}
```
由其骨架代码可以看出来，`drive_machine`是由`conn`结构体中的`enum conn_state state`成员来控制其流程。`enum conn_state`的定义如下:

```
/**
 * Possible states of a connection.
 */
enum conn_states {
	conn_listening,	/**< the socket which listens for connections */
	conn_new_cmd,		/**< Prepare connection for next command */
	conn_waiting,		/**< waiting for a readable socket */
	conn_read,		/**< reading in a command line */
	conn_parse_cmd,	/**< try to parse a command from the input buffer */
	conn_write,		/**< writing out a simple response */
	conn_nread,		/**< reading in a fixed number of bytes */
	conn_swallow,		/**< swallowing unnecessary bytes w/o storing */
	conn_closing,		/**< closing this connection */
	conn_mwrite,		/**< writing out many items sequentially */
	conn_closed,		/**< connection is closed */
	conn_watch,		/**< held by the logger thread as a watcher */
	conn_max_state	/**< Max state value (used for assertion) */
};
```

## 3. 状态机的具体代码
状态机的处理过程图示如下:

![memcached状态机循环图示](https://github.com/whynotAC/analysis_memcached/blob/master/thread/状态机循环.png)

其具体代码如下:

```
static void drive_machine(conn *c) {
	bool stop = false;		// 是否要停止状态机处理,等待下次触发
	int sfd;					// 文件描述符
	socklen_t addrlen;		// 用于udp信息处理
	struct sockaddr_storage addr;	// 用于udp信息处理
	int nreqs = settings.reqs_per_event;	// 每次触发最多执行命令的个数
	int res;
	const char *str;
#ifdef HAVE_ACCEPT4
	static int use_accept4 = 1;
#else
	static int use_accept4 = 0;
#endif

	assert(c != NULL);
	
	while (!stop) {	// 命令执行循环
		
		switch (c->state) {		// 根据struct conn的状态来执行状态机
		case conn_listening:
			// 此处的代码已经由网络章节详细介绍过了，有需要回顾的同学自行去查看
			stop = true;
			break;
			
		case conn_waiting:		// 等待网络发送过来消息
			if (!update_event(c, EV_READ | EV_PERSIST)) { // 更新连接字的状态
				if (settings.verbose > 0)
					fprintf(stderr, "Couldn't update event\n");
				conn_set_state(c, conn_closing);
				break;
			}
			
			conn_set_state(c, conn_read); // 设置状态为 conn_read
			stop = true;
			break;
			
		case conn_read:		// 读取网络发送过来的消息
			res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c); // 根据网络套接字来读取发送过来的信息
			
			switch (res) {	// 根据读取消息状态来设置接下来的状态
			case READ_NO_DATA_RECEIVED:	// 无消息接收到
				conn_set_state(c, conn_waiting); // 设置状态为conn_waiting
				break;
			case READ_DATA_RECEIVED:	// 有消息读取成功
				conn_set_state(c, conn_parse_cmd); // 解析读取过来的信息
				break;
			case READ_ERROR:		// 读取信息错误
				conn_set_state(c, conn_closing); // 读取信息错误，关闭套接字
				break;
			case READ_MEMORY_ERROR: /* Failed to allocate more memory */
				/* State already set by try_read_network */
				break;
			}
			break;
			
		case conn_parse_cmd:	// 解析读取过来的信息，产生命令进行处理
			if (c->try_read_command(c) == 0) {  // 尝试解析读取过来的信息 
				/* we need more data! */
				conn_set_state(c, conn_waiting); // 如果没有读取出来命令，则等待
			}
			
			break;
			
		case conn_new_cmd:		// 处理命令
			/* Only process nreqs at a time to avoid starving other
				connections */
			
			--nreqs;		// 处理命令的个数
			if (nreqs >= 0) {
				reset_cmd_handler(c);	// 从新设置struct conn的状态,尝试处理命令
			} else {
				// 释放网络通信子线程的处理机会，让其他网络套接字信息进行处理
				pthread_mutex_lock(&c->thread->stats.mutex);
				c->thread->stats.conn_yields++;
				pthread_mutex_unlock(&c->thread->stats.mutex);
				if (c->rbytes > 0) {	// 判断是否还有信息需要处理
					/* We have already read in data into the input buffer,
						so libevent will most likely not signal read events
						on the socket (unless more data is available. As a
						hack we should just put in a request to write data,
						because that should be possible ;-)
					*/
					if (!update_event(c, EV_WRITE | EV_PERSIST)) {
						if (settings.verbose > 0)
							fprintf(stderr, "Couldn't update event\n");
						conn_set_state(c, conn_closing);
						break;
					}
				}
				stop = true;
			}
			break;
			
		case conn_nread:		// 用于读取定长的字节，一般用于读取value值
			if (c->rlbytes == 0) {		// 读取完毕
				complete_nread(c);
				break;
			}
			
			/* Check if rbytes < 0, to prevent crash */
			if (c->rlbytes < 0) {			// 需要读取字节数小于0
				if (settings.verbose) {
					fprintf(stderr, "Invalid rlbytes to read: len %d\n", c->rlbytes);
				}
				conn_set_state(c, conn_closing);
				break;
			}
			
			if (!c->item || (((item *)c->item)->it_flags & ITEM_CHUNKED) == 0) {
				// 当item的value值小于settings.slab_chunk_size_max时,设置item的value值
				if (c->rbytes > 0) {	// conn结构体中还有未读取的字节数
					int tocopy = c->rbytes > c->rlbytes ? c->rlbytes : c->rbytes;
					if (c->ritem != c->rcurr) {
						memmove(c->ritem, c->rcurr, tocopy); // 拷贝字节数
					}
					c->ritem += tocopy;
					c->rlbytes -= tocopy;
					c->rcurr += tocopy;
					c->rbytes -= tocopy;
					if (c->rlbytes == 0) {	// 判断是否还需要读取字节
						break;
					}
				}
				
				/* now try reading from the socket */
				res = c->read(c, c->ritem, c->rlbytes); // 读取需要的字节数
				if (res > 0) {
					pthread_mutex_lock(&c->thread->stats.mutex);
					c->thread->stats.bytes_read += res;
					pthread_mutex_unlock(&c->thread->stats.mutex);
					if (c->rcurr == c->ritem) {
						c->rcurr += res;
					}
					// 修改读取数据的保存位置和需要读取的大小
					c->ritem += res;
					c->rlbytes -= res;
					break;
				}
			} else {
				// 当item的value值大于settings.slab_chunk_size_max时,设置item的value值
				res = read_into_chunked_item(c); // 申请chunked，用于存放item的value
				if (res > 0)
					break;
			}
			
			if (res == 0) {	// end of stream
				conn_set_state(c, conn_closing);
				break;
			}
			
			if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
				// 读取失败
				if (!update_event(c, EV_READ | EV_PERSIST)) {
					if (settings.verbose > 0)
						fprintf(stderr, "Couldn't update event\n");
					conn_set_state(c, conn_closing);
					break;
				}
				stop = true;
				break;
			}
			
			/* Memory allocation failure */
			if (res == -2) {
				// 当内存空间不足时，将丢弃部分传递过来的信息
				out_of_memory(c, "SERVER_ERROR Out of memory during read");
				c->sbytes = c->rlbytes;	 // 丢弃字节个数
				c->write_and_go = conn_swallow; // 丢弃字节状态
				break;
			}
			/* otherwise we have a real error, on which we close the connection */
			if (settings.verbose > 0) {
				fprintf(stderr, "Failed to read, and not due to blocking:\n"
							"errno: %d %s \n"
							"rcurr=%lx ritem=%lx rbuf=%lx rlbytes=%d rsize=%d\n",
							errno, strerror(errno),
							(long)c->rcurr, (long)c->ritem, (long)c->rbuf,
							(int)c->rlbytes, (int)c->rsize);
			}
			conn_set_state(c, conn_closing);
			break;
		
		case conn_swallow:	// 丢弃指定长度的网络传递信息
			/* we are reading sbytes and throwing them away */
			if (c->sbytes <= 0) {		// 当没有需要丢弃的信息
				conn_set_state(c, conn_new_cmd);
				break;
			}
			
			/* first check if we have leftovers in the conn_read buffer */
			if (c->rbytes > 0) {
				int tocopy = c->rbytes > c->sbytes ? c->sbytes : c->rbytes;
				c->sbytes -= tocopy;
				c->rcurr += tocopy;
				c->rbytes -= tocopy;
				break;
			}
			
			/* now try reading from the socket */
			res = c->read(c, c->rbuf, c->rsize > c->sbytes ? c->sbytes : c->rsize);
			if (res > 0) {
				pthread_mutex_lock(&c->thread->stats.mutex);
				c->thread->stats.bytes_read += res;
				pthread_mutex_unlock(&c->thread->stats.mutex);
				c->sbytes -= res;
				break;
			}
			if (res == 0) {	/* end of stream */
				conn_set_state(c, conn_closing);
				break;
			}
			if (res == -1 && (errno == EAGAIN || errno == EWOULDBLOCK)) {
				if (!update_event(c, EV_READ | EV_PERSIST)) {
					if (settings.verbose > 0)
						fprintf(stderr, "Couldn't update event\n");
					conn_set_state(c, conn_closing);
					break;
				}
				stop = true;
				break;
			}
			/* otherwise we have a real error, on which we close the conneciton */
			if (settings.verbose > 0)
				fprintf(stderr, "Failed to read, and not due to blocking\n");
			conn_set_state(c, conn_closing);
			break;
			
		case conn_write: // 用于写出非msghdr结构体的信息，将其转变为msghdr结构
			/**
			 * We want to write out a simple response. If we haven't already,
			 * assemble it into a msgbuf list (this will be a single-entry
			 * list for TCP or a two-entry list for UDP).
			 */
			 if (c->iovused == 0 || (IS_UDP(c->transport) && c->iovused == 1)) {
			 	if (add_iov(c, c->wcurr, c->wbytes) != 0) {
			 		if (settings.verbose > 0)
			 			fprintf(stderr, "Couldn't build response\n");
			 		conn_set_state(c, conn_closing);
			 		break;
			 	}
			 }
			 
			 /* fall through... */
			 
		case conn_mwrite:	// 使用msghdr结构体来发送消息
#ifdef EXTSTORE		// 使用外存时，后面文章将有详细介绍
			/* have side IO's that must process before transmit() can run.
			 * remove the connection from the worker thread and dispatch the 
			 * IO queue
			 */
			if (c->io_wrapleft) {
				assert(c->io_queued == false);
				assert(c->io_wraplist != NULL);
				// TODO: create proper state for this condition
				conn_set_state(c, conn_watch);
				event_del(&c->event);
				c->io_queued = true;
				extstore_submit(c->thread->storage, &c->io_wraplist->io);
				stop = true;
				break;
			}
#endif
			if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {
				if (settings.verbose > 0)
					fprintf(stderr, "Failed to build UDP headers\n");
				conn_set_state(c, conn_closing);
				break;
			}
			switch (transmit(c)) {		// 发送数据
			case TRANSMIT_COMPLETE:		// 发送信息完毕
				if (c->state == conn_mwrite) {
					conn_release_items(c);	// 释放需要写出的item
					if (c->protocol == binary_prot) {
						conn_set_state(c, c->write_and_go);
					} else {
						conn_set_state(c, conn_new_cmd);
					}
				} else if (c->state == conn_write) {
					if (c->write_and_free) {
						free(c->write_and_free); // 释放需要写出的空间
						c->write_and_free = 0;
					}
					conn_set_state(c, c->write_and_go); // 设置conn的状态
				} else {
					if (settings.verbose > 0)
						fprintf(stderr, "Unexpected state %d\n", c->state);
					conn_set_state(c, conn_closing);
				}
				break;
				
			case TRANSMIT_INCOMPLETE:
			case TRANSMIT_HARD_ERROR:
				break;		// Continue in state machine.
			
			case TRANSMIT_SOFT_ERROR:
				stop = true;
				break;
			}
			break;
			
		case conn_closing: 	// 链接将关闭
			if (IS_UDP(c->transport))
				conn_cleanup(c);
			else
				conn_close(c);
			stop = true;
			break;
			
		case conn_closed:
			/* This only happens if dormando is an idiot. */
			abort();
			break;
		
		case conn_watch:
			/* We handed off our connection to the logger thread. */
			stop = true;
			break;
		
		case conn_max_state:
			assert(false);
			break;
		}
	}
	
	return;
}
```

## 4. 状态机流程梳理
由`conn_new`函数可知，`struct conn`结构体的初始化`state`的状态为`conn_new_cmd`。从其状态来将描述状态机的运行过程。

### `conn_new_cmd`状态
在此状态下将调用`reset_cmd_handler`函数，其源代码如下:

```
static void reset_cmd_handler(conn *c) { // 重置命令解析中使用的struct conn结构体成员
	c->cmd = -1;							// 用于二进制命令解析
	c->substate = bin_no_state;		// 用于二进制命令解析
	if (c->item != NULL) {				// 用于判断上次命令处理的item
		item_remove(c->item);			// 释放上次处理的item
		c->item = NULL;
	}
	conn_shrink(c);						// 释放其他struct conn成员
	if (c->rbytes > 0) {				// 判断是否还有需要处理的已读取的信息
		conn_set_state(c, conn_parse_cmd);
	} else {
		conn_set_state(c, conn_waiting);
	}
}

/*
 * Shrinks a connection's buffers if they're too big. This prevents
 * periodic large "get" requests from permanently chewing lots of server
 * memory.
 * This should only be called in between requests since it can wipe output
 * buffers!
 */
static void conn_shrink(conn *c) {
	assert(c != NULL);
	
	if (IS_UDP(c->transport))
		return;
	
	// 处理已读取的信息
	if (c->rsize > READ_BUFFER_HIGHWAT && c->rbytes < DATA_BUFFER_SIZE) {
		char *newbuf;
		
		if (c->rcurr != c->rbuf) // 向前移动未解析的已读取的信息
			memove(c->rbuf, c->rcurr, (size_t)c->rbytes); // 向前拷贝未解析的信息
		
		newbuf = (char *)realloc((void *)c->rbuf, DATA_BUFFER_SIZE); // 扩展空间
		
		if (newbuf) {
			c->rbuf = newbuf;				// 指向新空间
			c->rsize = DATA_BUFFER_SIZE;	// 新空间大小
		}
		/* TODO check other branch */
		c->rcurr = c->rbuf;		// 指向未解析的信息
	}
	
	// 处理已写出的item
	if (c->isize > ITEM_LIST_HIGHWAT) {
		item **newbuf = (item**) realloc((void *)c->ilist, ITEM_LIST_INITIAL * sizeof(c->ilist[0]));
		if (newbuf) {
			c->ilist = newbuf;
			c->isize = ITEM_LIST_INITIAL;
		}
		/* TODO check error condition? */
	}
	
	// 处理msghdr数组信息
	if (c->msgsize > MSG_LIST_HIGHWAT) {
		struct msghdr *newbuf = (struct msghdr *) realloc((void *)c->msglist, MSG_LIST_INITIAL * sizeof(c->msglist[0]));
		if (newbuf) {
			c->msglist = newbuf;
			c->msgsize = MSG_LIST_INITIAL;
		}
		/* TODO check error condition? */
	}
	
	// 处理iovec数组信息
	if (c->iovsize > IOV_LIST_HIGHWAT) {
		struct iovec *newbuf = (struct iovec *) realloc((void *)c->iov, IOV_LIST_INITIAL * sizeof(c->iov[0]));
		if (newbuf) {
			c->iov = newbuf;
			c->iovsize = IOV_LIST_INITIAL;
		}
		/* TODO check return value */
	}
}
```
其状态转移图示如下:

![memcached状态机conn_new_cmd状态流转图示](https://github.com/whynotAC/analysis_memcached/blob/master/thread/conn_new_cmd状态.png)

### `conn_waiting`状态
此状态下的代码如下:

```
case conn_waiting:
	if (!update_event(c, EV_READ | EV_PERSIST)) {
		if (settings.verbose > 0)
			fprintf(stderr, "Couldn't update event\n");
		conn_set_state(c, conn_closing);
		break;
	}
	conn_set_state(c, conn_read);
	stop = true;
	break;
```
其状态图示如下:

![memcached状态机conn_waiting状态流转图示](https://github.com/whynotAC/analysis_memcached/blob/master/thread/conn_waiting状态转移图示.png)

### `conn_parse_cmd`状态
此状态下的源代码如下:

```
case conn_parse_cmd:
	if (c->try_read_command(c) == 0) {
		/* we need more data! */
		conn_set_state(c, conn_waiting);
	}
	break;
```
前文已经介绍过对于`try_read_command`函数指针在不同的网络协议和解析协议情况下，使用不同的函数，本文将详细介绍`TCP`网络协议、`ASCII`解析协议使用的`try_read_command_ascii`函数。其源代码如下:

```
// 从已读取的字节从解析出命令
static int try_read_command_ascii(conn *c) {
	char *el, *cont;
	
	if (c->rbytes == 0)			// 判断是否存在已经接受的字节
		return 0;
		
	el = memchr(c->rcurr, '\n', c->rbytes); // 查找命令的终结符\n
	if (!el) {
		if (c->rbytes > 1024) {
			/*
			 * We didn't have a '\n' in the first k. This _has_ to be a
			 * large multiget, if not should just nuke the connection.
			 */
			char *ptr = c->rcurr;
			while (*ptr == ' ') {	// ignore leading whitespaces
				++ptr;
			}
			
			// 当长度过长时关闭链接
			if (ptr - c->rcurr > 100 ||
					(strncmp(ptr, "get ", 4) && strncmp(ptr, "gets ", 5))) {
				
				conn_set_state(c, conn_closing);
				return 1;
			}
		}
		
		return 0;
	}
	cont = el + 1;			// 指向命令的下一个字符
	if ((el - c->rcurr) > 1 && *(el - 1) == '\r') { 判断命令终结字符为\r\n
		el--;
	}
	*el = '\0';				// 添加上字符串的终结符
	
	assert(cont <= (c->rcurr + c->rbytes));
	
	c->last_cmd_time = current_time;		// 修改命令的最后执行时间
	process_command(c, c->rcurr);			// 执行解析出来的命令(后续有文章单独讲解)
	
	c->rbytes -= (count - c->rcurr);		// 修改未解析的字符数
	c->rcurr = cont;							// 修改未解析字符串的开始位置
	
	assert(c->rcurr <= (c->rbuf + c->rsize));
	
	return 1;
}
```
从上面的代码可以看出，当`conn`处于`conn_parse_cmd`状态时。其会在已经接受到的字符串中解析出将要执行命令，调用`process_command`函数来执行命令。再根据命令的不同处理方式，设置`conn`的状态。针对`process_command`函数，后续会有单独的文章进行讲解。

### `conn_read`状态
此状态下的源代码如下:

```
case conn_read:
	res = IS_UDP(c->transport) ? try_read_udp(c) : try_read_network(c);
	
	switch (res) {		// 根据读取数据的状态来进行状态转移
	case READ_NO_DATA_RECEIVED:
		conn_set_state(c, conn_waiting);
		break;
	case READ_DATA_RECEIVED:
		conn_set_state(c, conn_parse_cmd);
		break;
	case READ_ERROR:
		conn_set_state(c, conn_closing);
		break;
	case READ_MEMORY_ERROR:		/* Failed to allocate more memory */
		/* State already set by try_read_network */
		break;
	}
	break;
	
// 着重介绍一下TCP网络协议下的try_read_network函数
/**
 * read from network as much as we can, handle buffer overflow and connection
 * close.
 * before reading, move the remaining incomplete fragment of a command
 * (if any) to the beginning of the buffer.
 * To protect us from someone flooding a connection with bogus data causing
 * the connection to eat up all available memory, break out and start looking
 * at the data I've got after a number of reallocs...
 * @return enum try_read_result
 */
static enum try_read_result try_read_network(conn *c) {
	enum try_read_result gotdata = READ_NO_DATA_RECEIVED;
	int res;
	int num_allocs = 0;
	assert(c != NULL);
	
	if (c->rcurr != c->rbuf) { // 判断是否有已经解析过的字符
		if (c->rbytes != 0) /* otherwise there's nothing to copy */
			memmove(c->rbuf, c->rcurr, c->rbytes);  // 向前移动
		c->rcurr = c->rbuf;
	}
	
	while (1) {
		if (c->rbytes >= c->rsize) {		// 判断是否有存储空间
			if (num_allocs == 4) {	 // 判断是否已经连续读取4次
				return gotdata;
			}
			++num_allocs;
			char *new_rbuf = realloc(c->rbuf, c->rsize * 2); // 申请2倍空间大小
			if (!new_rbuf) {
				STATS_LOCK();
				stats.malloc_fails++;
				STATS_UNLOCK();
				if (settings.verbose > 0) {
					fprintf(stderr, "Couldn't realloc input buffer\n");
				}
				c->rbytes = 0;
				out_of_memory(c, "SERVER_ERROR out of memory reading request");
				c->write_and_go = conn_closing; // 设置写出后状态
				return READ_MEMORY_ERROR;
			}
			c->rcurr = c->rbuf = new_rbuf; // 设置读取空间指针
			c->rsize *= 2; // 设置读取空间长度
		}
		
		int avail = c->rsize - c->rbytes;	 // 判断可用空间大小
		res = c->read(c, c->rbuf + c->rbytes, avail); // 读取发送过来的消息
		if (res > 0) {
			pthread_mutex_lock(&c->thread->stats.mutex);
			c->thread->stats.bytes_read += res;
			pthread_mutex_unlock(&c->thread->stats.mutex);
			gotdata = READ_DATA_RECEIVED;
			c->rbytes += res;	// 增加未解析字节数
			if (res == avail) {			// 判断是否还有剩余空间
				continue;
			} else {
				break;
			}
		}
		if (res == 0) {		// 读取失败
			return READ_ERROR;
		}
		if (res == -1) {		// 读取出现错误
			if (errno == EAGAIN || errno == EWOULDBLOCK) {
				break;
			}
			return READ_ERROR;
		}
	}
	return gotdata;
}
```
通过上述代码可知，正常情况下`memcached`通过扩展`rbuf`指向的空间来尽量存放更多需要读取的数据内容，并根据读取结果返回读取状态。其对应的状态转移流程图示如下:

![memcached状态机conn_read状态流转图示](https://github.com/whynotAC/analysis_memcached/blob/master/thread/conn_read状态转移图示.png)

对于其他状态都是由`process_command`执行命令过程中才会设置的状态，由于本文的篇幅已经远远超标了。并且`process_command`会单独作为一篇文章来讲解，所以本文就到此截止。

## 5. 回顾
### 本文重点:
* `struct conn`结构体中成员的使用。
* 状态机中状态之间的流转。

本文没有太多难以理解的代码，重要要关注`struct conn`结构体中成员的使用。

