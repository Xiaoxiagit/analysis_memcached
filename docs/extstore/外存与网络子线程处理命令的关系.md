外存与网络子线程处理命令之间的关系
===================================
通过面前的几篇文章已经全面的阐述外存的相关知识，但外存终将是要为网络子线程处理命令提供服务。对于往外存写，在外存相关部分的知识已经进行了详细的说明。本文将把网络子线程处理命令的流程与外存部分进行关联，详细说明网络子线程处理命令时对外存部分的调用。

## 1. 外存存储`item`的生存周期
从外存的相关文档可知，`item`是外存写入线程从`LRU`链表的尾部挑选符合写出条件的`item`写入到外存页面中。外存页面`page`中存活的`item`将通过外存紧缩线程进行转移处理，然而对于删除的或者过期的`item`将通过释放相应的外存`page`页面也随之释放。一旦`item`进入外存中，暂时没有相应的流程能够让`item`重新回到内存中。

## 2. 网络子线程的相关命令
下面列出网络子线程需要处理的命令，并备注其是否与外存相关。

| 命令 | 使用的函数 | 是否与外存相关 |
| ---  | ------- | -------- |
| `get/bget/gets/gat/gats` | `process_get_command` | 相关 |
| `add/set/replace/prepend/append/cas` | `process_update_command` | 相关 |
| `incr/decr` | `process_arithmetic_command` | 相关 |
| `delete` | `process_delete_command` | 相关 |
| `touch` | `process_touch_command` | 相关 |
| `stats` | `process_stat` | 相关 |
| `extstore` | `process_extstore_command` | 相关 |

对于上述命令中，对于使用`process_get_command`函数的命令需要特别的介绍。而其他的命令操作主要是调用了外存定义的宏函数`STORAGE_delete`来实现对外存的控制。

### 2.1 `STORAGE_delete`宏函数
其定义如下：

```
#ifdef EXTSTORE
#define STORAGE_delete(e, it) \
	do {	\
		if (it->it_flags & ITEM_HDR) {  \
			item_hdr *hdr = (item_hdr *)Item_data(it); \
			extstore_delete(e, hdr->page_id, hdr->page_version, \
					1, ITEM_ntotal(it)); \
		} \
	} while (0)
#else
#define STORAGE_delete(...)
#endif

/* engine note delete function: takes engine, page id, size ?
 * note that an item in this page is no longer valid. */
int extstore_delete(void *ptr, unsigned int page_id, uint64_t page_version, unsigned int count, unsigned int bytes) {
	store_engine *e = (store_engine *)ptr;
	// FIXME: validate page_id in bounds
	store_page *p = &e->pages[page_id];	 // 获取对应外存的页面信息
	int ret = 0;
	
	pthread_mutex_lock(&p->mutex);
	if (!p->closed && p->version == page_version) { // 判断当前页面是否合法
		if (p->bytes_used >= bytes) {		// 减少页面的使用字节数
			p->bytes_used -= bytes;
		} else {
			p->bytes_used = 0;
		}
		
		if (p->obj_count >= count) {     // 减少页面中存储item的个数
			p->obj_count -= count;
		} else {
			p->obj_count = 0;  // caller has bad accounting?
		}
		STAT_L(e);
		e->stats.bytes_used -= bytes;
		e->stats.objects_used -= count;
		STAT_UL(e);
		
		if (p->obj_count == 0) {         // 当外存页面没有存储item时可以考虑释放此页面
			extstore_run_maint(e);
		}
	} else {
		ret = -1;
	}
	pthread_mutex_unlock(&p->mutex);
	return ret;
}
```
通过上面的代码描述可以很清楚的看出，调用`STORAGE_delete`宏函数时，其仅仅改变外存页面中使用字节数和存储`item`的个数，不进行真正的删除操作。对于存储有了解的同学都应该知道，对于存储介质中失效或者过期的存储内容基本都是在外存紧缩过程中完成删除操作。

### 2.2 `process_update_command`命令处理函数
此函数是用来更新`item`的内容，其需要将内存中或者外存中的`item`删除掉，仅用申请一个新的空间来存放发送过来的内容，并替换掉原来空间的内容。其与外存相关的代码如下:

```
static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
	....
	// 申请新的空间
	it = item_alloc(key, nkey, flags, realtime(exptime), vlen);
	
	if (it == 0) {
		enum store_item_type status;
		if (! item_size_ok(nkey, flags, vlen)) {
			out_string(c, "SERVER_ERROR object too large for cache");
			status = TOO_LARGE;
		} else {
			out_of_memory(c, "SERVER_ERROR out of meory storing object");
			status = NO_MEMORY;
		}
		// 丢弃发送过来的数据
		c->write_and_go = conn_swallow;
		c->sbytes = vlen;
		
		// 尝试释放内存空间的内容
		if (comm == NREAD_SET) {
			it = item_get(key, nkey, c, DONT_UPDATE);
			if (it) {
				item_unlink(it);
				STORAGE_delete(c->thread->storage, it);   // 释放在外存的存储信息
				item_remove(it);
			}
		}
		
		return;
	}
	
	....
}
```

### 2.3 `process_arithmetic_command`命令处理函数
此命令用于增加或者减少`item`的值，当`item`存放在外存时则需要进行相应的外存信息处理。其相关代码如下:

```
static void process_arithmeitc_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
	....
	// 其调用add_delta函数来实现对外存的处理
	switch (add_delta(c, key, nkey, incr, delta, tmp, NULL)) {
		....
	}
}

enum delta_result_type add_delta(conn *c, const char *key, const size_t nkey,
											bool incr, const int64_t delta, 
											char *buf, uint64_t *cas) {
	....
	// 调用do_add_delta函数进行处理
	ret = do_add_delta(c, key, nkey, incr, delta, buf, cas, hv);
	....
	return ret;
}

enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
											const bool incr, const int64_t delta,
											char *buf, uint64_t *cas, const uint32_t hv) {
	....
#ifdef EXTSTORE
	if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {
#else
	if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) != 0) {
#endif
		do_item_remove(it);
		return NON_NUMERIC;
	}
	....
}
```

### 2.4 `process_delete_command`命令处理函数
此命令用于删除`item`的相关信息，其相关代码如下:

```
static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
	....
	// 锁定item，并做后续处理
	it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
	if (it) {
		....
		// 删除相应的item
		do_item_unlink(it, hv);
		STORAGE_delete(c->thread->storage, it);   // 删除外存的信息
		do_item_remove(it);
		....
	} else {
		....
	}
	item_unlock(hv);
}
```
### 2.5 `process_touch_command`命令处理函数
此命令用于更新`item`的访问时间，从而改变`item`在`LRU`链表中的位置。其相关代码如下:

```
static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
	....
	// 调用item_touch函数，关联到外存
	it = item_touch(key, nkey, realtime(exptime_int), c);
	....
}

item *item_touch(const char *key, size_t nkey, uint32_t exptime, conn *c) {
	....
	it = do_item_touch(key, nkey, exptime, hv, c);
	....
	return it;
}

item *do_item_touch(const char *key, size_t nkey, uint32_t exptime, const uint32_t hv, conn *c) {
	item *it = do_item_get(key, nkey, hv, c, DO_UPDATE);
	....
}

item *do_item_alloc(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update) {
	....
	// 判断item是否过期，则进行处理
	if (it != NULL) {
		was_found = 1;
		if (item_is_flushed(it)) {
			// 判断item是否被强制清除
			do_item_unlink(it, hv);
			STORAGE_delete(c->thread->storage, it);
			do_item_remove(it);
			....
		} else if (it->exptime != 0 && it->exptime <= current_time) {
			// 判断item是否过期
			do_item_unlink(it, hv);
			STORAGE_delete(c->thread->storage, it);
			do_item_remove(it);
			....
		} else {
			....
		}
	}
}
```

### 2.6 `process_stat`命令处理函数
此命令用于获取`memcached`的运行状态，此命令也会获取外存相关的运行状态。其源代码如下:

```
static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {
	....
#ifdef EXTSTORE
	} else if (strcmp(subcommand, "extstore") == 0) {
		process_extstore_stats(&append_stats, c);
#endif
	....
	}
}

#ifdef EXTSTORE
static void process_extstore_stats(ADD_STAT add_stats, conn *c) {
	int i;
	char key_str[STAT_KEY_LEN];
	char val_str[STAT_VAL_LEN];
	int klen = 0, vlen = 0;
	struct extstore_stats st;
	
	assert(add_stats);
	
	void *storage = c->thread->storage;
	extstore_get_stats(storage, &st);   // 获取外存信息存储状态
	st.page_data = calloc(st.page_count, sizeof(struct extstore_page_data)); // 申请存储外存页面信息的空间
	extstore_get_page_data(storage, &st); // 获取外存page存储状态
	
	// 添加bucket信息
	for (i = 0; i < st.page_count; i++) {
		APPEND_NUM_STAT(i, "version", "%llu", (unsigned long long)st.page_data[i].version);
		APPEND_NUM_STAT(i, "bytes", "%llu", (unsigned long long)st.page_data[i].bytes_used);
		APPEND_NUM_STAT(i, "bucket", "%u", st.page_data[i].bucket);
		APPEND_NUM_STAT(i, "free_bucket", "%u", st.page_data[i].free_bucket);
	}
}
#endif
```

### 2.7 `process_extstore_command`命令处理函数
此命令用于改变外存相关线程执行时所使用的参数，从而改变外存的状态。其源代码如下:

```
#ifdef EXTSTORE
static void process_extstore_command(conn *c, token_t *tokens, const size_t ntokens) {
	set_noreply_maybe(c, tokens, ntokens);
	bool ok = true;
	if (ntokens < 4) {
		ok = false;
	} else if (strcmp(tokens[1].value, "free_memchunks") == 0 && ntokens > 4) {
		// per-slab-class free chunk setting
		unsigned int clsid = 0;
		unsigned int limit = 0;
		if (!safe_strtoul(tokens[2].value, &clsid) || 
				!safe_strtoul(tokens[3].value, &limit)) {
			ok = false;
		} else {
			if (clsid < MAX_NUMBER_OF_SLAB_CLASSES) {
				settings.ext_free_memchunks[clsid] = limit;
			} else {
				ok = false;
			}
		}
	} else if (strcmp(tokens[1].value, "item_size") == 0) {
		// 设置最小写出item的大小
		if (!safe_strtoul(tokens[2].value, &settings.ext_item_size))
			ok = false;
	} else if (strcmp(tokens[1].value, "item_age") == 0) {
		// 设置写出item的最小有效期
		if (!safe_strtoul(tokens[2].value, &settings.ext_item_age))
			ok = false;
	} else if (strcmp(tokens[1].value, "low_ttl") == 0) {
		// 设置放在low ttl bucket的最大有效期
		if (!safe_strtoul(tokens[2].value, &settings.ext_low_ttl))
			ok = false;
	} else if (strcmp(tokens[1].value, "recache_rate") == 0) {
		// cache使用率
		if (!safe_strtoul(tokens[2].value, &settings.ext_recache_rate))
			ok = false;
	} else if (strcmp(tokens[1].value, "compact_under") == 0) {
		// 设置紧缩的最低水平线
		if (!safe_strtoul(tokens[2].value, &settings.ext_compact_under))
			ok = false;
	} else if (strcmp(tokens[1].value, "drop_under") == 0) {
		// 设置丢弃水平线
		if (!safe_strtoul(tokens[2].value, &settings.ext_drop_under))
			ok = false;
	} else if (strcmp(tokens[1].value, "max_frag") == 0) {
		if (!safe_strtoul(tokens[2].value, &settings.ext_max_frag))
			ok = false;
	} else if (strcmp(tokens[1].value, "drop_unread") == 0) {
		unsigned int v;
		if (!safe_strtoul(tokens[2].value, &v)) {
			ok = false;
		} else {
			settings.ext_drop_unread = v == 0 ? false : true;
		}
	} else {
		ok = false;
	}
	if (!ok) {
		out_string(c, "ERROR");
	} else {
		out_string(c, "OK");
	}
}
#endif
```

## 3. 网络子线程读取外存`item`的过程
如果网络子线程访问的`item`的实际值存放在外存中，则网络子线程需要提交外存读取`IO`命令，然后等待`IO`命令执行完毕后，通过回调函数重新将`conn`的状态置为`conn_mwrite`状态，继续写出访问的`item`的`value`值。其具体代码如下:

### 3.1 访问`item`的命令处理过程(准备阶段)
当网络子线程处理网络访问`item`命令时，调用`process_get_command`函数来处理对应的网络命令。其代码如下:

```
static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {
	char 		*key;
	size_t 	nkey;
	int			i = 0;
	int 		si = 0;
	item		*it;
	token_t 	*key_token = &tokens[KEY_TOKEN];
	char		*suffix;
	int32_t	exptime_int = 0;
	rel_time_t exptime = 0;
	bool		fail_length = false;
	assert(c != NULL);
	
	// 判断是否需要修改item访问时间
	if (should_touch) {
		// For get and touch commands, use first token as exptime
		if (!safe_strtol(tokens[1].value, &exptime_int)) {
			out_string(c, "CLIENT_ERROR invalid exptime argument");
			return;
		}
		key_token++;
		exptime = realtime(exptime_int);
	}
	
	// 依次获取需要访问的item的value值
	do {
		// 判断key_token的所有key
		while (key_token->length != 0) {
			key = key_token->value;			// 获取key值
			nkey = key_token->length;		// 获取key值得长度
			// 判断key值长度是否超过最长长度
			if (nkey > KEY_MAX_LENGTH) {
				fail_length = true;
				goto stop;
			}
			
			// 获取内存中的item
			it = limited_get(key, nkey, c, exptime, should_touch);
			if (settings.detail_enabled) {
				stats_prefix_record_get(key, nkey, NULL != it);
			}
			// 判断item是否存在
			if (it) {
				// 扩展conn的ilist数据长度
				if (_ascii_get_expand_ilist(c, i) != 0) {
					item_remove(it);
					goto stop;
				}
				
				/*
				 * Construct the response. Each hit adds three elements to the
				 * outgoing data list:
				 * 		"VALUE "
				 * 	 key
				 * 	 " " + flags + " " + data length + "\r\n" + data (with \r\n)
				 */
				{
					MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey, it->nbytes, ITEM_get_cas(it));
					int nbytes;
					suffix = _ascii_get_suffix_buf(c, si); // 获取suffix存储空间
					if (suffix == NULL) {
						item_remove(it);
						goto stop;
					}
					si++;		// 成功读取item个数
					nbytes = it->nbytes;	// item的值长度
					int suffix_len = make_ascii_get_suffix(suffix, it, return_cas, nbytes); // 获取suffix字段长度
					// 开始将item的信息写入到iov数组中
					if (add_iov(c, "VALUE", 6) != 0 ||
							add_iov(c, ITEM_key(it), it->nkey) != 0 ||
							add_iov(c, suffix, suffix_len) != 0) {
						item_remove(it);
						goto stop;
					}
					// 判断item真正值是否在外存中存储
#ifdef EXTSTORE
					if (it->it_flags & ITEM_HDR) {
						// 处理外存中的item信息
						if (_get_extstore(c, it, c->iovused-3, 4) != 0) {
							pthread_mutex_lock(&c->thread->stats.mutex);
							c->thread->stats.get_oom_extstore++;
							pthread_mutex_unlock(&c->thread->stats.mutex);
							
							item_remove(it);
							goto stop;
						}
					} else if ((it->it_flags & ITEM_CHUNKED) == 0) {
#else
					if ((it->it_flags & ITEM_CHUNKED) == 0) {
#endif
						add_iov(c, ITEM_data(it), it->nbytes);
					} else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {
						item_remove(it);
						goto stop;
					}
				}
				
				// 输出信息
				if (settings.verbose > 1) {
					int ii;
					fprintf(stderr, ">%d sending key ", c->sfd);
					for (ii = 0; ii < it->nkey; ++ii) {
						fprintf(stderr, "%c", key[ii]);
					}
					fprintf(stderr, "\n");
				}
				
				// 统计访问信息
				// item_get() has incremented it->refcount for us
				pthread_mutex_lock(&c->thread->stats.mutex);
				if (should_touch) {
					c->thread->stats.touch_cmds++;
					c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
				} else {
					c->thread->stats.lru_hits[it->slabs_clsid]++;
					c->thread->stats.get_cmds++;
				}
				pthread_mutex_unlock(&c->thread->stats.mtuex);
				// 记录访问的item
#ifdef EXTSTORE
				// If ITEM_HDR, an io_wrap owns the reference.
				if ((it->it_flags & ITEM_HDR) == 0) {
					*(c->ilist + i) = it;
					i++;
				}
#else
				*(c->ilist + i) = it;
				i++;
#endif
			} else {
				// 访问的item不存在
				pthread_mutex_lock(&c->thread->stats.mutex);
				if (should_touch) {
					c->thread->stats.touch_cmds++;
					c->thread->stats.touch_misses++;
				} else {
					c->thread->stats.get_misses++;
					c->thread->stats.get_cmds++;
				}
				MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
				pthread_mutex_unlock(&c->thread->stats.mutex);
			}
			
			key_token++;		// 下一个key值
		}
		
		/*
		 * If the command string hasn't been fully processed. get the next set
		 * of tokens.
		 */
		if (key_token->value != NULL) {
			// 获取下一个key值
			ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
			key_token = tokens;
		}
		
	} while (key_token->value != NULL);
stop:
	
	c->icurr = c->ilist;
	c->ileft = i;
	c->suffixcurr = c->suffixlist;
	c->suffixleft = si;
	
	if (settings.verbose > 1)
		fprintf(stderr, ">%d END\n", c->sfd);
	
	/*
	 * If the loop was terminated because of out-of-memory, it is not
	 * reliable to add END\r\n to the buffer, because it might not end
	 * in \r\n. So we send SERVER_ERROR instead.
	 */
	if (key_token->value != NULL || add_iov(c, "END\r\n", 5) != 0
				|| (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {
		if (fail_length) {
			out_string(c, "CLIENT_ERROR bad command line format");
		} else {
			out_of_memory(c, "SERVER_ERROR out of memory writing get response");
		}
		conn_release_items(c);
	} else {
		conn_set_state(c, conn_mwrite);
		c->msgcurr = 0;
	}
}

// 设置获取外存数据的函数
// FIXME: This completely breaks UDP support
static inline int _get_extstore(conn *c, item *it, int iovst, int iovcnt) {
	// 获取外存存放地址
#ifdef NEED_ALIGN
	item_hdr hdr;
	memcpy(&hdr, ITEM_data(it), sizeof(hdr));
#else
	item_hdr *hdr = (item_hdr *)ITEM_data(it);
#endif
	size_t ntotal = ITEM_ntotal(it);		      // 获取数据长度
	unsigned int clsid = slabs_clsid(ntotal); // 获取数据对应的clsid
	item *new_it;
	bool chunked = false;		// 判断是否需要chunked方式存储
	if (ntotal > settings.slab_chunk_size_max) {
		// chunked方式存储
		// Pull a chunked item header
		uint32_t flags;
		FLAGS_CONV(it, flags);
		new_it = item_alloc(ITEM_key(it), it->nkey, flags, it->exptime, it->nbytes);		// 分配存储空间
		assert(new_it == NULL || (new_it->it_flags & ITEM_CHUNKED));
		chunked = true;		// 需要chunked存储
	} else {
		// 直接存储即可
		new_it = do_item_alloc_pull(ntotal, clsid);
	}
	// 判断新空间是否申请成功
	if (new_it == NULL)
		return -1;
	assert(!c->io_queued);		// FIXME: debugging
	// so we can free the chunk on a miss
	new_it->slabs_clsid = clsid;		// 设置对应的clsid
	
	io_wrap *io = do_cache_alloc(c->thread->io_cache);  // 申请写出空间结构
	io->active = true;			//	设置成活跃状态
	io->miss = false;			// 默认读取会成功
	io->badcrc = false;			// 默认crc校验成功
	// io_wrap owns the reference for this object now.
	io->hdr_it = it;				// 设置为内存储存item位置
	
	// FIXME: error handling.
	// The offsets we'll wipe on a miss.
	io->iovec_start = iovst;	// 设置在iov中的开始位置
	io->iovec_count = iovcnt;	// 使用iov的个数
	// This is probably super dangerous. Keep it at 0 and fill into wrap
	// object?
	if (chunked) {
		// 使用chunked方式存储
		unsigned int ciovcnt = 1;
		size_t remain = new_it->nbytes;	// 设置item的值长度
		item_chunk *chunk = (item_chunk *)ITEM_schunk(new_it);  // 设置item的值
		io->io.iov = &c->iov[c->iovused];	  // 设置io操作时读取写入的位置
		// fill the header so we can get the full data - crc back.
		add_iov(c, new_it, ITEM_ntotal(new_it) - new_it->nbytes);
		// 循环申请空间，加入到iov数组中，从外存读取item的值放入到iov数组指定的位置
		while (remain > 0) {
			chunk = do_item_alloc_chunk(chunk, remain);  // 申请空间
			if (chunk == NULL) {
				item_remove(new_it);
				do_cache_free(c->thread->io_cache, io);
				return -1;
			}
			// 将存储空间加入到iov指定的缓存数组中
			add_iov(c, chunk->data, (remain < chunk->size) ? remain : chunk->size);
			chunk->used = (remain < chunk->size) ? remain : chunk->size; // 使用大小
			remain -= chunk->size;		// 还需要储存的长度
			ciovcnt++;					// 记录缓存空间的长度
		}
		io->io.iovcnt = ciovcnt;		// 记录缓存空间的长度
		// header object was already accounted for, remove one from total
		io->iovec_count += ciovcnt-1;
	} else {
		// 非chunked方式存储
		io->io.iov = NULL;				// 不适用iov结构来存储读取的内容
		io->iovec_data = c->iovused;
		add_iov(c, "", it->nbytes);
	}
	io->io.buf = (void *)new_it;		// 设置io操作结构体的buf
	// The offset we'll fill in on a hit.
	io->c = c;
	// We need to stack the sub-struct IO's together as well.
	// 加入conn的链表中
	if (c->io_wraplist) {
		io->io.next = &c->io_wraplist->io;
	} else {
		io->io.next = NULL;
	}
	// IO queue for this connection.
	io->next = c->io_wraplist;
	c->io_wraplist = io;
	assert(c->io_wraplist >= 0);
	c->io_wrapleft++;	// IO外存操作链表长度加1
	// reference ourselves for the callback.
	io->io.data = (void *)io;		// 指向操作的结构体
	
	// Now, fill in io->io based on what was in our header.
	// 设置IO操作读取的外存位置
#ifdef NEED_ALIGN
	io->io.page_version = hdr.page_version;
	io->io.page_id = hdr.page_id;
	io->io.offset = hdr.offset;
#else
	io->io.page_version = hdr->page_version;
	io->io.page_id = hdr->page_id;
	io->io.offset = hdr->offset;
#endif
	io->io.len = ntotal;	// 需要读取的长度
	io->io.mode = OBJ_IO_READ;  // 外存操作类型
	io.io->cb = _get_extstore_cb;  // 设置外存操作结束后的回调函数
	
	pthread_mutex_lock(&c->thread->stats.mutex);
	c->thread->stats.get_extstore++;
	pthread_mutex_unlock(&c->thread->stats.mutex);
	
	return 0;
}
```
通过上述代码可以看出，`_get_extstore`函数申请新内存空间用于存放外存中的value值，其主要过程有如下几步:

1. 申请`io_wrap`结构体空间，用于保存外存读取的相关信息。
2. 申请新的内存空间。
3. 将外存操作结构体`obj_io`中`iov`指向申请的内存空间，用于读取外存数据内容。
4. 设置外存操作结构体`obj_io`中的外存地址等相关参数。 
5. 将外存操作结构体`obj_io`中`buf`指向新申请的内存`item`空间。
6. 将申请的`io_wrap`结构体链入`conn`的`io_wraplist`链表中。

至此，外存`item`读取相关的准备操作已经完成。`_get_extstore`函数调用结束，操作流程返回到`process_get_command`函数中。当一切读取操作完成后，`process_get_command`函数将`conn`的状态设置为`conn_mwrite`。后续网络子线程对此`conn`的处理流程将进入`conn_mwrite`的相应处理过程。

### 3.2 `conn_mwrite`处理流程(读取外存`item`阶段)
当`conn`处于`conn_mwrite`阶段时，`memcached`会将读取到的`item`值返回给客户端。但在返回之前会检查是否有`item`处在外存中，将会出现如下两种处理情况。

1. 有`item`存在外存中，则先读取`item`的值，然后再将数据发送到客户端。
2. 没有`item`存在外存中，则直接将数据发送给客户端。

其具体的处理流程代码如下:

```
	case conn_mwrite:
#ifdef EXTSTORE
		/* have side IO's that must process before transmit() can run.
		 * remove the connection from the worker thread and dispatch the
		 * IO queue.
		 */
		 // 判断是否有外存读取操作需要处理
		 if (c->io_wrapleft) {
		 		assert(c->io_queued == false);
		 		assert(c->io_wraplist != NULL);
		 		// TODO: create proper state for this condition
		 		// 将conn状态设置为conn_watch，等待外存读取操作完成
		 		conn_set_state(c, conn_watch);
		 		event_del(&c->event);
		 		// 开始提交外存IO操作命令
		 		c->io_queued = true;
		 		extstore_submit(c->thread->storage, &c->io_wraplist->io);
		 		// 暂时停止状态处理机
		 		stop = true;
		 		break;
		 }
#endif
		// 对于UDP的特殊处理
		if (IS_UDP(c->transport) && c->msgcurr == 0 && build_udp_headers(c) != 0) {
			if (settings.verbose > 0)
				fprintf(stderr, "Failed to build UDP headers\n");
			conn_set_state(c, conn_closing);
			break;
		}
		// 开始传输数据
		switch (transmit(c)) {
		case TRANSMIT_COMPLETE:
			if (c->state == conn_mwrite) {
				conn_release_items(c);
				if (c->protocol == binary_prot) {
					conn_set_state(c, c->write_and_go);
				} else {
					conn_set_state(c, conn_new_cmd);
				}
			} else if (c->state == conn_write) {
				if (c->write_and_free) {
					free(c->write_and_free);
					c->write_and_free = 0;
				}
				conn_set_state(c, c->write_and_go);
			} else {
				conn_set_state(c, conn_closing);
			}
			break;
		case TRANSMIT_INCOMPLETE:
		case TRANSMIT_HEAD_ERROR:
			break;				// Continue in state machine
		case TRANSMIT_SOFT_ERROR:
			stop = true;
			break;
		}
		break;

// 提交IO操作的相关代码
/* engine submit funciton; takes engine, item_io stack.
 * lock io_thread context and add stack?
 * signal io thread to wake.
 * return success.
 */
int extstore_submit(void *ptr, obj_io *io) {
	// 轮询选择某个IO操作线程，将IO操作加入到线程的操作队列中
	store_engine *e = (store_engine *)ptr;
	store_io_thread *t = _get_io_thread(e);
	
	pthread_mutex_lock(&t->mutex);
	if (t->queue == NULL) {
		t->queue = io;
	} else {
		/* Have to put the *io stack at the end of current queue.
		 * FIXME: Optimize by tracking tail.
		 */
		obj_io *tmp = t->queue;
		while (tmp->next != NULL) {
			tmp = tmp->next;
			assert(tmp != t->queue);
		}
		tmp->next = io;
	}
	// TODO: extstore_submit(ptr, io, count)
	obj_io *tio = io;
	while (tio != NULL) {
		t->depth++;
		tio = tio->next;
	}
	pthread_mutex_unlock(&t->mutex);
	
	//pthread_mutex_lock(&t->mutex);
	pthread_cond_signal(&t->cond);
	//pthread_mutex_unlock(&t->mutex);
	return 0;
}

// IO操作线程处理读取操作
/* engine IO thread; takes engine context
 * manage writes/reads
 * runs IO callbacks inline after each IO
 */
static void *extstore_io_thread(void *arg) {
	store_io_thread *me = (store_io_thread *)arg;
	store_engine *e = me->e;
	// 开启循环体
	while (1) {
		obj_io *io_stack = NULL;
		pthread_mutex_lock(&me->mutex);
		if (me->queue == NULL) {
			pthread_cond_wait(&me->cond, &me->mutex);
		}
		
		// Pull and disconnect a batch from the queue
		// 从IO操作队列中截取一部分需要处理的IO操作
		if (me->queue != NULL) {
			int i;
			obj_io *end = NULL;
			io_stack = me->queue;
			end = io_stack;
			for (i = 1; i < e->io_depth; i++) {
				if (end->next) {
					end = end->next;
				} else {
					break;
				}
			}
			me->depth -= i;
			me->queue = end->next;
			end->next = NULL;
		}
		pthread_mutex_unlock(&me->mutex);
		
		// 处理IO操作
		obj_io *cur_io = io_stack;
		while (cur_io) {
			// We need to note next before the callback in case the obj_io
			// gets reused.
			obj_io *next = cur_io->next;
			int ret = 0;
			int do_op = 1;
			store_page *p = &e->pages[cur_io->page_id];
			// TODO: loop if not enough bytes were read/written
			switch (cur_io->mode) {			// 操作类型
				case OBJ_IO_READ:			// 读取操作
					// Page is currently open. deal if read is past the end.
					pthread_mutex_lock(&p->mutex);
					// 判断page是否被回收
					if (!p->free && !p->closed && p->version == cur_io->page_version) {
						// 判断是否需要从buf中读取
						if (p->active && cur_io->offset >= p->written) {
							ret = _read_from_wbuf(p, cur_io);
							do_op = 0;
						} else {
							p->refcount++;
						}
						STAT_L(e);
						e->stats.bytes_read += cur_io->len;
						e->stats.objects_read++;
						STAT_UL(e);
					} else {
						do_op = 0;
						ret = -2;
					}
					pthread_mutex_unlock(&p->mutex);
					// 判断是否需要从外存page中读取item信息
					if (do_op) {
						// 判断存放读取item内容的存放地址
						if (cur_io->iov == NULL) {
							// 对于非chunked的item
							ret = pread(p->fd, cur_io->buf, cur_io->len, p->offset + cur_io->offset);
						} else {
							// 针对于chunked的item
							ret = preadv(p->fd, cur_io->iov, cur_io->iovcnt, p->offset + cur_io->offset);
						}
					}
					break;
				case OBJ_IO_WRITE:
					do_op = 0;
					ret = pwrite(p->fd, cur_io->buf, cur_io->len, p->offset + cur_io->offset);
					break;
			}
			if (ret == 0) {
				E_DEBUG("read returned nothing\n");
			}
			
			// 回调函数
			cur_io->cb(e, cur_io, ret);
			if (do_op) {
				pthread_mutex_lock(&p->mutex);
				p->refcount--;
				pthread_mutex_unlock(&p->mutex);
			}
			cur_io = next;
		}
	}
	
	return NULL;
}
```

### 3.3 读取回调处理流程
在3.1小节中可看到`IO`操作结构体中设置的回调函数为`_get_extstore_cb`,其源代码如下:

```
// FIXME: This runs in the IO thread. to get better IO performance this should
// simply mark the io wrapper with the return value and decrement wrapleft, if
// zero redispatching. Still a bit of work being done in the side thread but
// minimized at least.
static void _get_extstore_cb(void *e, obj_io *io, int ret) {
	// FIXME: assumes success
	io_wrap *wrap = (io_wrap *)io->data;
	conn *c = wrap->c;
	assert(wrap->active == true);
	item *read_it = (item *)io->buf;		// 存放item的位置
	bool miss = false;						// 判断item是否已经被丢弃
	
	// TODO: How to do counters for hit/misses?
	if (ret < 1) {
		miss = true;
	} else {
		// 判断item存储前后的crc值来判断其是否被修改
		uint32_t crc2;
		uint32_t crc = (uint32_t) read_it->exptime;
		int x;
		// item is chunked, crc the iov's
		if (io->iov != NULL) {
			// first iov is the header, which we don't use beyond crc
			crc2 = crc32c(0, (char *)io->iov[0].iov_base+STORE_OFFSET, io->iov[0].iov_len-STORE_OFFSET);
			// make sure it's not sent. hack :(
			io->iov[0].iov_len = 0;
			for (x = 1; x < io->iovcnt; x++) {
				crc2 = crc32c(crc2, (char *)io->iov[x].iov_base, io->iov[x].iov_len);
			}
		} else {
			crc2 = crc32c(0, (char *)read_it+STORE_OFFSET, io->len-STORE_OFFSET);
		}
		
		if (crc != crc2) {
			miss = true;
			wrap->badcrc = true;
		}
	}
	
	// 判断是否成功读取出item值
	if (miss) {
		int i;
		struct iovec *v;
		// TODO: This should be movable to the worker thread.
		if (c->protocol == binary_prot) {
			protocol_binary_response_header *header = (protocol_binary_response_header *)c->wbuf;
			// this zeroes out the iovecs since binprot never stacks them.
			if (header->response.keylen) {
				write_bin_miss_response(c, ITEM_key(wrap->hdr_it), wrap->hdr_it->nkey);
			} else {
				write_bin_miss_response(c, 0, 0);
			}
		} else {
			// 对asscii命令的处理
			for (i = 0; i < wrap->iovec_count; i++) {
				v = &c->iov[wrap->iovec_start + i];
				v->iov_len = 0;
				v->iov_base = NULL;
			}
		}
		wrap->miss = true;		// 读取外存item失败
	} else {
		// 读取成功
		assert(read_it->slabs_clsid != 0);
		// kill \r\n for binprot
		if (io->iov == NULL) {
			// 指向需要写出item的位置
			c->iov[wrap->iovec_data].iov_base = ITEM_data(read_it);
			if (c->protocol == binary_prot) 
				c->iov[wrap->iovec_data].iov_len -= 2;
		} else {
			// FIXME: Might need to go back and ensure chunked binprots don't
			// ever span two chunks for the final \r\n
			if (c->protocol == binary_prot) {
				if (io->iov[io->iovcnt-1].iov_len >= 2) {
					io->iov[io->iovcnt-1].iov_len -= 2;
				} else {
					io->iov[io->iovcnt-1].iov_len = 0;
					io->iov[io->iovcnt-2].iov_len -= 1;
				}
			}
		}
		wrap->miss = false;		// 成功读取外存item值
		// iov_len is already set
		// TODO: Should do that here instead and cuddle in the wrap object
	}
	c->io_wraplist--;		// 减少IO链表长度
	wrap->active = false;	// 设置wrap的值
	
	// All IO's have returned, lets re-attach this connection to our original
	// thread.
	// 判断是否外存读取都完成;都完成后，将conn加入到网络线程的Reactor管理器中
	if (c->io_wrapleft == 0) {
		assert(c->io_queued == false);
		c->io_queued = false;
		redispatch_conn(c);		// 重新将conn加入到网络子线程的监听队列中,其状态仍为conn_mwrite
	}
}
```
通过上述的代码可以看出，读取完成外存`item`后，再次将`conn`加入到网络子线程的监听队列中。此时`conn`的状态仍为`conn_mwrite`状态，后续操作依然为写出操作，继续将需要写出的`item`返回给客户端。

### 3.4 读取流程图示
整个外存读取过程如下图所示，针对于`chunked`类型非`chunked`类型的`item`读取都有详细的结构体记录说明。

![外存item的读取流程](https://github.com/whynotAC/analysis_memcached/blob/master/exstore/外存Item读取流程.png)

# 4. 总结
至此，`memcached`中有关外存的介绍已经完结。
