网络子线程命令处理流程
============================
前面介绍了`memcached`的网络模型，以及对应网络套接字的整个生命周期。本文将详细介绍，`memcached`网络子线程在处理网络套接字发送过来命令信息的处理流程，以及如何跟原来介绍过的`slab`、`hash`和`item`相结合。`memcached`处理套接字命令的流程都被封装在`memcached.c`文件中的`dirve_machine`函数中，主要使用的结构体为`struct conn`，这将成为重点的介绍对象。

## 0.基础命令介绍
首先介绍一下，`memcached`支持的通信协议有一下三种:

* `local_transport`,本地通信
* `tcp_transport`,tcp通信协议(重点介绍对象)
* `udp_transport`,udp通信协议(处理较为简单，自行学习)

三种通信协议由`network_transport`枚举来定义，其在`memcached`中的定义如下:

```
enum network_transport {
	local_transport,
	tcp_transport,
	udp_transport
};
```

其次，`memcached`支持的命令解析协议由一下三种:

* `ascii_prot`,ASCII字节码命令解析
* `binary_prot`,二进制命令解析
* `negotiating_prot`,根据发送过来命令的字节解析是`ascii_prot`还是`binary_prot`命令

三种命令解析协议由`protocol`枚举来定义，其在`memcached`中的定义如下:

```
enum protocol {
	ascii_prot = 3,
	binary_prot,
	negotiating_prot
};
```
备注:命令解析协议仅在命令解析时不同，在`item`获取处理层面达成统一，后续会介绍。

`memcached`常用的命令有一下几种(以`ASCII`命令为例):

| 命令类型 | 命令集合 |
| ------- | -------|
| 存储命令 | `add/set/repalce/append/prepend/cas` |
| 查找命令 | `get/gets/delete/incr/decr` |
| 统计命令 | `stats/stats item/stats slabs/stats size/flush_all`|

每种命令的更加详细的使用方式、具体的参数，可以点击[传送门](https://www.runoob.com/memcached/memcached-add-data.html)（虽然传送门里面的命令不是都正确，但是也能大致了解一下命令）。

**补充知识点:**



## 1.结构体与枚举值
任何程序都离不开合适的结构体来实现其相应的算法或者函数，本小节将详细介绍`memcached`使用的结构体，从而更加清楚的介绍后面的函数处理流程。

网络套接的使用的结构体`staruct conn`(在`memcached.h`文件中):

```
/**
 * The structure representing a connection into memcached.
 */
struct conn {
	int sfd;	// 使用的文件描述符/网络套接字
#ifdef TLS	// 使用SSL安全时需要注意的结构体成员，本文将不做介绍
	SSL *ssl;
	char *ssl_wbuf;
	bool ssl_enabled;
#endif
	sasl_conn_t *sasl_conn;	// 有关认证一类的安全，本文都不做介绍
	bool sasl_started; // 有关认证一类的安全，本文都不做介绍
	bool authenticated;	// 有关认证一类的安全，本文都不做介绍
	
	enum conn_states state;		// 链接字处于的状态，drive_machine函数处理struct conn的主要状态依据
	enum bin_substates substate; // 二进制命令处理时的命令头
	
	rel_time_t last_cmd_time;	// 最后处理命令的时间戳，用于判断是否空闲超时
	
	struct event event;	 // 用于libevent的结构体成员
	short ev_flags;
	short which;		/** which events were just in triggered */
	
	// struct conn读入命令的重要结构体成员
	char 	*rbuf; /** buffer to read commands into */
	char 	*rcurr; /** but if we parsed some already, this is where we stopped */
	int 	rsize; /** total allocated size of rbuf */
	int 	rbytes; /** how much data, starting from curr, do we have unparsed */
	// rbuf --- 用于保存从套接字读取发送过来的数据。
	// rcurr --- 用于保存现在读取到的位置,在rbuf中的位置
	// rsize --- 用于保存rbuf的大小
	// rbytes --- 用于保存读入的字节中，还有多少字节未被处理
	// struct conn读入命令的重要结构体成员
	
	// struct conn用于简单写出的结构体成员,类似于`out_string`函数写出或者组装二进制写出头
	char *wbuf;		// 预先申请的写出空间
	char *wcurr; 		// 用于指向写出的位置，最终将加入msglist后传输到
	int wsize;		// wbuf预先分配的大小
	int wbytes;		// 需要写出的大小，即wcurr指向的大小
	// struct conn用于简单写出的结构体成员
	
	/** which state to go into after finishing current write */
	enum conn_states write_and_go;	// 写出数据后，需要跳转到conn_xxx状态
	void *write_and_free;	// free this memory after finishing writing
	// write_and_free 用于其它时刻申请的写出缓冲区，写出完成后释放其空间
	
	// ritem 用于指向读入存放的位置，二进制与ASCII指向不同
	char *ritem;	// when we read in a item's value, it goes here
	int	  rlbytes; // 需要读入数据的字节个数
	
	/* dat for the nread state */
	
	/**
	 * item is used to hold an item structure created after reading the command
	 * line of set/add/replace commands, but before we finished reading the actual
	 * data. The data is read into ITEM_data(item) to avoid extra copying.
	 */
	 void *item;	// for commands set/add/replace
	 // item用于指向操作的item结构体
	 
	 /* data for the swallow state */
	 int sbytes;		// how many bytes to swallow
	 // sbytes --- 用于保存需要放弃的字节个数，当出现信息无法即时处理时，会丢弃读入的字节信息
	 
	 /* data for the mwrite state */
	 struct iovec *iov;
	 int	iovsize;	// number of elements allocated in iov[]
	 int 	iovussed;	// number of elements used in iov[]
	 
	 struct msghdr *msglist;
	 int	msgsize;	// number of elements allocated in msglist[]
	 int	msgused;	// number of elements used in msglist[]
	 int 	msgcurr;	// element of msglist[] being transmitted now
	 int 	msgbytes;	// number of bytes in current msg
	 // 上面两个结构体都是关于conn写出数据时使用，后面写出时会有详细介绍
	 
	 item	**ilist;	// list of items to write out
	 int	isize;
	 item	**icurr;
	 int	ileft;
	 // 这四个成员用于记录需要发送的item信息
	 
	 char	**suffixlist;
	 int	suffixsize;
	 char	**suffixcurr;
	 int	suffixleft;
	 // 这四个成员在函数_ascii_get_suffix_buf中分配，在make_ascii_get_suffix中使用。
	 // suffixlist指向thread的suffix_cache,用于存放函数process_get_command处理的
	 // item的标志位信息。例如:位于哪一个slab、item的value大小等
	 
#ifdef EXTSTORE	//用于外存,后面有一章节单独介绍,这几个成员主要用于从外存读取item
	 int io_wrapleft;	// 还有多少item的value值需要读取
	 unsigned int recache_counter;
	 io_wrap *io_wraplist;	// 需要读取item的处理列表
	 bool	io_queued;	// FIXME: debugging flag
#endif

	 enum protocol protocol;		// which protocol this connection speaks
	 enum network_transport transport;	// what transport is used by this connection
	 
	 /* data for UDP clients */
	 // 用于UDP协议,本文不做详细介绍(有需要的同学自行分析，理解TCP就觉得UDP较为简单)
	 int	request_id;	// Incoming UDP request iD, if this is a UDP "connection" */
	 struct sockaddr_in6 request_addr;	// udp: who sent the most recent request
	 socklen_t request_addr_size;
	 unsigned char *hdrbuf;	// udp packet headers
	 int	hdrsize;	// number of headers' worth of space is allocated
	 
	 // 用于记录是否需要返回操作状态
	 bool	noreply;	// True if the reply should not be sent.

	 // 状态查看
	 // current stats command
	 struct {
		char *buffer;
		size_t size;
		size_t offset;	
	 } stats;
	 
	 /* Binary protocol stuff */
	 /* This is where the binary header goes */
	 protocol_binary_request_header binary_header; // 二进制协议的命令头
	 uint64_t cas;	// the cas to return
	 short cmd;		// current comand being processed 二进制协议的处理命令
	 int opaque;
	 int keylen;
	 // 上面的成员都与二进制命令相关
	 
	 conn *next;	// Used for generating a list of conn structures
	 LIBEVENT_THREAD *thread;	// Pointer to the thread object serving this connection
	 
	 // 函数指针，对于不同的网络协议使用不同的函数
	 int (*try_read_command)(conn *c); // pointer for top level input parser
	 ssize_t (*read)(conn *c, void *buf, size_t count);
	 ssize_t (*sendmsg)(conn *c, struct msghdr *msg, int flags);
	 ssize_t (*wirte)(conn *c, void *buf, size_t count);
};
```

前面介绍过了`memcached`的网络模型，由此可知新的`struct conn`结构体的初始化是在`conn_new`函数中进行(忘记的同学再去复习网络那一部分)。起初始化代码如下:

```
conn *conn_new(const int sfd, enum conn_states init_state,
					const int event_flags,
					const int read_buffer_size, enum network_transport transport,
					struct event_base *base, void *ssl) {
	conn *c;	// 用来关联网络套接字的struct conn结构体
	
	assert(sfd >= 0 && sfd < max_fds);	// 判断是否超出了最大套接字的值
	c = conns[sfd];	// 判断原先这个套接字对应的struct conn是否被申请过
		
	if (NULL == c) {
		if (!(c = (conn *)calloc(1, sizeof(conn)))) {
			STATS_LOCK();
			stats.malloc_fails++;
			STATS_UNLOCK();
			fprintf(stderr, "Failed to allocate connection object\n");
			return NULL;
		}
		MEMCACHED_CONN_CREATE(c);
		// 下面进入了struct conn成员的初始化过程
		// 函数指针初始化，用于不同的网络通信协议
		c->read = NULL;
		c->sendmsg = NULL;
		c->write = NULL;
		
		c->rbuf = c->wbuf = 0;
		c->ilist = 0;
		c->suffixlist = 0;
		c->iov = 0;
		c->msglist = 0;
		c->hdrbuf = 0;
		
		c->rsize = read_buffer_size;	// 读取缓冲区大小
		c->wsize = DATA_BUFFER_SIZE;	// 写出缓冲区大小
		c->isize = ITEM_LIST_INITIAL;	// 初始化写出item数组的大小
		c->suffixsize = SUFFIX_LIST_INITIAL; // 写出item的标志位的数组大小
		c->iovsize = IOV_LIST_INITIAL; // 写出的struct iovec结构体的数组大小
		c->msgsize = MSG_LIST_INTITAL; // 写出的struct msghdr结构体的数组大小
		c->hdrsize = 0; // 用于UDP，不做介绍
		
		// 根据上面初始化的大小，申请空间
		c->rbuf = (char *)malloc((size_t)c->rsize); // 读取空间
		c->wbuf = (char *)malloc((size_t)c->wsize); // 写出空间
		c->ilist = (item **)malloc(sizeof(item *) * c->isize); // 用于保存需要写出的item
		c->suffixlist = (char **)malloc(sizeof(char *) * c->suffixsize); // 用于保存item中标志位的位置数组
		c->iov = (struct iovec*)malloc(sizeof(struct iovec) * c->iovsize); // 用于写出的struct iovec结构的数组
		c->msglist = (struct msghdr*)malloc(sizeof(struct msghdr *) * c->msgsize); // 用于写出的struct msghdr结构的数组
		
		if (c->rbuf == 0 || c->wbuf == 0 || c->ilist == 0 || c->iov == 0 ||
				c->msglist == 0 || c->suffixlist == 0) {
			conn_free(c);
			STATS_LOCK();
			stats.malloc_fails++;
			STATS_UNLOCK();
			fprintf(stderr, "Failed to allocate buffers for connection\n");
			return NULL;
		}
		
		STATS_LOCK();
		stats_state.conn_structs++;
		STATS_UNLOCK();
		
		// 记录此struct conn结构体
		c->sfd = sfd;
		conns[sfd] = c;
	}
	
	// 设置使用的协议
	c->transport = transport;	// 传输协议
	c->protocol = settings.binding_protocol; // 命令解析协议
	
	/* unix socket mode doesn't need this, so zeroed out. but why
	 * is this done for every command? prsumably for UDP 
	 * mode. */
   	if (!settings.socketpath) {
   		c->request_addr_size = sizeof(c->request_addr);
   	} else {
   		c->request_addr_size = 0;
   	}
   	
   	if (transport == tcp_transport && init_state == conn_new_cmd) {
   		if (getpeername(sfd, (struct sockaddr *) &c->request_addr,
   								&c->request_addr_size)) {
   			perror("getpeername");
   			memset(&c->request_addr, 0, sizeof(c->request_addr));
   		}
   	}
   	
   	// 日志代码
   	
#ifdef TLS
	c->ssl = NULL;
	c->ssl_wbuf = NULL;
	c->ssl_enabled = false;
#endif
	c->state = init_state;	// 初始化struct conn的状态，新struct conn的状态为conn_new_cmd
	c->rlbytes = 0; // 还需要读取多少字节的标志位
	c->cmd = -1;		// 用于二进制命令的解析
	c->rbytes = c->wbytes = 0; // 分别表示有多少字节未被处理或者未被写出
	c->wcurr = c->wbuf;	// 用于标示需要写出的字节位置
	c->rcurr = c->rbuf;	// 用于标示需要解析的读入字节的开始位置
	c->ritem = 0;		// 记录用于读入value数据的位置
	c->icurr = c->ilist;	// 用于记录需要写出item数组的可以存放的开始位置
	c->suffixcurr = c->suffixlist; // 用于记录写出item的标示位的存放开始位置
	c->ileft = 0;		// 用于记录还有多少item需要发送
	c->suffixleft = 0; // 用于记录item的标示位还有多少需要发送
	c->iovused = 0; // struct iovec数组中使用的位置也是个数
	c->msgcurr = 0; // struct msghdr数组中可以使用的位置
	c->msgused = 0; // struct msghdr数组中已使用的大小
	c->sasl_started = false;
	c->last_cmd_time = current_time;	// 链接最后执行命令时间，跟生命周期有关，前面已介绍过
#ifdef EXTSTORE	// 外存(后续会有单独介绍)
	c->io_wraplist = NULL; // 读取外存item的IO命令列表
	c->io_wrapleft = 0; // 已经处理完的IO命令的个数
#endif

	c->wirte_and_go = init_state;	// 当写出后，设置conn的状态
	c->write_and_free = 0; // 用于记录临时申请的写出空间，写出后需要释放
	c->item = 0; // add/set/replace操作的item
	
	c->noreply = false;	// 是否需要回复信息
	
	// TLS的相关设置,不做重点介绍
	
	{
		// 设置struct conn的函数指针
		c->read = tcp_read;
		c->sendmsg = tcp_sendmsg;
		c->write = tcp_write;
	}
	
	// 设置try_read_command函数指针
	if (IS_UDP(transport)) {
		c->try_read_command = try_read_command_udp;
	} else {
		switch (c->protocol) {
			case ascii_prot:
				if (settings.auth_file == NULL) {
					c->authenticated = true;
					c->try_read_command = try_read_command_ascii;
				} else {
					c->authenticated = false;
					c->try_read_command = try_read_command_asciiauth;
				}
				break;
			case binary_prot:
				// binprot handles its own authentication via SASL parsing.
				c->authenticated = false;
				c->try_read_command = try_read_command_binary;
				break;
			case negotiating_prot:
				c->try_read_command = try_read_command_negotiate;
				break;
		}
	}
	
	// 设置strcut conn的处理函数event_handler
	event_set(&c->event, sfd, event_flags, event_handler, (void *)c);
	event_base_set(base, &c->event);
	c->ev_flags = event_flags;
	
	// 其他统计信息
	
	return c;
}
```