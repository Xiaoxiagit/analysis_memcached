网络子线程命令处理流程
============================
前面介绍了`memcached`的网络模型，以及对应网络套接字的整个生命周期。本文将详细介绍，`memcached`网络子线程在处理网络套接字发送过来命令信息的处理流程，以及如何跟原来介绍过的`slab`、`hash`和`item`相结合。`memcached`处理套接字命令的流程都被封装在`memcached.c`文件中的`dirve_machine`函数中，主要使用的结构体为`struct conn`，这将成为重点的介绍对象。

## 0.基础命令介绍
首先介绍一下，`memcached`支持的通信协议有一下三种:

* `local_transport`,本地通信
* `tcp_transport`,tcp通信协议(重点介绍对象)
* `udp_transport`,udp通信协议(处理较为简单，自行学习)

三种通信协议由`network_transport`枚举来定义，其在`memcached`中的定义如下:

```
enum network_transport {
	local_transport,
	tcp_transport,
	udp_transport
};
```

其次，`memcached`支持的命令解析协议由一下三种:

* `ascii_prot`,ASCII字节码命令解析
* `binary_prot`,二进制命令解析
* `negotiating_prot`,根据发送过来命令的字节解析是`ascii_prot`还是`binary_prot`命令

三种命令解析协议由`protocol`枚举来定义，其在`memcached`中的定义如下:

```
enum protocol {
	ascii_prot = 3,
	binary_prot,
	negotiating_prot
};
```
备注:命令解析协议仅在命令解析时不同，在`item`获取处理层面达成统一，后续会介绍。

`memcached`常用的命令有一下几种(以`ASCII`命令为例):

| 命令类型 | 命令集合 |
| ------- | -------|
| 存储命令 | `add/set/repalce/append/prepend/cas` |
| 查找命令 | `get/gets/delete/incr/decr` |
| 统计命令 | `stats/stats item/stats slabs/stats size/flush_all`|

每种命令的更加详细的使用方式、具体的参数，可以点击[传送门](https://www.runoob.com/memcached/memcached-add-data.html)（虽然传送门里面的命令不是都正确，但是也能大致了解一下命令）。

## 1.结构体与枚举值
任何程序都离不开合适的结构体来实现其相应的算法或者函数，本小节将详细介绍`memcached`使用的结构体，从而更加清楚的介绍后面的函数处理流程。

网络套接的使用的结构体`staruct conn`(在`memcached.h`文件中):

```
/**
 * The structure representing a connection into memcached.
 */
struct conn {
	int sfd;	// 使用的文件描述符/网络套接字
#ifdef TLS	// 使用SSL安全时需要注意的结构体成员，本文将不做介绍
	SSL *ssl;
	char *ssl_wbuf;
	bool ssl_enabled;
#endif
	sasl_conn_t *sasl_conn;	// 有关认证一类的安全，本文都不做介绍
	bool sasl_started; // 有关认证一类的安全，本文都不做介绍
	bool authenticated;	// 有关认证一类的安全，本文都不做介绍
	
	enum conn_states state;		// 链接字处于的状态，drive_machine函数处理struct conn的主要状态依据
	enum bin_substates substate; // 二进制命令处理时的命令头
	
	rel_time_t last_cmd_time;	// 最后处理命令的时间戳，用于判断是否空闲超时
	
	struct event event;	 // 用于libevent的结构体成员
	short ev_flags;
	short which;		/** which events were just in triggered */
	
	// struct conn读入命令的重要结构体成员
	char 	*rbuf; /** buffer to read commands into */
	char 	*rcurr; /** but if we parsed some already, this is where we stopped */
	int 	rsize; /** total allocated size of rbuf */
	int 	rbytes; /** how much data, starting from curr, do we have unparsed */
	// rbuf --- 用于保存从套接字读取发送过来的数据。
	// rcurr --- 用于保存现在读取到的位置,在rbuf中的位置
	// rsize --- 用于保存rbuf的大小
	// rbytes --- 用于保存读入的字节中，还有多少字节未被处理
	// struct conn读入命令的重要结构体成员
	
	// struct conn用于简单写出的结构体成员,类似于`out_string`函数写出或者组装二进制写出头
	char *wbuf;		// 预先申请的写出空间
	char *wcurr; 		// 用于指向写出的位置，最终将加入msglist后传输到
	int wsize;		// wbuf预先分配的大小
	int wbytes;		// 需要写出的大小，即wcurr指向的大小
	// struct conn用于简单写出的结构体成员
	
	/** which state to go into after finishing current write */
	enum conn_states write_and_go;	// 写出数据后，需要跳转到conn_xxx状态
	void *write_and_free;	// free this memory after finishing writing
	// write_and_free 用于其它时刻申请的写出缓冲区，写出完成后释放其空间
	
	// ritem 用于指向读入存放的位置，二进制与ASCII指向不同
	char *ritem;	// when we read in a item's value, it goes here
	int	  rlbytes; // 需要读入数据的字节个数
	
	/* dat for the nread state */
	
	/**
	 * item is used to hold an item structure created after reading the command
	 * line of set/add/replace commands, but before we finished reading the actual
	 * data. The data is read into ITEM_data(item) to avoid extra copying.
	 */
	 void *item;	// for commands set/add/replace
	 // item用于指向操作的item结构体
	 
	 /* data for the swallow state */
	 int sbytes;		// how many bytes to swallow
	 // sbytes --- 用于保存需要放弃的字节个数，当出现信息无法即时处理时，会丢弃读入的字节信息
	 
	 /* data for the mwrite state */
	 struct iovec *iov;
	 int	iovsize;	// number of elements allocated in iov[]
	 int 	iovussed;	// number of elements used in iov[]
	 
	 struct msghdr *msglist;
	 int	msgsize;	// number of elements allocated in msglist[]
	 int	msgused;	// number of elements used in msglist[]
	 int 	msgcurr;	// element of msglist[] being transmitted now
	 int 	msgbytes;	// number of bytes in current msg
	 // 上面两个结构体都是关于conn写出数据时使用，后面写出时会有详细介绍
	 
	 item	**ilist;	// list of items to write out
	 int	isize;
	 item	**icurr;
	 int	ileft;
	 // 这四个成员用于记录需要发送的item信息
	 
	 char	**suffixlist;
	 int	suffixsize;
	 char	**suffixcurr;
	 int	suffixleft;
	 // 这四个成员在函数_ascii_get_suffix_buf中分配，在make_ascii_get_suffix中使用。
	 // suffixlist指向thread的suffix_cache,用于存放函数process_get_command处理的
	 // item的标志位信息。例如:位于哪一个slab、item的value大小等
	 
#ifdef EXTSTORE	//用于外存,后面有一章节单独介绍,这几个成员主要用于从外存读取item
	 int io_wrapleft;	// 还有多少item的value值需要读取
	 unsigned int recache_counter;
	 io_wrap *io_wraplist;	// 需要读取item的处理列表
	 bool	io_queued;	// FIXME: debugging flag
#endif

	 enum protocol protocol;		// which protocol this connection speaks
	 enum network_transport transport;	// what transport is used by this connection
	 
	 /* data for UDP clients */
	 // 用于UDP协议,本文不做详细介绍(有需要的同学自行分析，理解TCP就觉得UDP较为简单)
	 int	request_id;	// Incoming UDP request iD, if this is a UDP "connection" */
	 struct sockaddr_in6 request_addr;	// udp: who sent the most recent request
	 socklen_t request_addr_size;
	 unsigned char *hdrbuf;	// udp packet headers
	 int	hdrsize;	// number of headers' worth of space is allocated
	 
	 // 用于记录是否需要返回操作状态
	 bool	noreply;	// True if the reply should not be sent.

	 // 状态查看
	 // current stats command
	 struct {
		char *buffer;
		size_t size;
		size_t offset;	
	 } stats;
	 
	 /* Binary protocol stuff */
	 /* This is where the binary header goes */
	 protocol_binary_request_header binary_header; // 二进制协议的命令头
	 uint64_t cas;	// the cas to return
	 short cmd;		// current comand being processed 二进制协议的处理命令
	 int opaque;
	 int keylen;
	 // 上面的成员都与二进制命令相关
	 
	 conn *next;	// Used for generating a list of conn structures
	 LIBEVENT_THREAD *thread;	// Pointer to the thread object serving this connection
	 
	 // 函数指针，对于不同的网络协议使用不同的函数
	 int (*try_read_command)(conn *c); // pointer for top level input parser
	 ssize_t (*read)(conn *c, void *buf, size_t count);
	 ssize_t (*sendmsg)(conn *c, struct msghdr *msg, int flags);
	 ssize_t (*wirte)(conn *c, void *buf, size_t count);
};
```