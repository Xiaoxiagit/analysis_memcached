网络子线程命令处理流程
============================
前面介绍了`memcached`的网络模型，以及对应网络套接字的整个生命周期。本文将详细介绍，`memcached`网络子线程在处理网络套接字发送过来命令信息的处理流程，以及如何跟原来介绍过的`slab`、`hash`和`item`相结合。`memcached`处理套接字命令的流程都被封装在`memcached.c`文件中的`dirve_machine`函数中，主要使用的结构体为`struct conn`，这将成为重点的介绍对象。

## 1.结构体与枚举值
任何程序都离不开合适的结构体来实现其相应的算法或者函数，本小节将详细介绍`memcached`使用的结构体，从而更加清楚的介绍后面的函数处理流程。

网络套接的使用的结构体`staruct conn`(在`memcached.h`文件中):

```
/**
 * The structure representing a connection into memcached.
 */
struct conn {
	int sfd;	// 使用的文件描述符/网络套接字
#ifdef TLS	// 使用SSL安全时需要注意的结构体成员，本文将不做介绍
	SSL *ssl;
	char *ssl_wbuf;
	bool ssl_enabled;
#endif
	sasl_conn_t *sasl_conn;	// 有关认证一类的安全，本文都不做介绍
	bool sasl_started; // 有关认证一类的安全，本文都不做介绍
	bool authenticated;	// 有关认证一类的安全，本文都不做介绍
	
	enum conn_states state;		// 链接字处于的状态，drive_machine函数处理struct conn的主要状态依据
	enum bin_substates substate; // 二进制命令处理时的命令头
	
	rel_time_t last_cmd_time;	// 最后处理命令的时间戳，用于判断是否空闲超时
	
	struct event event;	 // 用于libevent的结构体成员
	short ev_flags;
	short which;		/** which events were just in triggered */
	
	// struct conn读入命令的重要结构体成员
	char 	*rbuf; /** buffer to read commands into */
	char 	*rcurr; /** but if we parsed some already, this is where we stopped */
	int 	rsize; /** total allocated size of rbuf */
	int 	rbytes; /** how much data, starting from curr, do we have unparsed */
	// rbuf --- 用于保存从套接字读取发送过来的数据。
	// rcurr --- 用于保存现在读取到的位置,在rbuf中的位置
	// rsize --- 用于保存rbuf的大小
	// rbytes --- 用于保存读入的字节中，还有多少字节未被处理
	// struct conn读入命令的重要结构体成员
	
	// struct conn用于简单写出的结构体成员,类似于`out_string`函数写出或者组装二进制写出头
	char *wbuf;		// 预先申请的写出空间
	char *wcurr; 		// 用于指向写出的位置，最终将加入msglist后传输到
	int wsize;		// wbuf预先分配的大小
	int wbytes;		// 需要写出的大小，即wcurr指向的大小
	// struct conn用于简单写出的结构体成员
	
	/** which state to go into after finishing current write */
	enum conn_states write_and_go;	// 写出数据后，需要跳转到conn_xxx状态
	void *write_and_free;	// free this memory after finishing writing
	// write_and_free 用于其它时刻申请的写出缓冲区，写出完成后释放其空间
	
	// ritem 用于指向读入存放的位置，二进制与ASCII指向不同
	char *ritem;	// when we read in a item's value, it goes here
	int	  rlbytes; // 需要读入数据的字节个数
	
	/* dat for the nread state */
	
	/**
	 * item is used to hold an item structure created after reading the command
	 * line of set/add/replace commands, but before we finished reading the actual
	 * data. The data is read into ITEM_data(item) to avoid extra copying.
	 */
	 void *item;	// for commands set/add/replace
	 // item用于指向操作的item结构体
	 
	 /* data for the swallow state */
	 int sbytes;		// how many bytes to swallow
	 // sbytes --- 用于保存需要放弃的字节个数，当出现信息无法即时处理时，会丢弃读入的字节信息
	 
	 /* data for the mwrite state */
	 struct iovec *iov;
	 
};
```