网络子线程命令解析
==================================
前面介绍了4种`conn`的状态，其中`conn_parse_cmd`状态用来解析客户端发送过来的命令(`process_command`函数)。本文将详细介绍此函数，并根据`process_command`函数设置`conn`状态来介绍剩下的`conn`状态的处理过程。

#1. `process_command`函数体
首先来查看`process_command`的源代码，从而进一步介绍`memcached`种常用的几个命令，例如`get/gets/add/set/replace/delete`等操作。

```
static void process_command(conn *c, char *command) {
	
	token_t tokens[MAX_TOKENS];		// 命令以及其参数
	size_t ntokens;						// 解析出来参数的个数
	int comm;
	
	assert(c != NULL);
	
	MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
	
	if (settings.verbose > 1)
		fprintf(stderr, "<%d %s\n", c->sfd, command);
		
	/**
	 * for commands set/add/replace, we build an item and read the data
	 * directly into it, then continue in nread_complete().
	 */
	
	// 初始化需要发送的数组
	c->msgcurr = 0;	
	c->msgused = 0;
	c->iovused = 0;
	if (add_msg(c) != 0) {		// 如果是UDP网络协议，空余出发送数据头
		out_of_memory(c, "SERVER_ERROR out of memory preparing response");
		return;
	}
	
	ntokens = tokenize_command(command, tokens, MAX_TOKENS);  // 从接受字节中解析命令
	if (ntokens >= 3 &&
			((strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "bget") == 0))) { // get命令
		
		process_get_command(c, tokens, ntokens, false, false);
		
	} else if ((ntokens == 6 || ntokens == 7) &&
			((strcmp(tokens[COMMAND_TOKEN].value, "add") == 0 && (comm = NREAD_ADD)) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "set") == 0 && (comm = NREAD_SET)) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) )) {
		// 注意这里comm是设置操作
		process_update_command(c, tokens, ntokens, comm, false);
	
	} else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, "cas") == 0 && (comm = NREAD_CAS))) {
		// 注意这里comm是设置操作
		process_update_command(c, tokens, ntokens, comm, ture);
	
	} else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0)) {
		
		process_arithmetic_command(c, tokens, ntokens, 1);
		
	} else if ((ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0)) {
	
		process_get_command(c, tokens, ntokens, true, false);
	
	} else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "decr") == 0)) {
	
		process_arithmetic_command(c, tokens, ntokens, 0);
	
	} else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, "delete") == 0)) {
	
		process_delete_command(c, tokens, ntokens, 0);
		
	} else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "touch") == 0)) {
		
		process_touch_command(c, tokens, ntokens);
	 
	} else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gat") == 0) {
	
		process_get_command(c, tokens, ntokens, false, true);
	
	} else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gats" == 0)) {
	
		process_get_command(c, tokens, ntokens, true, true);
	
	} else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "stats") == 0)) {
	
		process_stat(c, tokens, ntokens);
	
	} else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "flush_all") == 0)) {
		// 删除所有item
		time_t exptime = 0;
		rel_time_t new_oldest = 0;
		
		set_noreply_maybe(c, tokens, ntokens); // 设置是否需要返回值
		
		pthread_mutex_lock(&c->thread->stats.mutex);
		c->thread->stats.flush_cmds++;
		pthread_mutex_unlock(&c->thread->stats.mutex);
		
		if (!setttings.flush_enabled) {
			// flush_all is not allowed but we log it an stats
			out_string(c, "CLIENT_ERROR flush_all not allowed"); // 输出字符串
			return;
		}
		
		if (ntokens != (c->noreply ? 3 : 2)) {
			exptime = strtol(tokens[1].value, NULL, 10); // 获取设置的超时时间
			if (errno == ERANGE) {
				out_string(c, "CLIENT_ERROR bad command line format");
				return;
			}
		}
		
		/**
		 * If exptime is zero realtime() would return zero too, and
		 * realtime(exptime) - 1 would overflow to the max unsigned
		 * value. So we process exptime == 0 the same way we do when
		 * no delay is given at all.
		 */
		if (exptime > 0) {
			new_oldest = realtime(exptime); // 设置最老item的时间
		} else { // exptime == 0
			new_oldest = current_time;
		}
	
		if (settings.use_cas) {
			settings.oldest_live = new_oldest - 1;
			if (settings.oldest_live <= current_time)
				settings.oldest_cas = get_cas_id();
		} else {
			settings.oldest_live = new_oldest;
		}
		out_string(c, "OK");
		return;
		
	} else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "version") == 0)) {
		
		out_string(c, "VERSION " VERSION);
		
	} else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "quit") == 0)) {
	
		conn_set_state(c, conn_closing);
		
	} else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "shutdown") == 0)) {
	
		if (settings.shutdown_command) {
			conn_set_state(c, conn_closing);
			raise(SIGINT);
		} else {
			out_string(c, "ERROR: shutdown not enabled");
		}
	
	} else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "slabs") == 0) {
		// 对于slab管理的操作
		if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, "reassign") == 0) {
			// 调用slab reassign操作
			int src, dst, rv;
			
			if (settings.slab_reassign == false) {
				out_string(c, "CLIENT_ERROR slab reassignment disabled");
				return;
			}
			
			src = strtol(tokens[2].value, NULL, 10);
			dst = strtol(tokens[3].value, NULL, 10);
			
			if (errno == ERANGE) {
				out_string(c, "CLIENT_ERROR bad command line format");
				return;
			}
			
			rv = slabs_reassign(src, dst);
			switch (rv) {
			case REASSIGN_OK:
				out_string(c, "OK");
				break;
			case REASSIGN_RUNNING:
				out_string(c, "BUSY currently processing reassign request");
				break;
			case REASSIGN_BADCLASS:
				out_string(c, "BADCLASS invalid src or dst class id");
				break;
			case REASSIGN_NOSPARE:
				out_string(c, "NOSPARE source class has no spare pages");
				break;
			case REASSIGN_SRC_DST_SAME:
				out_string(c, "SAME src and dst class are identical");
				break;
			}
			return;
		
		} else if (ntokens >= 4 && 
				(strcmp(tokens[COMMAND_TOKEN + 1].value, "automove") == 0)) {
			process_slabs_automove_command(c, tokens, ntokens); // 设置automove的参数
		} else {
			out_string(c, "ERROR");
		}
	
	} else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "lru_crawler") == 0) {
		// 对lru_crawler线程的设置
		if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "crawl") == 0) {
			int rv;
			if (settings.lru_crawler == false) {
				out_string(c, "CLIENT_ERROR lru crawler disabled");
				return;
			}
			
			rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0, settings.lru_crawler_tocrawl); // 开启扫描某一个slab链表
			switch (rv) {
			case CRAWLER_OK:
				out_string(c, "OK");
				break;
			case CRAWLER_RUNNING:
				out_string(c, "BUSY currently processing crawler request");
				break;
			case CRAWLER_BADCLASS:
				out_string(c, "BADCLASS invalid class id");
				break;
			case CRAWLER_NOTSTARTED:
				out_string(c, "NOTSTRTED no items to crawl");
				break;
			case CRAWLER_ERROR:
				out_string(c, "ERROR on unknown error happened");
				break;
			}
			return;
		} else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "metadump") == 0) {
			if (settings.lru_crawler == false) {
				out_string(c, "CLIENT_ERROR lru crawler disabled");
				return;
			}
			if (!settings.dump_enabled) {
				out_string(c, "ERROR metadump not allowed");
				return;
			}
			
			int rv = lru_crawler_crawl(tokens[2].value, CRAWLER_METADUMP, c, c->sfd, LRU_CRAWLER_CAP_REMAINING);
			switch(rv) {
			case CRAWLER_OK:
				out_string(c, "OK");
				conn_set_state(c, conn_watch);
				event_del(&c->event);		// 先将conn从Reactor管理器中去除掉
				break;
			case CRAWLER_RUNNING:
				out_string(c, "BUSY currently processing crawler request");
				break;
			case CRAWLER_BADCLASS:
				out_string(c, "BADCLASS invalid class id");
				break;
			case CRAWLER_NOTSTARTED:
				out_string(c, "NOTSTARTED no items to crawl");
				break;
			case CRAWLER_ERROR:
				out_string(c, "ERROR an unknown error happended");
				break;
			}
			return;
		} else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "tocrawl") == 0) {
			uint32_t tocrawl;
			if (!safe_strtoul(tokens[2].value, &tocrawl)) {
				out_string(c, "CLIENT_ERROR bad command line format");
				return;
			}
			settings.lru_crawler_tocrawl = tocrawl;
			out_string(c, "OK");
			return;
		} else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "sleep") == 0) {
			uint32_t tosleep;
			if (!safe_strtoul(tokens[2].value, &tosleep)) {
				out_string(c, "CLIENT_ERROR bad command line format");
				return;
			}
			if (tosleep > 1000000) {
				out_string(c, "CLIENT_ERROR sleep must be one second or less");
				return;
			}
			settings.lru_crawler_sleep = tosleep;
			out_string(c, "OK");
			return;
		} else if (ntokens == 2) {
			if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "enable") == 0)) {
				if (start_item_crawler_thread() == 0) {
					out_string(c, "OK");
				} else {
					out_string(c, "ERROR failed to start lru crawler thread");
				}
			} else if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "disable") == 0)) {
				if (stop_item_crawler_thread() == 0) {
					out_string(c, "OK");
				} else {
					out_string(c, "ERROR failed to stop lru crawler thread");
				}
			} else {
				out_string(c, "ERROR");
			}
			return;
		} else {
			out_string(c, "ERROR");
		}
	
	} else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "watch") == 0) {
		process_watch_command(c, tokens, ntokens);
		
	} else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "cache_memlimit") == 0)) {
		process_memlimit_command(c, tokens, ntokens);
		
	} else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "verbosity") == 0)) {
		process_verbosity_command(c, tokens, ntokens);
		
	} else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "lru") == 0) {
#ifdef MEMCACHED_DEBUG
	// commands which exist only for testing the memcached's security protection
	} else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "misbehave") == 0)) {
		process_misbehave_command(c);
#endif
#ifdef EXTSTORE
	} else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "extstore") == 0) {
		process_extstore_command(c, tokens, ntokens);
#endif
#ifdef TLS
	} else if (ntokens == 2 && strcmp(tokens[COMMAND_TOKEN].value, "refresh_certs") == 0) {
		set_noreply_maybe(c, tokens, ntokens);
		char *errmsg = NULL;
		if (refresh_certs(&errmsg)) {
			out_string(c, "OK");
		} else {
			write_and_free(c, errmsg, strlen(errmsg));
		}
		return;
#endif
	} else {
		if (ntokens >= 2 && strcmp(tokens[ntokens - 2].value, "HTTP/", 5) == 0) {
			conn_set_state(c, conn_closing);
		} else {
			out_string(c, "ERROR");
		}
	}
	return;
}

// 命令解析函数
typedef struct token_s {
	char *value;
	size_t length;
} token_t;

#define COMMAND_TOKEN 0
#define SUBCOMMAND_TOKEN 1
#define KEY_TOKEN 1

#define MAX_TOKENS 8

/**
 * Tokenize the command string by replacing whitespace with '\0' and update
 * the token array tokens with pointer to start of each token and length.
 * Returns total number of tokens. The last valid token is the terminal
 * token (value points to the first unprocessed character of the string and
 * length zero).
 */
// 理解此段代码需要详细了解client发送过来命令的格式，请读者自行谷歌
static size_t tokenize_command(char *command, token_t *tokens, const size_t max_tokens) {
	char *s, *e;
	size_t ntokens = 0;
	size_t len = strlen(command);	// 上面文章介绍过在try_read_command_ascii函数中将命令截止符\n替换为\0
	unsigned int i = 0;
	
	assert(command != NULL && tokens != NULL && max_tokens > 1);
	
	s = e = command;
	for (i = 0; i < len; i++) {			// 从原字符串中记录对应的命令以及参数等信息
		if (*e == ' ') {
			if (s != e) {
				tokens[ntokens].value = s;
				tokens[ntokens].length = e - s;
				ntokens++;
				*e = '\0';
				if (ntokens == max_tokens - 1) {
					e++;
					s = e;	// so we don't add an extra token
					break;
				}
			}
			s = e + 1;
		}
		e++;
	}
	
	if (s != e) {
		tokens[ntokens].value = s;
		tokens[ntokens].length = e - s;
		ntokens++;
	}
	
	/**
	 * If we scanned the whole string, the terminal value pointer is null,
	 * otherwise it is the first unprocessed character.
	 */
	tokens[ntokens].value = *e == '\0' ? NULL : e;
	tokens[ntokens].length = 0;
	ntokens++;
	
	return ntokens;
}
```
从上面的源代码可看出，命令可分为如下几类:

* 存储命令,例如`add/set/replace/prepend/append/delete`等命令。
* 查找命令,例如`get/gets/incr/decr`等敏玲。
* 统计命令,例如`stats`命令。
* 控制命令,例如`flush_all/quit/shutdown`等命令。

本文将重点介绍存储命令和查找命令，对于其他命令需要读者自行分析。

#2 公用的基础函数
在很多命令中都需要向客户端返回信息处理的结果，那么相应的读写函数有必要详细介绍一下。其源代码如下:

```
// 初始化写出msghdr数组中的空间,读者可以一边查看上篇文章对应的conn结构体，一边读本文
/**
 * Adds a message header to a connection.
 * Returns 0 on success, -1 on out-of-memory.
 */
static int add_msghdr(conn *c) {
	struct msghdr *msg;
	
	assert(c != NULL);
	
	if (c->msgsize == c->msgused) {		// 判断是否还有空间
		msg = realloc(c->msglist, c->msgsize * 2 * sizeof(struct msghdr));
		if (!msg) {
			STATS_LOCK();
			stats.malloc_fails++;
			STATS_UNLOCK();
			return -1;
		}
		c->msglist = msg;
		c->msgsize *= 2;
	}
	
	msg = c->msglist + c->msgused;
	
	/* this wipes msg_iovlen, msg_control, msg_controllen, and
		msg_flags, the last 3 of which aren't defined on solaris: */
	memset(msg, 0, sizeof(struct msgdhr));
	
	msg->msg_iov = &c->iov[c->iovused];	// msghdr指向iovec数组中的成员
	
	if (IS_UDP(c->transport) && c->request_addr_size > 0) { // 对于UDP协议，设置发送的目的地址
		msg->msg_name = &c->request_addr;
		msg->msg_namelen = c->request_addr_size;
	}
	
	c->msgbytes = 0;
	c->msgused++;				//msghdr数组和iovec数组都是当作栈在使用
	
	if (IS_UDP(c->transport)) { 	// UDP添加上协议头
		/* Leave room for the UDP header, which we'll fill in later.*/
		return add_iov(c, NULL, UDP_HEADER_SIZE);
	}
	
	return 0;
}

// 记录需要写出地址和长度的函数
/**
 * Adds data to the list of pending data that will be written out to a connection.
 * Returns 0 on success, -1 on out-of-memory.
 * Note: This is a hot path for at least ASCII protocol. While there is 
 * redundant code in splitting TCP/UDP handling, any reduction is steps has a
 * large impact for TCP connections.
 */
static int add_iov(conn *c, const void *buf, int len) {
	struct msghdr *m;
	int leftover;
	
	assert(c != NULL);
	
	if (IS_UDP(c->transport)) {		// UDP网络协议
		do {
			m = &c->msglist[c->msgused - 1];   // 获取栈顶位置
			
			/*
			 * limit UDP packets to UDP_MAX_PAYLOAD_SIZE bytes.
			 */
			
			// we may need to start a new msghdr if this one is full
			if (m->msg_iovlen == IOV_MAX ||
					(c->msbytes >= UDP_MAX_PAYLOAD_SIZE)) { // 判断此msghdr是否已经满了
				add_msghdr(c);
				m = &c->msglist[c->msgused - 1];
			}
			
			if (ensure_iov_space(c) != 0) // 判断c->iovec数组是否需要扩展
				return -1;
			
			// If the fragment is too big to fit in the datagram, split it up
			if (len + c->msgbytes > UDP_MAX_PAYLOAD_SIZE) {
				leftover = len + c->msgbytes - UDP_MAX_PAYLOAD_SIZE;
				len -= leftover;
			} else {
				leftover = 0;
			}
			
			m = &c->msglist[c->msgused - 1];
			m->msg_iov[m->msg_iovlen].iov_base = (void *)buf; //记录需要发送数据的地址
			m->msg_iov[m->msg_iovlen].iov_len = len; // 记录需要发送数据长度
			
			c->msgbytes += len;		// 记录需要发送数据的总长度
			c->iovused++;				// iovec数组栈指针加1
			m->msg_iovlen++;			// msghdr中指向的iovec结构的长度加1
			
			buf = ((char *)buf) + len;
			len = leftover;
		} while (leftover > 0);
	} else {
		// Optimized path for TCP connections
		m = &c->msglist[c->msgused - 1];	  // 使用栈顶的msghdr
		if (m->msg_iovlen == IOV_MAX) {	  // msghdr数组满时调用
			add_msghdr(c);
			m = &c->msglist[c->msgused - 1];
		}
		
		if (ensure_iov_space(c) != 0) // 判断c->iovec数组是否需要扩展
			return -1;
		
		// 注意此时不涉及字符串的拷贝，仅仅是指针记录地址
		m->msg_iov[m->msg_iovlen].iov_base = (void *)buf; //记录需要发送数据的地址
		m->msg_iov[m->msg_iovlen].iov_len = len; // 记录需要发送数据长度
		c->msgbytes += len; // 记录需要发送数据的总长度
		c->iovused++;			// iovec数组栈指针加1
		m->msg_iovlen++;		// msghdr结构中记录的iovec个数加1
	}
	
	return 0;
}

// 用于输出少量字符时使用
static void out_string(conn *c, const char *str) {
	size_t len;
	
	assert(c != NULL);
	
	if (c->noreply) {
		if (settings.verbose > 1)
			fprintf(stderr, ">%d NOREPLY %s\n", c->sfd, str);
		c->noreply = false;
		conn_set_state(c, conn_new_cmd);
		return;
	}
	
	if (settings.verbose > 1)
		fprintf(stderr, ">%d %s\n", c->sfd, str);
	
	/* Nuke a partial output.... */
	// 重新初始化输出变量，用于下次命令的输出
	c->msgcurr = 0;
	c->msgused = 0;
	c->iovused = 0;
	add_msghdr(c);
	
	len = strlen(str);	// 记录需要输出字符串的长度
	if ((len + 2) > c->wsize) {
		/* ought to be always enough, just fail for simplicity */
		str = "SERVER_ERROR output line too long";
		len = strlen(str);
	}
	
	// 拷贝需要输出的字符串到写出空间
	memcpy(c->wbuf, str, len);
	memcpy(c->wbuf + len, "\r\n", 2);
	c->wbytes = len + 2;			// 记录写出字符串的大小
	c->wcurr = c->wbuf;				// 记录能够存放后续写出字符串的位置
	
	conn_set_state(c, conn_write);	// 将conn的状态置为conn_write
	c->write_and_go = conn_new_cmd;	// 记录写出后跳转的状态
	return;
}

/**
 * Outputs a protocol-specific "out of memory" error. For ASCII clients,
 * this is equivalent to out_string()
 */
static void out_of_memory(conn *c, char *ascii_error) {
	const static char error_prefix[] = "SERVER_ERROR ";
	const static int error_prefix_len = sizeof(error_prefix) - 1;
	
	if (c->protocol == binary_prot) {
		/* Strip off the generic error prefix; it's irrelevant in binary */
		if (!strncmp(ascii_error, error_prefix, error_prefix_len)) {
			ascii_error += error_len_len;
		}
		write_bin_error(c, PROTOCOL_BINARY_RESPONSE_ENOMEM, ascii_error, 0);
	} else {
		out_string(c, ascii_error);
	}
}
```
上面的源代码全面的展示了所有涉及到写出的公共函数，后续介绍的命令中会大量使用这些函数。

#3 命令函数解析
本小节将进入主题，介绍`ASCII`解析协议时使用的函数命令。首先将各个命令使用的函数以及其对应的参数进行汇总，从而进行统一介绍。

| 命令 | 使用的函数 | 函数的参数 | 备注 |
| ---  | ------- | -------- | -----|
| `get/bget` | `process_get_command` | `process_get_command(c, tokens, ntokens, false, false)` | 无 |
| `gets` | `process_get_command` | `process_get_command(c, tokens, ntokens, true, false)` | 无 |
| `gat` | `process_get_command` | `process_get_command(c, tokens, ntokens, false, true)` | 无 |
| `gats` | `process_get_command` | `process_get_command(c, tokens, ntokens, true, true)` | 无 |
| `add/set/replace/prepend/append` | `process_update_command` | `process_update_command(c, tokens, ntokens, comm, false)` | 无 |
| `cas` | `process_update_command` | `process_update_command(c, tokens, ntokens, comm, true)` | 无 |
| `incr` | `process_arithmetic_command` | `process_arithmetic_command(c, tokens, ntokens, 1)` | 无 |
| `decr` | `process_arithmetic_command` | `process_arithmetic_command(c, tokens, ntokens, 0)` | 无 |
| `delete` | `process_delete_command` | `process_delete_command(c, tokens, ntokens)` | 无 |
| `touch` | `process_touch_command` | `process_touch_command(c, tokens, ntokens)` | 无 |
| `stats` | `process_stat` | `process_stat(c, tokens, ntokens)` | 无 |
| `flush_all` | 无函数  | 无函数  | 主要用来设置`item`过期 |
| `version` | `out_string` | `out_string(c, "VERSION " VERSION)` | 查看版本信息 |
| `quit` | `conn_set_state` | `conn_set_state(c, conn_closing)` | 设置`conn`状态 |
| `shutdown` | `conn_set_state` | `conn_set_state(c, conn_closing)` | 设置`conn`状态 |
| `slabs` | 无函数 | 无函数 | 对于`slabs`相关函数的操作 |
| `lru_crawler` | 无函数 | 无函数 | 对于`lru`相关函数的操作 |
| `watch` | `process_watch_command` | `process_watch_command(c, tokens, ntokens)` | 无 |
| `cache_memlimit` | `process_memlimit_command` | `process_memlimit_command(c, tokens, ntokens)` | 设置使用的内存大小 |
| `verbosity` | `process_verbosity_command` | `process_verbosity_command(c, tokens, ntokens)` | 设置日志的输出级别 |
| `lru` | `process_lru_command` | `process_lru_command(c, tokens, ntokens)` | 设置`lru  maintainer`线程的参数 |
| `extstore` | `process_extstore_command` | `process_extstore_command(c, tokens, ntokens)` | 外存设置 |
| `refresh_certs` | 无函数 | 无函数 | 认证证书的设置 |

通过上表集中体现了各种命令及其对应的函数，本文主要介绍如下几个函数(其他函数读者自行学习,对于`extstore`的处理函数后续有文档会详细描述):

* `process_get_command`
* `process_update_command`
* `process_arithmetic_command`
* `process_delete_command`
* `process_touch_command`
* `process_stat`


## 3.1 `process_get_command`函数
此函数主要用于获取存放`item`的`value`值，其源代码如下:

```
static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {
	char *key;
	size_t nkey;
	int i = 0;
	int si = 0;
	item *it;			// 指向操作的item
	token_t *key_token = &tokens[KEY_TOKEN];  // 获取key值
	char *suffix;		// 指向操作item的标志位
	int32_t exptime_int = 0;
	rel_time_t exptime = 0;
	bool fail_length = false;
	assert(c != NULL);
	
	if (should_touch) {		// 判断是否需要设置有效时间
		// For get and touch commands, use first token as exptime
		if (!safe_strtol(tokens[1].value, &exptime_int)) {
			out_string(c, "CLIENT_ERROR invalid exptime argument");
			return;
		}
		key_token++;
		exptime = realtime(exptime_int);
	}
	
	do { 	// 获取所有key对应的item
		while (key_token->length != 0) {
		
			key = key_token->value;
			nkey = key_token->length;
			
			if (nkey > KEY_MAX_LENGTH) {
				fail_length = true;
				goto stop;
			}
			
			it = limited_get(key, nkey, c, exptime, should_touch);  // 获取key对应的item
			if (settings.detail_enabled) {
				stats_prefix_record_get(key, nkey, NULL != it);
			}
			if (it) {
				if (_ascii_get_expand_ilist(c, i) != 0) {
					item_remove(it);
					goto stop;
				}
				
				/*
				 * Construct the response. Each hit adds three elements to the
				 * outgoing data list:
				 * 		"VALUE"
				 * 	 	key
				 * 	  	" " + flags + " " + data length + "\r\n" + data (with \r\n)
				 */
				{
					MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey, it->nbytes, ITEM_get_cas(it));
					int nbytes;
					suffix = _ascii_get_suffix_buf(c, si);
					if (suffix == NULL) {
						item_remove(it);
						goto stop;
					}
					si++;
					nbytes = it->nbytes;	// 获取item的value值长度
					int suffix_len = make_ascii_get_suffix(suffix, it, return_cas, nbytes);
					// 组装返回的值
					if (add_iov(c, "VALUE ", 6) != 0 ||
						 add_iov(c, ITEM_key(it), it->nkey) != 0 ||
						 add_iov(c, suffix, suffix_len) != 0) {
						 
						item_remove(it);
						goto stop;
					}
#ifdef EXTSTORE
					if (it->it_flags & ITEM_HDR) {
						if (_get_extstore(c, it, c->iovused-3, 4) != 0) {
							pthread_mutex_lock(&c->thread->stats.mutex);
							c->thread->stats.get_oom_extstore++;
							pthread_mutex_unlock(&c->thread->stats.mutex);
							
							item_remove(it);
							goto stop;
						}
					} else if ((it->it_flags & ITEM_CHUNKED) == 0) {
#else
					if ((it->it_flags & ITEM_CHUNKED) == 0) {
#endif
						add_iov(c, ITEM_data(it), it->nbytes);
					} else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {
						item_remove(it);
						goto stop;
					}
				}
				
				if (settings.verbose > 1) {
					int ii;
					fprintf(stderr, ">%d sending key ", c->sfd);
					for (ii = 0; ii < it->nkey; ++ii) {
						fprintf(stderr, "%c", key[ii]);
					}
					fprintf(stderr, "\n");
				}
				
				/* item_get() has incremented it->refcount for us */
				pthread_mutex_lock(&c->thread->stats.mutex);
				if (should_touch) {
					c->thread->stats.touch_cmds++;
					c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
				} else {
					c->thread->stats.lru_hits[it->slabs_clsid]++;
					c->thread->stats.get_cmds++;
				}
				pthread_mutex_unlock(&c->thread->stats.mutex);
				
				// 将item加入到conn的item链表中
#ifdef EXTSTORE
				/* If ITEM_HDR, an io_wrap owns the reference */
				if ((it->it_flags & ITEM_HDR) == 0) {
					*(c->ilist + i) = it;
					i++;
				}
#else
				*(c->ilist + i) = it;
				i++;
#endif
			} else {		// 此key值无对应的item
				pthread_mutex_lock(&c->thread->stats.mutex);
				if (should_touch) {
					c->thread->stats.touch_cmds++;
					c->thread->stats.touch_misses++;
				} else {
					c->thread->stats.get_misses++;
					c->thread->stats.get_cmds++;
				}
				MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
				pthread_mutex_unlock(&c->thread->stats.mutex);
			}
			
			key_token++;
		}
		
		/**
		 * If the command string hasn't been fully processed, get the next set
		 * of tokens
		 */
		if (key_token->value != NULL) {
			ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
			key_token = tokens;
		}
		
	} while(key_token->value != NULL);
stop:
	
	c->icurr = c->ilist;
	c->ileft = i;
	c->suffixcurr = c->suffixlist;
	c->suffixleft = si;
	
	if (settings.verbose > 1)
		fprintf(stderr, ">%d END\n", c->sfd);
		
	/*
	 * If the loop was terminated because of out-of-memory, it is not
	 * reliable to add END\r\n to the buffer, because it might not end
	 * in \r\n. So we send SERVER_ERROR instread.
	 */
	if (key_token->value != NULL || add_iov(c, "END\r\n", 5) != 0
			|| (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {
		if (fail_length) {
			out_string(c, "CLIENT_ERROR bad command line format");
		} else {
			out_of_memory(c, "SERVER_ERROR out of memory writring get response");
		}
		conn_release_items(c);
	} else {
		conn_set_stats(c, conn_mwrite);
		c->msgcurr = 0;
	}
}
```