网络子线程命令解析
==================================
前面介绍了4种`conn`的状态，其中`conn_parse_cmd`状态用来解析客户端发送过来的命令(`process_command`函数)。本文将详细介绍此函数，并根据`process_command`函数设置`conn`状态来介绍剩下的`conn`状态的处理过程。

#1. `process_command`函数体
首先来查看`process_command`的源代码，从而进一步介绍`memcached`种常用的几个命令，例如`get/gets/add/set/replace/delete`等操作。

```
static void process_command(conn *c, char *command) {
	
	token_t tokens[MAX_TOKENS];		// 命令以及其参数
	size_t ntokens;						// 解析出来参数的个数
	int comm;
	
	assert(c != NULL);
	
	MEMCACHED_PROCESS_COMMAND_START(c->sfd, c->rcurr, c->rbytes);
	
	if (settings.verbose > 1)
		fprintf(stderr, "<%d %s\n", c->sfd, command);
		
	/**
	 * for commands set/add/replace, we build an item and read the data
	 * directly into it, then continue in nread_complete().
	 */
	
	// 初始化需要发送的数组
	c->msgcurr = 0;	
	c->msgused = 0;
	c->iovused = 0;
	if (add_msg(c) != 0) {		// 如果是UDP网络协议，空余出发送数据头
		out_of_memory(c, "SERVER_ERROR out of memory preparing response");
		return;
	}
	
	ntokens = tokenize_command(command, tokens, MAX_TOKENS);  // 从接受字节中解析命令
	if (ntokens >= 3 &&
			((strcmp(tokens[COMMAND_TOKEN].value, "get") == 0) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "bget") == 0))) { // get命令
		
		process_get_command(c, tokens, ntokens, false, false);
		
	} else if ((ntokens == 6 || ntokens == 7) &&
			((strcmp(tokens[COMMAND_TOKEN].value, "add") == 0 && (comm = NREAD_ADD)) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "set") == 0 && (comm = NREAD_SET)) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "replace") == 0 && (comm = NREAD_REPLACE)) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "prepend") == 0 && (comm = NREAD_PREPEND)) ||
			 (strcmp(tokens[COMMAND_TOKEN].value, "append") == 0 && (comm = NREAD_APPEND)) )) {
		// 注意这里comm是设置操作
		process_update_command(c, tokens, ntokens, comm, false);
	
	} else if ((ntokens == 7 || ntokens == 8) && (strcmp(tokens[COMMAND_TOKEN].value, "cas") == 0 && (comm = NREAD_CAS))) {
		// 注意这里comm是设置操作
		process_update_command(c, tokens, ntokens, comm, ture);
	
	} else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "incr") == 0)) {
		
		process_arithmetic_command(c, tokens, ntokens, 1);
		
	} else if ((ntokens >= 3 && (strcmp(tokens[COMMAND_TOKEN].value, "gets") == 0)) {
	
		process_get_command(c, tokens, ntokens, true, false);
	
	} else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "decr") == 0)) {
	
		process_arithmetic_command(c, tokens, ntokens, 0);
	
	} else if (ntokens >= 3 && ntokens <= 5 && (strcmp(tokens[COMMAND_TOKEN].value, "delete") == 0)) {
	
		process_delete_command(c, tokens, ntokens, 0);
		
	} else if ((ntokens == 4 || ntokens == 5) && (strcmp(tokens[COMMAND_TOKEN].value, "touch") == 0)) {
		
		process_touch_command(c, tokens, ntokens);
	 
	} else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gat") == 0) {
	
		process_get_command(c, tokens, ntokens, false, true);
	
	} else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "gats" == 0)) {
	
		process_get_command(c, tokens, ntokens, true, true);
	
	} else if (ntokens >= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "stats") == 0)) {
	
		process_stat(c, tokens, ntokens);
	
	} else if (ntokens >= 2 && ntokens <= 4 && (strcmp(tokens[COMMAND_TOKEN].value, "flush_all") == 0)) {
		// 删除所有item
		time_t exptime = 0;
		rel_time_t new_oldest = 0;
		
		set_noreply_maybe(c, tokens, ntokens); // 设置是否需要返回值
		
		pthread_mutex_lock(&c->thread->stats.mutex);
		c->thread->stats.flush_cmds++;
		pthread_mutex_unlock(&c->thread->stats.mutex);
		
		if (!setttings.flush_enabled) {
			// flush_all is not allowed but we log it an stats
			out_string(c, "CLIENT_ERROR flush_all not allowed"); // 输出字符串
			return;
		}
		
		if (ntokens != (c->noreply ? 3 : 2)) {
			exptime = strtol(tokens[1].value, NULL, 10); // 获取设置的超时时间
			if (errno == ERANGE) {
				out_string(c, "CLIENT_ERROR bad command line format");
				return;
			}
		}
		
		/**
		 * If exptime is zero realtime() would return zero too, and
		 * realtime(exptime) - 1 would overflow to the max unsigned
		 * value. So we process exptime == 0 the same way we do when
		 * no delay is given at all.
		 */
		if (exptime > 0) {
			new_oldest = realtime(exptime); // 设置最老item的时间
		} else { // exptime == 0
			new_oldest = current_time;
		}
	
		if (settings.use_cas) {
			settings.oldest_live = new_oldest - 1;
			if (settings.oldest_live <= current_time)
				settings.oldest_cas = get_cas_id();
		} else {
			settings.oldest_live = new_oldest;
		}
		out_string(c, "OK");
		return;
		
	} else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "version") == 0)) {
		
		out_string(c, "VERSION " VERSION);
		
	} else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "quit") == 0)) {
	
		conn_set_state(c, conn_closing);
		
	} else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "shutdown") == 0)) {
	
		if (settings.shutdown_command) {
			conn_set_state(c, conn_closing);
			raise(SIGINT);
		} else {
			out_string(c, "ERROR: shutdown not enabled");
		}
	
	} else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "slabs") == 0) {
		// 对于slab管理的操作
		if (ntokens == 5 && strcmp(tokens[COMMAND_TOKEN + 1].value, "reassign") == 0) {
			// 调用slab reassign操作
			int src, dst, rv;
			
			if (settings.slab_reassign == false) {
				out_string(c, "CLIENT_ERROR slab reassignment disabled");
				return;
			}
			
			src = strtol(tokens[2].value, NULL, 10);
			dst = strtol(tokens[3].value, NULL, 10);
			
			if (errno == ERANGE) {
				out_string(c, "CLIENT_ERROR bad command line format");
				return;
			}
			
			rv = slabs_reassign(src, dst);
			switch (rv) {
			case REASSIGN_OK:
				out_string(c, "OK");
				break;
			case REASSIGN_RUNNING:
				out_string(c, "BUSY currently processing reassign request");
				break;
			case REASSIGN_BADCLASS:
				out_string(c, "BADCLASS invalid src or dst class id");
				break;
			case REASSIGN_NOSPARE:
				out_string(c, "NOSPARE source class has no spare pages");
				break;
			case REASSIGN_SRC_DST_SAME:
				out_string(c, "SAME src and dst class are identical");
				break;
			}
			return;
		
		} else if (ntokens >= 4 && 
				(strcmp(tokens[COMMAND_TOKEN + 1].value, "automove") == 0)) {
			process_slabs_automove_command(c, tokens, ntokens); // 设置automove的参数
		} else {
			out_string(c, "ERROR");
		}
	
	} else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "lru_crawler") == 0) {
		// 对lru_crawler线程的设置
		if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "crawl") == 0) {
			int rv;
			if (settings.lru_crawler == false) {
				out_string(c, "CLIENT_ERROR lru crawler disabled");
				return;
			}
			
			rv = lru_crawler_crawl(tokens[2].value, CRAWLER_EXPIRED, NULL, 0, settings.lru_crawler_tocrawl); // 开启扫描某一个slab链表
			switch (rv) {
			case CRAWLER_OK:
				out_string(c, "OK");
				break;
			case CRAWLER_RUNNING:
				out_string(c, "BUSY currently processing crawler request");
				break;
			case CRAWLER_BADCLASS:
				out_string(c, "BADCLASS invalid class id");
				break;
			case CRAWLER_NOTSTARTED:
				out_string(c, "NOTSTRTED no items to crawl");
				break;
			case CRAWLER_ERROR:
				out_string(c, "ERROR on unknown error happened");
				break;
			}
			return;
		} else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "metadump") == 0) {
			if (settings.lru_crawler == false) {
				out_string(c, "CLIENT_ERROR lru crawler disabled");
				return;
			}
			if (!settings.dump_enabled) {
				out_string(c, "ERROR metadump not allowed");
				return;
			}
			
			int rv = lru_crawler_crawl(tokens[2].value, CRAWLER_METADUMP, c, c->sfd, LRU_CRAWLER_CAP_REMAINING);
			switch(rv) {
			case CRAWLER_OK:
				out_string(c, "OK");
				conn_set_state(c, conn_watch);
				event_del(&c->event);		// 先将conn从Reactor管理器中去除掉
				break;
			case CRAWLER_RUNNING:
				out_string(c, "BUSY currently processing crawler request");
				break;
			case CRAWLER_BADCLASS:
				out_string(c, "BADCLASS invalid class id");
				break;
			case CRAWLER_NOTSTARTED:
				out_string(c, "NOTSTARTED no items to crawl");
				break;
			case CRAWLER_ERROR:
				out_string(c, "ERROR an unknown error happended");
				break;
			}
			return;
		} else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "tocrawl") == 0) {
			uint32_t tocrawl;
			if (!safe_strtoul(tokens[2].value, &tocrawl)) {
				out_string(c, "CLIENT_ERROR bad command line format");
				return;
			}
			settings.lru_crawler_tocrawl = tocrawl;
			out_string(c, "OK");
			return;
		} else if (ntokens == 4 && strcmp(tokens[COMMAND_TOKEN + 1].value, "sleep") == 0) {
			uint32_t tosleep;
			if (!safe_strtoul(tokens[2].value, &tosleep)) {
				out_string(c, "CLIENT_ERROR bad command line format");
				return;
			}
			if (tosleep > 1000000) {
				out_string(c, "CLIENT_ERROR sleep must be one second or less");
				return;
			}
			settings.lru_crawler_sleep = tosleep;
			out_string(c, "OK");
			return;
		} else if (ntokens == 2) {
			if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "enable") == 0)) {
				if (start_item_crawler_thread() == 0) {
					out_string(c, "OK");
				} else {
					out_string(c, "ERROR failed to start lru crawler thread");
				}
			} else if ((strcmp(tokens[COMMAND_TOKEN + 1].value, "disable") == 0)) {
				if (stop_item_crawler_thread() == 0) {
					out_string(c, "OK");
				} else {
					out_string(c, "ERROR failed to stop lru crawler thread");
				}
			} else {
				out_string(c, "ERROR");
			}
			return;
		} else {
			out_string(c, "ERROR");
		}
	
	} else if (ntokens > 1 && strcmp(tokens[COMMAND_TOKEN].value, "watch") == 0) {
		process_watch_command(c, tokens, ntokens);
		
	} else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "cache_memlimit") == 0)) {
		process_memlimit_command(c, tokens, ntokens);
		
	} else if ((ntokens == 3 || ntokens == 4) && (strcmp(tokens[COMMAND_TOKEN].value, "verbosity") == 0)) {
		process_verbosity_command(c, tokens, ntokens);
		
	} else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "lru") == 0) {
#ifdef MEMCACHED_DEBUG
	// commands which exist only for testing the memcached's security protection
	} else if (ntokens == 2 && (strcmp(tokens[COMMAND_TOKEN].value, "misbehave") == 0)) {
		process_misbehave_command(c);
#endif
#ifdef EXTSTORE
	} else if (ntokens >= 3 && strcmp(tokens[COMMAND_TOKEN].value, "extstore") == 0) {
		process_extstore_command(c, tokens, ntokens);
#endif
#ifdef TLS
	} else if (ntokens == 2 && strcmp(tokens[COMMAND_TOKEN].value, "refresh_certs") == 0) {
		set_noreply_maybe(c, tokens, ntokens);
		char *errmsg = NULL;
		if (refresh_certs(&errmsg)) {
			out_string(c, "OK");
		} else {
			write_and_free(c, errmsg, strlen(errmsg));
		}
		return;
#endif
	} else {
		if (ntokens >= 2 && strcmp(tokens[ntokens - 2].value, "HTTP/", 5) == 0) {
			conn_set_state(c, conn_closing);
		} else {
			out_string(c, "ERROR");
		}
	}
	return;
}
```
