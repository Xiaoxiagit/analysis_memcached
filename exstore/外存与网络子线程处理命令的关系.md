外存与网络子线程处理命令之间的关系
===================================
通过面前的几篇文章已经全面的阐述外存的相关知识，但外存终将是要为网络子线程处理命令提供服务。对于往外存写，在外存相关部分的知识已经进行了详细的说明。本文将把网络子线程处理命令的流程与外存部分进行关联，详细说明网络子线程处理命令时对外存部分的调用。

## 1. 外存存储`item`的生存周期
从外存的相关文档可知，`item`是外存写入线程从`LRU`链表的尾部挑选符合写出条件的`item`写入到外存页面中。外存页面`page`中存活的`item`将通过外存紧缩线程进行转移处理，然而对于删除的或者过期的`item`将通过释放相应的外存`page`页面也随之释放。一旦`item`进入外存中，暂时没有相应的流程能够让`item`重新回到内存中。

## 2. 网络子线程的相关命令
下面列出网络子线程需要处理的命令，并备注其是否与外存相关。

| 命令 | 使用的函数 | 是否与外存相关 |
| ---  | ------- | -------- | -----|
| `get/bget/gets/gat/gats` | `process_get_command` | 相关 |
| `add/set/replace/prepend/append/cas` | `process_update_command` | 相关 |
| `incr/decr` | `process_arithmetic_command` | 相关 |
| `delete` | `process_delete_command` | 相关 |
| `touch` | `process_touch_command` | 相关 |
| `stats` | `process_stat` | 相关 |
| `extstore` | `process_extstore_command` | 相关 |

对于上述命令中，对于使用`process_get_command`函数的命令需要特别的介绍。而其他的命令操作主要是调用了外存定义的宏函数`STORAGE_delete`来实现对外存的控制。

### 2.1 `STORAGE_delete`宏函数
其定义如下：

```
#ifdef EXTSTORE
#define STORAGE_delete(e, it) \
	do {	\
		if (it->it_flags & ITEM_HDR) {  \
			item_hdr *hdr = (item_hdr *)Item_data(it); \
			extstore_delete(e, hdr->page_id, hdr->page_version, \
					1, ITEM_ntotal(it)); \
		} \
	} while (0)
#else
#define STORAGE_delete(...)
#endif

/* engine note delete function: takes engine, page id, size ?
 * note that an item in this page is no longer valid. */
int extstore_delete(void *ptr, unsigned int page_id, uint64_t page_version, unsigned int count, unsigned int bytes) {
	store_engine *e = (store_engine *)ptr;
	// FIXME: validate page_id in bounds
	store_page *p = &e->pages[page_id];	 // 获取对应外存的页面信息
	int ret = 0;
	
	pthread_mutex_lock(&p->mutex);
	if (!p->closed && p->version == page_version) { // 判断当前页面是否合法
		if (p->bytes_used >= bytes) {		// 减少页面的使用字节数
			p->bytes_used -= bytes;
		} else {
			p->bytes_used = 0;
		}
		
		if (p->obj_count >= count) {     // 减少页面中存储item的个数
			p->obj_count -= count;
		} else {
			p->obj_count = 0;  // caller has bad accounting?
		}
		STAT_L(e);
		e->stats.bytes_used -= bytes;
		e->stats.objects_used -= count;
		STAT_UL(e);
		
		if (p->obj_count == 0) {         // 当外存页面没有存储item时可以考虑释放此页面
			extstore_run_maint(e);
		}
	} else {
		ret = -1;
	}
	pthread_mutex_unlock(&p->mutex);
	return ret;
}
```
通过上面的代码描述可以很清楚的看出，调用`STORAGE_delete`宏函数时，其仅仅改变外存页面中使用字节数和存储`item`的个数，不进行真正的删除操作。对于存储有了解的同学都应该知道，对于存储介质中失效或者过期的存储内容基本都是在外存紧缩过程中完成删除操作。

### 2.2 `process_update_command`命令处理函数
此函数是用来更新`item`的内容，其需要将内存中或者外存中的`item`删除掉，仅用申请一个新的空间来存放发送过来的内容，并替换掉原来空间的内容。其与外存相关的代码如下:

```
static void process_update_command(conn *c, token_t *tokens, const size_t ntokens, int comm, bool handle_cas) {
	....
	// 申请新的空间
	it = item_alloc(key, nkey, flags, realtime(exptime), vlen);
	
	if (it == 0) {
		enum store_item_type status;
		if (! item_size_ok(nkey, flags, vlen)) {
			out_string(c, "SERVER_ERROR object too large for cache");
			status = TOO_LARGE;
		} else {
			out_of_memory(c, "SERVER_ERROR out of meory storing object");
			status = NO_MEMORY;
		}
		// 丢弃发送过来的数据
		c->write_and_go = conn_swallow;
		c->sbytes = vlen;
		
		// 尝试释放内存空间的内容
		if (comm == NREAD_SET) {
			it = item_get(key, nkey, c, DONT_UPDATE);
			if (it) {
				item_unlink(it);
				STORAGE_delete(c->thread->storage, it);   // 释放在外存的存储信息
				item_remove(it);
			}
		}
		
		return;
	}
	
	....
}
```

### 2.3 `process_arithmetic_command`命令处理函数
此命令用于增加或者减少`item`的值，当`item`存放在外存时则需要进行相应的外存信息处理。其相关代码如下:

```
static void process_arithmeitc_command(conn *c, token_t *tokens, const size_t ntokens, const bool incr) {
	....
	// 其调用add_delta函数来实现对外存的处理
	switch (add_delta(c, key, nkey, incr, delta, tmp, NULL)) {
		....
	}
}

enum delta_result_type add_delta(conn *c, const char *key, const size_t nkey,
											bool incr, const int64_t delta, 
											char *buf, uint64_t *cas) {
	....
	// 调用do_add_delta函数进行处理
	ret = do_add_delta(c, key, nkey, incr, delta, buf, cas, hv);
	....
	return ret;
}

enum delta_result_type do_add_delta(conn *c, const char *key, const size_t nkey,
											const bool incr, const int64_t delta,
											char *buf, uint64_t *cas, const uint32_t hv) {
	....
#ifdef EXTSTORE
	if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED|ITEM_HDR)) != 0) {
#else
	if (it->nbytes <= 2 || (it->it_flags & (ITEM_CHUNKED)) != 0) {
#endif
		do_item_remove(it);
		return NON_NUMERIC;
	}
	....
}
```

### 2.4 `process_delete_command`命令处理函数
此命令用于删除`item`的相关信息，其相关代码如下:

```
static void process_delete_command(conn *c, token_t *tokens, const size_t ntokens) {
	....
	// 锁定item，并做后续处理
	it = item_get_locked(key, nkey, c, DONT_UPDATE, &hv);
	if (it) {
		....
		// 删除相应的item
		do_item_unlink(it, hv);
		STORAGE_delete(c->thread->storage, it);   // 删除外存的信息
		do_item_remove(it);
		....
	} else {
		....
	}
	item_unlock(hv);
}
```
### 2.5 `process_touch_command`命令处理函数
此命令用于更新`item`的访问时间，从而改变`item`在`LRU`链表中的位置。其相关代码如下:

```
static void process_touch_command(conn *c, token_t *tokens, const size_t ntokens) {
	....
	// 调用item_touch函数，关联到外存
	it = item_touch(key, nkey, realtime(exptime_int), c);
	....
}

item *item_touch(const char *key, size_t nkey, uint32_t exptime, conn *c) {
	....
	it = do_item_touch(key, nkey, exptime, hv, c);
	....
	return it;
}

item *do_item_touch(const char *key, size_t nkey, uint32_t exptime, const uint32_t hv, conn *c) {
	item *it = do_item_get(key, nkey, hv, c, DO_UPDATE);
	....
}

item *do_item_alloc(const char *key, const size_t nkey, const uint32_t hv, conn *c, const bool do_update) {
	....
	// 判断item是否过期，则进行处理
	if (it != NULL) {
		was_found = 1;
		if (item_is_flushed(it)) {
			// 判断item是否被强制清除
			do_item_unlink(it, hv);
			STORAGE_delete(c->thread->storage, it);
			do_item_remove(it);
			....
		} else if (it->exptime != 0 && it->exptime <= current_time) {
			// 判断item是否过期
			do_item_unlink(it, hv);
			STORAGE_delete(c->thread->storage, it);
			do_item_remove(it);
			....
		} else {
			....
		}
	}
}
```

### 2.6 `process_stat`命令处理函数
此命令用于获取`memcached`的运行状态，此命令也会获取外存相关的运行状态。其源代码如下:

```
static void process_stat(conn *c, token_t *tokens, const size_t ntokens) {
	....
#ifdef EXTSTORE
	} else if (strcmp(subcommand, "extstore") == 0) {
		process_extstore_stats(&append_stats, c);
#endif
	....
	}
}

#ifdef EXTSTORE
static void process_extstore_stats(ADD_STAT add_stats, conn *c) {
	int i;
	char key_str[STAT_KEY_LEN];
	char val_str[STAT_VAL_LEN];
	int klen = 0, vlen = 0;
	struct extstore_stats st;
	
	assert(add_stats);
	
	void *storage = c->thread->storage;
	extstore_get_stats(storage, &st);   // 获取外存信息存储状态
	st.page_data = calloc(st.page_count, sizeof(struct extstore_page_data)); // 申请存储外存页面信息的空间
	extstore_get_page_data(storage, &st); // 获取外存page存储状态
	
	// 添加bucket信息
	for (i = 0; i < st.page_count; i++) {
		APPEND_NUM_STAT(i, "version", "%llu", (unsigned long long)st.page_data[i].version);
		APPEND_NUM_STAT(i, "bytes", "%llu", (unsigned long long)st.page_data[i].bytes_used);
		APPEND_NUM_STAT(i, "bucket", "%u", st.page_data[i].bucket);
		APPEND_NUM_STAT(i, "free_bucket", "%u", st.page_data[i].free_bucket);
	}
}
#endif
```

### 2.7 `process_extstore_command`命令处理函数
此命令用于改变外存相关线程执行时所使用的参数，从而改变外存的状态。其源代码如下:

```
#ifdef EXTSTORE
static void process_extstore_command(conn *c, token_t *tokens, const size_t ntokens) {
	set_noreply_maybe(c, tokens, ntokens);
	bool ok = true;
	if (ntokens < 4) {
		ok = false;
	} else if (strcmp(tokens[1].value, "free_memchunks") == 0 && ntokens > 4) {
		// per-slab-class free chunk setting
		unsigned int clsid = 0;
		unsigned int limit = 0;
		if (!safe_strtoul(tokens[2].value, &clsid) || 
				!safe_strtoul(tokens[3].value, &limit)) {
			ok = false;
		} else {
			if (clsid < MAX_NUMBER_OF_SLAB_CLASSES) {
				settings.ext_free_memchunks[clsid] = limit;
			} else {
				ok = false;
			}
		}
	} else if (strcmp(tokens[1].value, "item_size") == 0) {
		// 设置最小写出item的大小
		if (!safe_strtoul(tokens[2].value, &settings.ext_item_size))
			ok = false;
	} else if (strcmp(tokens[1].value, "item_age") == 0) {
		// 设置写出item的最小有效期
		if (!safe_strtoul(tokens[2].value, &settings.ext_item_age))
			ok = false;
	} else if (strcmp(tokens[1].value, "low_ttl") == 0) {
		// 设置放在low ttl bucket的最大有效期
		if (!safe_strtoul(tokens[2].value, &settings.ext_low_ttl))
			ok = false;
	} else if (strcmp(tokens[1].value, "recache_rate") == 0) {
		// cache使用率
		if (!safe_strtoul(tokens[2].value, &settings.ext_recache_rate))
			ok = false;
	} else if (strcmp(tokens[1].value, "compact_under") == 0) {
		// 设置紧缩的最低水平线
		if (!safe_strtoul(tokens[2].value, &settings.ext_compact_under))
			ok = false;
	} else if (strcmp(tokens[1].value, "drop_under") == 0) {
		// 设置丢弃水平线
		if (!safe_strtoul(tokens[2].value, &settings.ext_drop_under))
			ok = false;
	} else if (strcmp(tokens[1].value, "max_frag") == 0) {
		if (!safe_strtoul(tokens[2].value, &settings.ext_max_frag))
			ok = false;
	} else if (strcmp(tokens[1].value, "drop_unread") == 0) {
		unsigned int v;
		if (!safe_strtoul(tokens[2].value, &v)) {
			ok = false;
		} else {
			settings.ext_drop_unread = v == 0 ? false : true;
		}
	} else {
		ok = false;
	}
	if (!ok) {
		out_string(c, "ERROR");
	} else {
		out_string(c, "OK");
	}
}
#endif
```

## 3. 网络子线程读取外存`item`的过程
如果网络子线程访问的`item`的实际值存放在外存中，则网络子线程需要提交外存读取`IO`命令，然后等待`IO`命令执行完毕后，通过回调函数重新将`conn`的状态置为`conn_mwrite`状态，继续写出访问的`item`的`value`值。其具体代码如下:

### 3.1 访问`item`的命令处理过程
当网络子线程处理网络访问`item`命令时，调用`process_get_command`函数来处理对应的网络命令。其代码如下:

```
static inline void process_get_command(conn *c, token_t *tokens, size_t ntokens, bool return_cas, bool should_touch) {
	char 		*key;
	size_t 	nkey;
	int			i = 0;
	int 		si = 0;
	item		*it;
	token_t 	*key_token = &tokens[KEY_TOKEN];
	char		*suffix;
	int32_t	exptime_int = 0;
	rel_time_t exptime = 0;
	bool		fail_length = false;
	assert(c != NULL);
	
	// 判断是否需要修改item访问时间
	if (should_touch) {
		// For get and touch commands, use first token as exptime
		if (!safe_strtol(tokens[1].value, &exptime_int)) {
			out_string(c, "CLIENT_ERROR invalid exptime argument");
			return;
		}
		key_token++;
		exptime = realtime(exptime_int);
	}
	
	// 依次获取需要访问的item的value值
	do {
		// 判断key_token的所有key
		while (key_token->length != 0) {
			key = key_token->value;			// 获取key值
			nkey = key_token->length;		// 获取key值得长度
			// 判断key值长度是否超过最长长度
			if (nkey > KEY_MAX_LENGTH) {
				fail_length = true;
				goto stop;
			}
			
			// 获取内存中的item
			it = limited_get(key, nkey, c, exptime, should_touch);
			if (settings.detail_enabled) {
				stats_prefix_record_get(key, nkey, NULL != it);
			}
			// 判断item是否存在
			if (it) {
				// 扩展conn的ilist数据长度
				if (_ascii_get_expand_ilist(c, i) != 0) {
					item_remove(it);
					goto stop;
				}
				
				/*
				 * Construct the response. Each hit adds three elements to the
				 * outgoing data list:
				 * 		"VALUE "
				 * 	 key
				 * 	 " " + flags + " " + data length + "\r\n" + data (with \r\n)
				 */
				{
					MEMCACHED_COMMAND_GET(c->sfd, ITEM_key(it), it->nkey, it->nbytes, ITEM_get_cas(it));
					int nbytes;
					suffix = _ascii_get_suffix_buf(c, si); // 获取suffix存储空间
					if (suffix == NULL) {
						item_remove(it);
						goto stop;
					}
					si++;		// 成功读取item个数
					nbytes = it->nbytes;	// item的值长度
					int suffix_len = make_ascii_get_suffix(suffix, it, return_cas, nbytes); // 获取suffix字段长度
					// 开始将item的信息写入到iov数组中
					if (add_iov(c, "VALUE", 6) != 0 ||
							add_iov(c, ITEM_key(it), it->nkey) != 0 ||
							add_iov(c, suffix, suffix_len) != 0) {
						item_remove(it);
						goto stop;
					}
					// 判断item真正值是否在外存中存储
#ifdef EXTSTORE
					if (it->it_flags & ITEM_HDR) {
						// 处理外存中的item信息
						if (_get_extstore(c, it, c->iovused-3, 4) != 0) {
							pthread_mutex_lock(&c->thread->stats.mutex);
							c->thread->stats.get_oom_extstore++;
							pthread_mutex_unlock(&c->thread->stats.mutex);
							
							item_remove(it);
							goto stop;
						}
					} else if ((it->it_flags & ITEM_CHUNKED) == 0) {
#else
					if ((it->it_flags & ITEM_CHUNKED) == 0) {
#endif
						add_iov(c, ITEM_data(it), it->nbytes);
					} else if (add_chunked_item_iovs(c, it, it->nbytes) != 0) {
						item_remove(it);
						goto stop;
					}
				}
				
				// 输出信息
				if (settings.verbose > 1) {
					int ii;
					fprintf(stderr, ">%d sending key ", c->sfd);
					for (ii = 0; ii < it->nkey; ++ii) {
						fprintf(stderr, "%c", key[ii]);
					}
					fprintf(stderr, "\n");
				}
				
				// 统计访问信息
				// item_get() has incremented it->refcount for us
				pthread_mutex_lock(&c->thread->stats.mutex);
				if (should_touch) {
					c->thread->stats.touch_cmds++;
					c->thread->stats.slab_stats[ITEM_clsid(it)].touch_hits++;
				} else {
					c->thread->stats.lru_hits[it->slabs_clsid]++;
					c->thread->stats.get_cmds++;
				}
				pthread_mutex_unlock(&c->thread->stats.mtuex);
				// 记录访问的item
#ifdef EXTSTORE
				// If ITEM_HDR, an io_wrap owns the reference.
				if ((it->it_flags & ITEM_HDR) == 0) {
					*(c->ilist + i) = it;
					i++;
				}
#else
				*(c->ilist + i) = it;
				i++;
#endif
			} else {
				// 访问的item不存在
				pthread_mutex_lock(&c->thread->stats.mutex);
				if (should_touch) {
					c->thread->stats.touch_cmds++;
					c->thread->stats.touch_misses++;
				} else {
					c->thread->stats.get_misses++;
					c->thread->stats.get_cmds++;
				}
				MEMCACHED_COMMAND_GET(c->sfd, key, nkey, -1, 0);
				pthread_mutex_unlock(&c->thread->stats.mutex);
			}
			
			key_token++;		// 下一个key值
		}
		
		/*
		 * If the command string hasn't been fully processed. get the next set
		 * of tokens.
		 */
		if (key_token->value != NULL) {
			// 获取下一个key值
			ntokens = tokenize_command(key_token->value, tokens, MAX_TOKENS);
			key_token = tokens;
		}
		
	} while (key_token->value != NULL);
stop:
	
	c->icurr = c->ilist;
	c->ileft = i;
	c->suffixcurr = c->suffixlist;
	c->suffixleft = si;
	
	if (settings.verbose > 1)
		fprintf(stderr, ">%d END\n", c->sfd);
	
	/*
	 * If the loop was terminated because of out-of-memory, it is not
	 * reliable to add END\r\n to the buffer, because it might not end
	 * in \r\n. So we send SERVER_ERROR instead.
	 */
	if (key_token->value != NULL || add_iov(c, "END\r\n", 5) != 0
				|| (IS_UDP(c->transport) && build_udp_headers(c) != 0)) {
		if (fail_length) {
			out_string(c, "CLIENT_ERROR bad command line format");
		} else {
			out_of_memory(c, "SERVER_ERROR out of memory writing get response");
		}
		conn_release_items(c);
	} else {
		conn_set_state(c, conn_mwrite);
		c->msgcurr = 0;
	}
}
```
