外存管理
=================================
通过前文<<外存介绍文档>>可以知道，外存的相关信息主要存在于三个文件中`extstore.h/c`、`storage.h/c`和`slab_automove_extstore.h/c`。本文将详细介绍`extstore.h/c`文件中的内容，此文件中的内容主要涉及外存的管理的相关信息。

## 1. 主要数据结构
对于外存的管理的主要数据结构如下所示:

```
/* A safe-to-read dataset for determining compaction
 * id is the array index.
 */
// 用于page compaction的结构体
struct extstore_page_data {
	uint64_t version;
	uint64_t bytes_used;
	unsigned int bucket;
	unsigned int free_bucket;
};

/* Pages can have objects deleted from them at any time. This creates holes
 * that can't be reused until the page is either evicted or all objects are
 * deleted.
 * bytes_fragmented is the total bytes for all of these holes.
 * It is the size of all used pages minus each page's bytes_used value.
 */
struct extstore_stats {
	// 页面相关
	uint64_t page_allocs;
	uint64_t page_count;	// total page count
	uint64_t page_evictions;
	uint64_t page_reclaims;
	uint64_t page_size;		// size in bytes per page (supplied by caller)
	uint64_t pages_free;	// currently unallocated/unused pages
	uint64_t pages_used;
	// 存储的对象相关
	uint64_t objects_evicted;
	uint64_t objects_read;
	uint64_t objects_written;
	uint64_t objects_used;	// total number of objects stored
	// 外存字节使用情况
	uint64_t bytes_evicted;
	uint64_t bytes_written;
	uint64_t bytes_read;	// wbuf - read -> bytes read from storage
	uint64_t bytes_used;	// total number of bytes stored
	uint64_t bytes_fragmented;	// see above comment
	
	// 其他
	uint64_t io_queue;
	
	// 页面本身内容
	struct extstore_page_data *page_data;
};

// 外存配置相关
// TODO： Temporary configuration structure. A "real" library should have an
// extstore_set(enum, void *ptr) which hides the implementation.
// this is plenty for quick development.
struct extstore_conf {
	// 外存的相关配置
	unsigned int page_size;		// ideally 64-256M in size
	unsigned int page_count;
	unsigned int page_buckets;	// number of different writeable pages
	unsigned int free_page_buckets; // buckets of dedicated pages (see code)
	unsigned int wbuf_size;		// must divide cleanly into page_size
	unsigned int wbuf_count;	// this might get locked to "Z per active page"
	unsigned int io_threadcount;	// IO线程个数
	unsigned int io_depth;			// with normal I/O, hits locks less. req'd for AIO
};

// 外存文件配置相关
struct extstore_conf_file {
	unsigned int page_count;
	char *file;
	int fd;						// internal usage
	uint64_t offset;				// internal usage
	unsigned int bucket;		// free page bucket
	unsigned int free_bucket;	// spcialized free bucket
	struct extstore_conf_file *next;
};

// IO操作类型
enum obj_io_mode {
	OBJ_IO_READ = 0,
	OBJ_IO_WRITE,
};

// 宏定义
typedef struct _obj_io obj_io;			// 重命名
typedef void (*obj_io_cb)(void *e, obj_io *io, int ret);  // 回调函数

/* An object for both reads and writes to the storage engine.
 * Once an IO is submitted, ->next may be changed by the IO thread. It is not
 * safe to further modify the IO stack until the entire request is completed.
 */
// IO线程操作的结构体
struct _obj_io {
	void *data;					// user supplied data pointer
	struct _obj_io *next;
	char *buf;					// buffer of data to read or write to
	struct iovec *iov;			// alternatively, use this iovec
	unsigend int iovcnt;		// number of IOV's
	unsigend int page_version;	// page version for read mode
	unsigned int len;			// for both modes
	unsigned int offset;		// for read mode
	unsigned short page_id;		// for read mode
	enum obj_io_mode mode;
	// callback pointers
	obj_io_cb cb;					// 操作完后的回调函数
};

// 操作结构返回值
enum extstore_res {
	EXTSTORE_INIT_BAD_WBUF_SIZE = 1,
	EXTSTORE_INIT_NEED_MORE_WBUF,
	EXTSTORE_INIT_NEED_MORE_BUCKETS,
	EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT,
	EXTSTORE_INIT_TOO_MANY_PAGES,
	EXTSTORE_INIT_OOM,
	EXTSTORE_INIT_OPEN_FAIL,
	EXTSTORE_INIT_THREAD_FAIL
};

// 结构体操作的宏函数 ---- 位于extstore.c文件中
#define STAT_L(e) pthread_mutex_lock(&e->stats_mutex);
#define STAT_UL(e) pthread_mutex_unlock(&e->stats.mutex);
#define STAT_INCR(e, stat, amount) { \
		pthread_mutex_lock(&e->stats_mutex);  \
		e->stats.stat += amount;			     \
		pthread_mutex_unlock(&e->stats_mutex);\
}

#define STAT_DECR(e, stat, amount) { \
		pthread_mutex_lock(&e->stats_mutex);  \
		e->stats.stat -= amount;			     \		pthread_mutex_unlock(&e->stats_mutex);\
}

// 用于写出的缓存
typedef struct __store_wbuf {
	struct __store_wbuf *next;
	char *buf;
	char *buf_pos;
	unsigned int free;
	unsigned int size;
	unsigned int offset; // offset into page this write starts at
	bool full;			 // done writing to this page
	bool flushed;			 // whether wbuf has been flushed to disk
} _store_wbuf;

// 用于存储的page的结构体
typedef struct _store_page {
	pthread_mutex_t mutex;		// Need to be held for most operation
	uint64_t obj_count;			// _delete can decrease post-closing
	uint64_t bytes_used;		// _delete can decrease post-closing
	uint64_t offset;				// starting address of page within fd
	unsigned int version;
	unsigned int refcount;
	unsinged int allocated;
	unsigned int written;		// item offsets can be past written if wbuf not flushed
	unsigned int bucket;		// which bucket the page is linked into
	int fd;
	unsigned short id;
	bool active;					// actively being written to
	bool closed;					// closed and draining before free
	bool free;					// on freelist
	_store_wbuf *wbuf;			// currently active wbuf from the stack
	struct _store_page *next;
} store_page;

// 外存使用的最重要的结构体，整个外存的控制结构体
typedef struct store_engine store_engine;
struct store_engine {
	pthread_mutex_t mutex;				// covers internal stacks and variables
	store_page *pages;					// directly addressable page list
	_store_wbuf *wbuf_stack;			// wbuf freelist
	obj_io *io_stack;					// IO's to use with submitting wbuf's
	store_io_thread *io_threads;		
	store_maint_thread *maint_thread;
	store_page *page_freelist;
	store_page **oage_buckets;			// stack of pages currently allocated to each bucket
	store_page **free_page_buckets;	// stack of use-case isolated free pages
	size_t page_size;
	unsigned int version;				// global version counter
	unsigned int last_io_thread;		// round robin the IO threads
	unsigned int io_threadcount;		// count of IO threads
	unsigned int page_count;
	unsigned int page_free;				// unallocated pages
	unsigned int page_bucketcount;	// count of potential page buckets
	unsigned int free_page_bucketcount; // count of free page buckets
	unsigned int io_depth;				// FIXME: Might cache into thr struct
	pthread_mutex_t stats_mutex;
	struct extstore_stats stats;
};

// IO线程使用的结构体
typedef struct {
	pthread_mutex_t mutex;
	pthread_cond_t cond;
	obj_io *queue;
	store_engine *e;
	unsigned int depth;		// queue depth
} store_io_thread;

// 外存维护线程使用的结构体
typedef struct {
	pthread_mutex_t mutex;
	pthread_cond_t cond;
	store_engine *e;
} store_maint_thread;
```
上述结构体中最为重要的结构体为`struct store_engine`，此结构体负责管理所有的`struct __store_wbuf`、`struct _store_page`以及抽象的`bucket`。此结构体也是在`IO`线程和`maintain`线程中使用的重要结构体，后续将会有详细的介绍。

## 2. 外存初始化

### 2.1 `memcached`文件中的初始化
首先查看外存的初始化过程，其过程在`memcached.c`文件中。其源代码如下:

```
// memcached.c文件中
int main (int argc, char **argv) {
	int retval = EXIT_SUCCESS;
	// 其他代码
	....
#ifdef EXTSTORE
	void *storage = NULL;			// 指向struct store_engine结构体
	struct extstore_conf_file *storage_file = NULL; // 外存配置文件指针
	struct extstore_conf ext_cf;  // 外存配置结构体
#endif

	enum {
		....
#ifdef EXTSTORE
		EXT_PAGE_SIZE,				// page页面大小
		EXT_WBUF_SIZE,				// wbuf的缓冲区大小
		EXT_THREADS,					// 外存写出线程
		EXT_IO_DEPTH,					// 外存IO线程
		EXT_PATH,						// 外存文件路径
		EXT_ITEM_SIZE,				// 存放在外存中item的最小长度
		EXT_ITEM_AGE,					// 
		EXT_LOW_TTL,
		EXT_RECACHE_RATE,
		EXT_COMPACT_UNDER,			// 外存紧缩时最小的page存活占比
		EXT_DROP_UNDER,				// 外存丢弃的比例
		EXT_MAX_FRAG,
		EXT_DROP_UNREAD,
		SLAB_AUTOMOVE_FREERATIO,	// 外存空闲转移比例
#endif
	};
	char *const subopts_tokens[] = {
		....
#ifdef EXTSTORE
		[EXT_PAGE_SIZE] = "ext_page_size",
		[EXT_WBUF_SIZE] = "ext_wbuf_size",
		[EXT_THREADS] = "ext_threads",
		[EXT_IO_DEPTH] = "ext_io_depth",
		[EXT_PATH] = "ext_path",
		[EXT_ITEM_SIZE] = "ext_item_size",
		[EXT_ITEM_AGE] = "ext_item_age",
		[EXT_LOW_TTL] = "ext_low_ttl",
		[EXT_RECACHE_RATE] = "ext_recache_rate",
		[EXT_COMPACT_UNDER] = "ext_compact_under",
		[EXT_DROP_UNDER] = "ext_drop_under",
		[EXT_MAX_FRAG] = "ext_max_frag",
		[EXT_DROP_UNREAD] = "ext_drop_unread",
		[SLAB_AUTOMOVE_FREERATIO] = "slab_automove_freeratio",
#endif
		NULL
	};
	
	....
#ifdef EXTSTORE
	settings.ext_item_size = 512;		// 存放在外存中item的最小长度
	settings.ext_item_age = UINT_MAX;	// 
	settings.ext_low_ttl = 0;
	settings.ext_recache_rate = 2000;
	settings.ext_max_frag = 0.8;
	settings.ext_drop_unread = false;
	settings.ext_wbuf_size = 1024 * 1024 * 4; // 写出外存的缓冲区大小为4M
	settings.ext_compact_under = 0;
	settings.ext_drop_under = 0;
	settings.slab_automove_freeratio = 0.01;  // 外存移动的比例
	
	ext_cf.page_size = 1024 * 1024 * 64;	  // 页面默认大小为64M
	ext_cf.wbuf_size = settings.ext_wbuf_size;  // 外存缓冲区大小
	ext_cf.io_threadcount = 1;				  // IO线程个数
	ext_cf.io_depth = 1;					  // 
	ext_cf.page_buckets = 4;				  // 逻辑bucket的个数
	ext_cf.wbuf_count = ext_cf.page_buckets; // 外存缓冲区的个数
#endif

// 设置外存参数并初始化外存文件
#ifdef HAVE_GETOPT_LONG
	....
	while (-1 != (c = getopt_long(argc, argv, shortopts,
							longopts, &optindex))) {
#else
	while (-1 != (c = getopt(argc, argv, shortopts))) {
#endif
		switch (c) {
		....
		case 'o': // It's sub-opts time!
			subopts_orig = subopts = strdup(optarg); // getsubopt() changes the original args
			while (*subopts != '\0') {
			switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {
			....
#ifdef EXTSTORE
			case EXT_PAGE_SIZE:
				if (storage_file) {
					fprintf(stderr, "Must specify ext_page_size before any ext_path arguments\n");
					return 1;
				}
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_page_size argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &ext_cf.page_size)) {
					fprintf(stderr, "could not parse argument to ext_page_size\n");
					return 1;
				}
				ext_cf.page_size *= 1024 * 1024;  // megabytes
				break;
			case EXT_WBUF_SIZE:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_wbuf_size argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &ext_cf.wbuf_size)) {
					fprintf(stderr, "could not parse argument to ext_wbuf_size\n");
					return 1;
				}
				ext_cf.wbuf_size *= 1024 * 1024; // megabytes
				settings.ext_wbuf_size = ext_cf.wbuf_size;
				break;
			case EXT_THREADS:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_threads argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &ext_cf.io_threadcount)) {
					fprintf(stderr, "could not parse argument to ext_threads\n");
					return 1;
				}
				break;
			case EXT_IO_DEPTH:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_io_depth argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &ext_cf.io_depth)) {
					fprintf(stderr, "could not parse argument to ext_io_depth\n");
					return 1;
				}
				break;
			case EXT_ITEM_SIZE:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_item_size argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &settings.ext_item_size)) {
					fprintf(stderr, "could not parse argument to ext_item_size\n");
					return 1;
				}
				break;
			case EXT_ITEM_AGE:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_item_age argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &settings.ext_item_age)) {
					fprintf(stderr, "could not parse argument to ext_item_age\n");
					return 1;
				}
				break;
			case EXT_LOW_TTL:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_low_ttl argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &settings.ext_low_ttl)) {
					fprintf(stderr, "could not parse argument to ext_low_ttl\n");
					return 1;
				}
				break;
			case EXT_RECACHE_RATE:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_recache_rate arugment\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &settings.ext_recache_rate)) {
					fprintf(stderr, "could not parse argument to ext_recache_rate\n");
					return 1;
				}
				break;
			case EXT_COMPACT_UNDER:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_compact_under argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &settings.ext_compact_under)) {
					fprintf(stderr, "could not parse argument to ext_compact_under\n");
					return 1;
				}
				break;
			case EXT_DROP_UNDER:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_drop_under argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &settings.ext_drop_under)) {
					fprintf(stderr, "could not parse argument to ext_drop_under\n");
					return 1;
				}
				break;
			case EXT_MAX_FRAG:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_max_frag argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &settings.ext_max_frag)) {
					fprintf(stderr, "could not parse argument to ext_max_frag\n");
					return 1;
				}
				break;
			case SLAB_AUTOMOVE_FREERATIO:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing slab_automove_freeratio argument\n");
					return 1;
				}
				if (!safe_strtod(subopts_value, &settings.slab_automove_freeratio)) {
					fprintf(stderr, "could not parse argument to slab_automove_freeratio\n");
					return 1;
				}
				break;
			case EXT_DROP_UNREAD:
				settings.ext_drop_unread = true;
				break;
			case EXT_PATH:
				if (subopts_value) {
					struct extstore_conf_file *tmp = storage_conf_parse(subopts_value, ext_cf.page_size);
					if (tmp == NULL) {
						fprintf(stderr, "failed to parse ext_path argument\n");
						return 1;
					}
					if (storage_file != NULL) {
						tmp->next = storage_file;
					}
					storage_file = tmp;
				} else {
					fprintf(stderr, "missing argument to ext_path, ie: ext_path=/d/file:5G\n");
					return 1;
				}
				break;
#endif
			....
			}
			}
		}
	}

// 判断初始化参数是否合法
#ifdef EXTSTORE
	if (storage_file) {
		if (settings.item_size_max > ext_cf.wbuf_size) {
			fprintf(stderr, "-I (item_size_max: %d) cannot be larger than ext_wbuf_size: %d\n", 
				settings.item_size_max, ext_cf.wbuf_size);
			exit(EX_USAGE);
		}
		
		if (settings.udpport) {
			fprintf(stderr, "Cannot use UDP with extstore enalbed (-U 0 to disable)\n");
			exit(EX_USAGE);
		}
	}
#endif
	
	....
// 初始化struct store_engine结构体
#ifdef EXTSTORE
	if (storage_file) {
		enum extstore_res eres;
		if (settings.ext_compact_under == 0) {
			settings.ext_compact_under = storage_file->page_count / 4;
			// Only rescues non-COLD items if below this threshold
			settings.ext_drop_under = storage_file->page_count / 4;
		}
		crc32_init();
		// Init free chunks to zero
		for (int x = 0; x < MAX_NUMBER_OF_SLAB_CLASSES; x++) {
			settings.ext_free_memchunks[x] = 0;
		}
		storage = extstore_init(storage_file, &ext_cf, &eres);
		if (storage == NULL) {
			fprintf(stderr, "Failed to initialize external storage: %s\n",
					extstore_err(eres));
			if (eres == EXTSTORE_INIT_OPEN_FAIL) {
				perror("extstore open");
			}
			exit(EXIT_FAILURE);
		}
		ext_storage = storage;
		// page mover algorithm for extstore needs memory prefilled
		slabs_prefill_global();
	}
#endif
	/**
	 * ignore SIGPIPE signlas; we can use errno == EPIPE if we
	 * need that information
	 */
	if (sigignore(SIGPIPE) == -1) {
		perror("failed to ignore SIGPIPE: sigaction");
		exit(EX_OSERR);
	}
	// start up worker threads if MT mode
	// 使用storage初始化其他线程
#ifdef EXTSTORE
	slabs_set_storage(storage);
	memcached_thread_init(settings.num_threads, storage);
	init_lru_crawler(storage);
#else
	memcached_thread_init(settings.num_threads, NULL);
	init_lru_crawler(NULL);
#endif
	
	....
#ifdef EXTSTORE
	if (storage && start_storage_compact_thread(storage) != 0) {
		fprintf(stderr, "Failed to start storage compaction thread\n");
		exit(EXIT_FAILURE);
	}
	if (storage && start_storage_write_thread(storage) != 0) {
		fprintf(stderr, "Failed to start storage writer thread\n");
		exit(EXIT_FAILURE);
	}
	
	if (start_lru_maintainer && start_lru_maintainer_thread(storage) != 0) {
#else
	if (start_lru_maintainer && start_lru_maintainer_thread(NULL) != 0) {
#endif
		fprintf(stderr, "Failed to enable LRU maintainer thread\n");
		return 1;
	}
	
	....
	return retval;
}
```
通过上述代码可以看出先通过调用`storage_conf_parse`函数来初始化`extstore_conf_file`结构体，然后通过`extstore_conf_file`与`extstore_conf`两个结构体来初始化`struct storage_engine`结构体。从而让各个线程都拥有使用`struct storage_engine`结构体。

### 2.2 条件初始化
`struct storage_engine`的初始化需要`extstore_conf_file`和`extstore_conf`两个结构体。这两个结构体初始化的过程如下:

```
// extstore_conf_file结构体初始化过程
// /path/to/file:100G:bucket1
// FIXME: Modifies argument, copy instead?
struct extstore_conf_file *storage_conf_parse(char *arg, unsigned int page_size) {
	// arg ---- 文件的路径以及大小、bucket等信息字符串
	// page_size ---- 页面大小
	struct extstore_conf_file *cf = NULL;
	char *b = NULL;
	char *p = strtok_r(arg, ":", &b);		// arg的字符串以:进行分割
	char unit = 0;
	uint64_t multiplier = 0;
	int base_size = 0;
	if (p == NULL)
		goto error;
	// First arg is the filepath
	cf = calloc(1, sizeof(struct extstore_conf_file)); // 申请新空间
	cf->file = strdup(p);					// 指向文件的路径以及名称
	
	p = strtok_r(NULL, ":", &b);		// 指向下一个文件大小
	if (p == NULL) {
		fprintf(stderr, "must supply size to ext_path, ie: ext_path=/f/e:64m(MIGTIP supported)\n");
		goto error;
	}
	unit = tolower(p[strlen(p)-1]); // 文件使用的大小字节数
	p[strlen(p)-1] = '\0';			  // 将文件大小单位置为\0
	// sign
	switch (unit) {					// 获取文件大小的单位
	case 'm':
		multiplier = 1024 * 1024;
		break;
	case 'g':
		multiplier = 1024 * 1024 * 1024;
		break;
	case 't':
		multiplier = 1024 * 1024;
		multiplier *= 1024 * 1024;
		break;
	case 'p':
		multiplier = 1024 * 1024;
		multiplier = 1024 * 1024 * 1024;
		break;
	}
	base_size = atoi(p);		// 获取文件大小的数字
	multiplier *= base_size;	// 此文件对应的外存大小
	// page_count is nearest-but-not-larger-than pages * psize
	cf->page_count = multiplier / page_size;   // 此文件可以划分出的page个数
	assert(page_size * cf->page_count <= multiplier);
	
	// final token would be a default free bucket
	p = strtok_r(NULL, ",", &b);		// 获取逻辑bucket的名称
	// TODO: We reuse the original DEFINES for now.
	// but if lowttl gets split up this needs to be its own set
	if (p != NULL) {
		if (strcmp(p, "compact") == 0) {
			cf->free_bucket = PAGE_BUCKET_COMPACT;
		} else if (strcmp(p, "lowttl") == 0) {
			cf->free_bucket = PAGE_BUCKET_LOWTTL;
		} else if (strcmp(p, "chunked") == 0) {
			cf->free_bucket = PAGE_BUCKET_CHUNKED;
		} else if (strcmp(p, "default") == 0) {
			cf->free_bucket = PAGE_BUCKET_DEFAULT;
		} else {
			fprintf(stderr, "Unknown extstore bucket: %s\n", p);
			goto error;
		}
	} else {
		// TODO: is this necessary?
		cf->free_bucket = PAGE_BUCKET_DEFAULT;
	}
	
	// TODO:disabling until compact algorithm is improved
	// 目前bucket仅支持PAGE_BUCKET_DEFAULT一种
	if (cf->free_bucket != PAGE_BUCKET_DEFAULT) {
		fprintf(stderr, "ext_path only presently supports the default bucket\n");
		goto error;
	}
	
	return cf;
error:
	if (cf) {
		if (cf->file)
			free(cf->file);
		free(cf);
	}
	return NULL;
}

// extstore_conf的字段值是由settings或者参数相关进行设置
```

### 2.3 `struct storage_engine`结构体初始化
条件已经初始化完毕，本小节将讲述`struct storage_engine`结构体的初始化函数`extstore_init`。其源代码如下:

```
// 初始化struct storage_engine结构体
// TODO: #define's for DEFAULT_BUCKET, FREE_VERSION, etc
void *extstore_init(struct extstore_conf_file *fh, struct extstore_conf *cf, enum extstore_res *res) {
	int i;
	struct extstore_conf_file *f = NULL;
	pthread_t thread;
	
	// 外存页面的大小必须是写出缓冲区的整数倍
	if (cf->page_size % cf->wbuf_size != 0) {
		*res = EXTSTORE_INIT_BAD_WBUF_SIZE;
		return NULL;
	}
	// Should ensure at least one write buffer per potential page
	// 至少每一种bucket有一个写出缓冲区
	if (cf->page_buckets > cf->wbuf_count) {
		*res = EXTSTORE_INIT_NEED_MORE_WBUF;
		return NULL;
	}
	if (cf->page_buckets < 1) {
		*res = EXTSTORE_INIT_NEED_MORE_BUCKETS;
		return NULL;
	}
	
	// TODO: More intelligence around alignment of flash erasure block sizes
	// 边界对齐
	if (cf->page_size % (1024 * 1024 * 2) != 0 ||
			cf->wbuf_size % (1024 * 1024 * 2) != 0) {
		*res = EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT;
		return NULL;
	}
	
	// 申请struct engine空间
	store_engine *e = calloc(1, sizeof(store_engine));
	if (e == NULL) {
		*res = EXTSTORE_INIT_OOM;
		return NULL;
	}
	
	e->page_size = cf->page_size;		// 初始化外存页面的大小
	uint64_t temp_page_count = 0;		// 获取外存页面的总个数
	for (f = fh; f != NULL; f = f->next) { // 逐个遍历每个外存文件
		f->fd = open(f->file, O_RDWR | O_CREAT | O_TRUNC, 0644);
		if (f->fd < 0) {		// 判断文件是否成功打开
			*res = EXTSTORE_INIT_OPEN_FAIL;
			free(e);
			return NULL;
		}
		temp_page_count += f->page_count;
		f->offset = 0;
	}
	
	if (temp_page_count >= UINT16_MAX) {	 // 外存页面总数过多
		*res = EXTSTORE_INIT_TOO_MANY_PAGES;
		free(e);
		return NULL;
	}
	e->page_count = temp_page_count;		// 设置外存总页面数
	
	e->pages = calloc(e->page_count, sizeof(store_page)); // 为页面申请空间
	if (e->pages == NULL) {
		*res = EXTSTORE_INIT_OOM;
		// FIXME: loop-close, make error label
		free(e);
		return NULL;
	}
	
	// interleave the pages between devices
	f = NULL;	// start at the first device
	for (i = 0; i < e->page_count; i++) {   // 依次遍历每个外存文件，将其映射成外存的page页面
		// find next device with available pages
		while (1) {
			// restart the loop
			if (f == NULL || f->next == NULL) {
				f = fh;
			} else {
				f = f->next;
			}
			if (f->page_count) {
				f->page_count--;
				break;
			}
		}
		// 将外存文件中的一段内容映射成page
		pthread_mutex_init(&e->pages[i].mutex, NULL);
		e->pages[i].id = i;		// 页面的编号
		e->pages[i].fd = f->fd;	// 页面对应的外存文件
		e->pages[i].free_bucket = f->free_bucket; // page对应的逻辑bucket
		e->pages[i].offset = f->offset;	// 页面对应的文件偏移量		e->pages[i].free = true;			// 页面是空闲状态
		f->offset += e->page_size;			// 修改文件的偏移量
	}
	
	// free page buckets allows the app to organize devices by use case
	// 创建逻辑bucket桶的空闲页面
	e->free_page_buckets = clloc(cf->page_buckets, sizeof(store_page *));
	e->page_bucketcount = cf->page_buckets;  // 逻辑bucket的个数
	// 将空闲page链入总空闲链表或者某个bucket对应的空闲链表中
	for (i = e->page_count-1; i > 0; i--) {
		e->page_free++;			// 记录空闲page数
		if (e->pages[i].free_bucket == 0) {
			// 链入总空闲链表中
			e->pages[i].next = e->page_freelist;
			e->page_freelist = &e->pages[i];
		} else {
			// 链入某个bucket的空闲连表中
			int fb = e->pages[i].free_bucket;
			e->pages[i].next = e->free_page_buckets[fb];
			e->free_page_buckets[fb] = &e->pages[i];
		}
	}
	
	// 0 is magic "page is freed" version
	e->version = 1;		// 初始化页面的版本开始数值
	
	// scratch data for stats. TODO: malloc failure handle
	// 初始化外存页面的记录信息
	e->stats.page_data = calloc(e->page_count, sizeof(struct extstore_page_data));
	e->stats.page_count = e->page_count;
	e->stats.page_size = e->page_size;
	
	// page buckets lazily have pages assigned into them
	// 初始化bucket的空间
	e->page_buckets = calloc(cf->page_buckets, sizeof(store_page *));
	e->page_bucketcount = cf->page_buckets;
	
	// allocate write buffers
	// also IO's to use for shipping to IO thread
	// 初始化写出缓冲区的个数
	for (i = 0; i < cf->wbuf_count; i++) {
		_store_wbuf *w = wbuf_new(cf->wbuf_size);
		obj_io *io = calloc(1, sizeof(obj_io));
		// TODO: on error, loop again and free stack
		w->next = e->wbuf_stack;
		e->wbuf_stack = w;
		io->next = e->io_stack;
		e->io_stack = io;
	}
	
	// 初始化互斥量
	pthread_mutex_init(&e->mutex, NULL);
	pthread_mutex_init(&e->stats_mutex, NULL);
	
	// IO个数
	e->io_depth = cf->io_depth;
	
	// spawn threads
	// 初始化外存IO线程
	e->io_threads = calloc(cf->io_threadcount, sizeof(store_io_thread));
	for (i = 0; i < cf->io_threadcount; i++) {
		pthread_mutex_init(&e->io_threads[i].mutex, NULL);
		pthread_cond_init(&e->io_threads[i].cond, NULL);
		e->io_threads[i].e = e;
		// FIXME: error handling
		pthread_create(&thread, NULL, extstore_io_thread, &e->io_threads[i]);
	}
	e->io_threadcount = cf->io_threadcount;
	
	// 初始化维护线程
	e->maint_thread = calloc(1, sizeof(store_maint_thread);
	e->maint_thread->e = e;
	// FIXME: error handling
	pthread_mutex_init(&e->maint_thread->mutex, NULL);
	pthread_cond_init(&e->maint_thread->cond, NULL);
	pthread_create(&thread, NULL, extstore_maint_thread, e->maint_thread);
	
	extstore_run_maint(e);
	
	return (void *)e;
}

// 申请写出缓冲区空间的函数
static _store_wbuf *buf_new(size_t size) {
	_store_wbuf *b = calloc(1, sizeof(_store_wbuf));
	if (b == NULL)
		return NULL;
	b->buf = malloc(size);		// 申请存放数据空间
	if (b->buf == NULL) {
		free(b);
		return NULL;
	}
	// 初始化wbuf的成员变量
	b->buf_pos = b->buf;
	b->free = size;
	b->size = size;
	return b;
}
```
通过上述的代码可以绘制出如下图示来表示整个`store_engine`结构体的初始化情况和其结构体的关系。

![storage_engine初始化图示](https://github.com/whynotAC/analysis_memcached/blob/master/exstore/storage_engine初始化.png)

`store_engine`经过初始化后，然后传递给各个线程方便线程进行调用。

## 3. `exstore`管理线程初始化
由`store_engine`结构体的初始化过程中可知，涉及`extstore`基础管理的线程有两个:`extstore_io_thread`和`extstore_maint_thread`。这两个线程分别管理着`exstore`的读写过程和`extstore`的空闲管理。下面文档将分别介绍其对应的运行过程。

### 3.1 `extstore_io_thread`线程
这个线程管理着`extstore`的读写操作，主要流程是从`queue`中拿取`IO`操作结构体，然后根据`IO`操作结构体的类型来进行相应的读写操作,最终会调用`IO`操作结构体中的回调函数，其流程较为简单。源代码如下:

```
/* engine IO thread; takes engine context
 * manage writes/reads
 * runs IO callbacks inline after each IO 
 */
// FIXME: protect from reading past page
static void *extstore_io_thread(void *arg) {
	// 获取其对应的store_io_thread结构体
	store_io_thread *me = (store_io_thread *)arg;
	store_engine *e = me->e;
	// 处理IO操作的主要流程
	while (1) {
		obj_io *io_stack = NULL;	// 操作IO操作的指针
		pthread_mutex_lock(&me->mutex);
		// 等待IO操作队列有数据
		if (me->queue == NULL) {
			pthread_cond_wait(&me->cond, &me->mutex);
		}
		
		// Pull and disconnect a batch from the queue
		// 获取一批IO操作
		if (me->queue != NULL) {
			int i;
			obj_io *end = NULL;
			io_stack = me->queue;
			end = io_stack;
			// 获取IO操作队列的值
			for (i = 1; i < e->io_depth; i++) {
				if (end->next) {
					end = end->next;
				} else {
					break;
				}
			}
			// 调整IO处理线程的操作队列
			me->depth -= i;
			me->queue = end->next;
			end->next = NULL;
		}
		pthread_mutex_unlock(&me->mutex);
		
		obj_io *cur_io = io_stack;		// 从取出IO操作的链表头开始进行处理
		while (cur_io) {
			// We need to note next before the callback in case the obj_io
			// gets reused
			obj_io *next = cur_io->next;	// 记录下一个需要的操作
			int ret = 0;
			int do_op = 1;
			store_page *p = &e->pages[cur_io->page_id]; // 获取需要操作的page
			// TODO: loop if not enough bytes were read/written
			switch (cur_io->mode) {
				case OBJ_IO_READ:		// 读操作
					// Page is currently open. deal if read is past the end
					pthread_mutex_lock(&p->mutex);
					// 判断page和需要操作的item是否符合要求
					// 1.页面不处于空闲状态
					// 2.页面不处于关闭状态
					// 3.需要操作item的版本与page版本是否相同
					if (!p->free && !p->closed && p->version == cur_io->page_version) {
						// 如果页面处于活跃状态，并且有wbuf对其映射。则判断是否需要从wbuf获取item的值
						if (p->active && cur_io->offset >= p->written) {
							ret = _read_from_wbuf(p, cur_io);
							do_op = 0;
						} else {
							p->refcount++;	// page引用量加1
						}
						// 修改外存统计量
						STAT_L(e);
						e->stats.bytes_read += cur_io->len;
						e->stats.objects_read++;
						STAT_UL(e);
					} else {
						// item记录的消息已经过期
						do_op = 0;
						ret = -2;
					}
					pthread_mutex_unlock(&p->mutex);
					// 判断是否需要处理
					if (do_op) {
						// 注意偏移量为页面偏移量+页内偏移量
						if (cur_io->iov == NULL) {
							ret = pread(p->fd, cur_io->buf, cur_io->len, p->offset + cur_io->offset);
						} else {
							ret = preadv(p->fd, cur_io->iov, cur_io->iovcnt, p->offset + cur_io->offset);
						}
					}
					break;
				case OBJ_IO_WRITE:
					do_op = 0;
					// FIXME: Should hold refcount during write. doesn't
					// currently matter since page can't free while active
					ret = pwrite(p->fd, cur_io->buf, cur_io->len, p->offset + cur_io->offset);
					break;
			}
			if (ret == 0) {
				E_DEBUG("read returned nothing\n");
			}
			
			// 每当IO处理操作完成后，调用回调函数
			cur_io->cb(e, cur_io, ret);
			
			if (do_op) {
				pthread_mutex_lock(&p->mutex);
				p->refcount--;		// 减少页面引用量
				pthread_mutex_unlock(&p->mutex);
			}
			cur_io = next;	// 下一个IO操作
		}
	}
	return NULL;
}

/* Finds an attached wbuf that can satisfy the read.
 * Since wbufs can potentially be flushed to disk out of order, they are only
 * removed as the head of the list successfully flushes to disk.
 */
// 从wbuf读取对应的item
static inline int _read_from_wbuf(store_page *p, obj_io *io) {
	_store_wbuf *wbuf = p->wbuf;
	assert(wbuf != NULL);
	assert(io->offset < p->written + wbuf->size);
	// 注意调整偏移量
	if (io->iov == NULL) {
		memcpy(io->buf, wbuf->buf + (io->offset - wbuf->offset), io->len);
	} else {
		int x;
		unsigned int off = io->offset - wbuf->offset;
		// need to loop fill iovecs
		for (x = 0; x < io->iovcnt; x++) {
			struct iovec *iov = &io->iov[x];
			memcpy(iov->iov_base, wbuf->buf + off, iov->iov_len);
			off += iov->iov_len;
		}
	}
	return io->len;
}
```

### 3.2 `extstore_maint_thread`线程
此线程主要根据`extstore`中空闲`page`数以及每个`page`的状态来决定是否释放页面，以及强制从使用中的`page`来释放页面，从而腾出空闲空间。其源代码如下:

```

```