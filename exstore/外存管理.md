外存管理
=================================
通过前文<<外存介绍文档>>可以知道，外存的相关信息主要存在于三个文件中`extstore.h/c`、`storage.h/c`和`slab_automove_extstore.h/c`。本文将详细介绍`extstore.h/c`文件中的内容，此文件中的内容主要涉及外存的管理的相关信息。

## 1. 主要数据结构
对于外存的管理的主要数据结构如下所示:

```
/* A safe-to-read dataset for determining compaction
 * id is the array index.
 */
// 用于page compaction的结构体
struct extstore_page_data {
	uint64_t version;
	uint64_t bytes_used;
	unsigned int bucket;
	unsigned int free_bucket;
};

/* Pages can have objects deleted from them at any time. This creates holes
 * that can't be reused until the page is either evicted or all objects are
 * deleted.
 * bytes_fragmented is the total bytes for all of these holes.
 * It is the size of all used pages minus each page's bytes_used value.
 */
struct extstore_stats {
	// 页面相关
	uint64_t page_allocs;
	uint64_t page_count;	// total page count
	uint64_t page_evictions;
	uint64_t page_reclaims;
	uint64_t page_size;		// size in bytes per page (supplied by caller)
	uint64_t pages_free;	// currently unallocated/unused pages
	uint64_t pages_used;
	// 存储的对象相关
	uint64_t objects_evicted;
	uint64_t objects_read;
	uint64_t objects_written;
	uint64_t objects_used;	// total number of objects stored
	// 外存字节使用情况
	uint64_t bytes_evicted;
	uint64_t bytes_written;
	uint64_t bytes_read;	// wbuf - read -> bytes read from storage
	uint64_t bytes_used;	// total number of bytes stored
	uint64_t bytes_fragmented;	// see above comment
	
	// 其他
	uint64_t io_queue;
	
	// 页面本身内容
	struct extstore_page_data *page_data;
};

// 外存配置相关
// TODO： Temporary configuration structure. A "real" library should have an
// extstore_set(enum, void *ptr) which hides the implementation.
// this is plenty for quick development.
struct extstore_conf {
	// 外存的相关配置
	unsigned int page_size;		// ideally 64-256M in size
	unsigned int page_count;
	unsigned int page_buckets;	// number of different writeable pages
	unsigned int free_page_buckets; // buckets of dedicated pages (see code)
	unsigned int wbuf_size;		// must divide cleanly into page_size
	unsigned int wbuf_count;	// this might get locked to "Z per active page"
	unsigned int io_threadcount;	// IO线程个数
	unsigned int io_depth;			// with normal I/O, hits locks less. req'd for AIO
};

// 外存文件配置相关
struct extstore_conf_file {
	unsigned int page_count;
	char *file;
	int fd;						// internal usage
	uint64_t offset;				// internal usage
	unsigned int bucket;		// free page bucket
	unsigned int free_bucket;	// spcialized free bucket
	struct extstore_conf_file *next;
};

// IO操作类型
enum obj_io_mode {
	OBJ_IO_READ = 0,
	OBJ_IO_WRITE,
};

// 宏定义
typedef struct _obj_io obj_io;			// 重命名
typedef void (*obj_io_cb)(void *e, obj_io *io, int ret);  // 回调函数

/* An object for both reads and writes to the storage engine.
 * Once an IO is submitted, ->next may be changed by the IO thread. It is not
 * safe to further modify the IO stack until the entire request is completed.
 */
// IO线程操作的结构体
struct _obj_io {
	void *data;					// user supplied data pointer
	struct _obj_io *next;
	char *buf;					// buffer of data to read or write to
	struct iovec *iov;			// alternatively, use this iovec
	unsigend int iovcnt;		// number of IOV's
	unsigend int page_version;	// page version for read mode
	unsigned int len;			// for both modes
	unsigned int offset;		// for read mode
	unsigned short page_id;		// for read mode
	enum obj_io_mode mode;
	// callback pointers
	obj_io_cb cb;					// 操作完后的回调函数
};

// 操作结构返回值
enum extstore_res {
	EXTSTORE_INIT_BAD_WBUF_SIZE = 1,
	EXTSTORE_INIT_NEED_MORE_WBUF,
	EXTSTORE_INIT_NEED_MORE_BUCKETS,
	EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT,
	EXTSTORE_INIT_TOO_MANY_PAGES,
	EXTSTORE_INIT_OOM,
	EXTSTORE_INIT_OPEN_FAIL,
	EXTSTORE_INIT_THREAD_FAIL
};


```