外存管理
=================================
通过前文<<外存介绍文档>>可以知道，外存的相关信息主要存在于三个文件中`extstore.h/c`、`storage.h/c`和`slab_automove_extstore.h/c`。本文将详细介绍`extstore.h/c`文件中的内容，此文件中的内容主要涉及外存的管理的相关信息。

## 1. 主要数据结构
对于外存的管理的主要数据结构如下所示:

```
/* A safe-to-read dataset for determining compaction
 * id is the array index.
 */
// 用于page compaction的结构体
struct extstore_page_data {
	uint64_t version;
	uint64_t bytes_used;
	unsigned int bucket;
	unsigned int free_bucket;
};

/* Pages can have objects deleted from them at any time. This creates holes
 * that can't be reused until the page is either evicted or all objects are
 * deleted.
 * bytes_fragmented is the total bytes for all of these holes.
 * It is the size of all used pages minus each page's bytes_used value.
 */
struct extstore_stats {
	// 页面相关
	uint64_t page_allocs;
	uint64_t page_count;	// total page count
	uint64_t page_evictions;
	uint64_t page_reclaims;
	uint64_t page_size;		// size in bytes per page (supplied by caller)
	uint64_t pages_free;	// currently unallocated/unused pages
	uint64_t pages_used;
	// 存储的对象相关
	uint64_t objects_evicted;
	uint64_t objects_read;
	uint64_t objects_written;
	uint64_t objects_used;	// total number of objects stored
	// 外存字节使用情况
	uint64_t bytes_evicted;
	uint64_t bytes_written;
	uint64_t bytes_read;	// wbuf - read -> bytes read from storage
	uint64_t bytes_used;	// total number of bytes stored
	uint64_t bytes_fragmented;	// see above comment
	
	// 其他
	uint64_t io_queue;
	
	// 页面本身内容
	struct extstore_page_data *page_data;
};

// 外存配置相关
// TODO： Temporary configuration structure. A "real" library should have an
// extstore_set(enum, void *ptr) which hides the implementation.
// this is plenty for quick development.
struct extstore_conf {
	// 外存的相关配置
	unsigned int page_size;		// ideally 64-256M in size
	unsigned int page_count;
	unsigned int page_buckets;	// number of different writeable pages
	unsigned int free_page_buckets; // buckets of dedicated pages (see code)
	unsigned int wbuf_size;		// must divide cleanly into page_size
	unsigned int wbuf_count;	// this might get locked to "Z per active page"
	unsigned int io_threadcount;	// IO线程个数
	unsigned int io_depth;			// with normal I/O, hits locks less. req'd for AIO
};

// 外存文件配置相关
struct extstore_conf_file {
	unsigned int page_count;
	char *file;
	int fd;						// internal usage
	uint64_t offset;				// internal usage
	unsigned int bucket;		// free page bucket
	unsigned int free_bucket;	// spcialized free bucket
	struct extstore_conf_file *next;
};

// IO操作类型
enum obj_io_mode {
	OBJ_IO_READ = 0,
	OBJ_IO_WRITE,
};

// 宏定义
typedef struct _obj_io obj_io;			// 重命名
typedef void (*obj_io_cb)(void *e, obj_io *io, int ret);  // 回调函数

/* An object for both reads and writes to the storage engine.
 * Once an IO is submitted, ->next may be changed by the IO thread. It is not
 * safe to further modify the IO stack until the entire request is completed.
 */
// IO线程操作的结构体
struct _obj_io {
	void *data;					// user supplied data pointer
	struct _obj_io *next;
	char *buf;					// buffer of data to read or write to
	struct iovec *iov;			// alternatively, use this iovec
	unsigend int iovcnt;		// number of IOV's
	unsigend int page_version;	// page version for read mode
	unsigned int len;			// for both modes
	unsigned int offset;		// for read mode
	unsigned short page_id;		// for read mode
	enum obj_io_mode mode;
	// callback pointers
	obj_io_cb cb;					// 操作完后的回调函数
};

// 操作结构返回值
enum extstore_res {
	EXTSTORE_INIT_BAD_WBUF_SIZE = 1,
	EXTSTORE_INIT_NEED_MORE_WBUF,
	EXTSTORE_INIT_NEED_MORE_BUCKETS,
	EXTSTORE_INIT_PAGE_WBUF_ALIGNMENT,
	EXTSTORE_INIT_TOO_MANY_PAGES,
	EXTSTORE_INIT_OOM,
	EXTSTORE_INIT_OPEN_FAIL,
	EXTSTORE_INIT_THREAD_FAIL
};

// 结构体操作的宏函数 ---- 位于extstore.c文件中
#define STAT_L(e) pthread_mutex_lock(&e->stats_mutex);
#define STAT_UL(e) pthread_mutex_unlock(&e->stats.mutex);
#define STAT_INCR(e, stat, amount) { \
		pthread_mutex_lock(&e->stats_mutex);  \
		e->stats.stat += amount;			     \
		pthread_mutex_unlock(&e->stats_mutex);\
}

#define STAT_DECR(e, stat, amount) { \
		pthread_mutex_lock(&e->stats_mutex);  \
		e->stats.stat -= amount;			     \		pthread_mutex_unlock(&e->stats_mutex);\
}

// 用于写出的缓存
typedef struct __store_wbuf {
	struct __store_wbuf *next;
	char *buf;
	char *buf_pos;
	unsigned int free;
	unsigned int size;
	unsigned int offset; // offset into page this write starts at
	bool full;			 // done writing to this page
	bool flushed;			 // whether wbuf has been flushed to disk
} _store_wbuf;

// 用于存储的page的结构体
typedef struct _store_page {
	pthread_mutex_t mutex;		// Need to be held for most operation
	uint64_t obj_count;			// _delete can decrease post-closing
	uint64_t bytes_used;		// _delete can decrease post-closing
	uint64_t offset;				// starting address of page within fd
	unsigned int version;
	unsigned int refcount;
	unsinged int allocated;
	unsigned int written;		// item offsets can be past written if wbuf not flushed
	unsigned int bucket;		// which bucket the page is linked into
	int fd;
	unsigned short id;
	bool active;					// actively being written to
	bool closed;					// closed and draining before free
	bool free;					// on freelist
	_store_wbuf *wbuf;			// currently active wbuf from the stack
	struct _store_page *next;
} store_page;

// 外存使用的最重要的结构体，整个外存的控制结构体
typedef struct store_engine store_engine;
struct store_engine {
	pthread_mutex_t mutex;				// covers internal stacks and variables
	store_page *pages;					// directly addressable page list
	_store_wbuf *wbuf_stack;			// wbuf freelist
	obj_io *io_stack;					// IO's to use with submitting wbuf's
	store_io_thread *io_threads;		
	store_maint_thread *maint_thread;
	store_page *page_freelist;
	store_page **oage_buckets;			// stack of pages currently allocated to each bucket
	store_page **free_page_buckets;	// stack of use-case isolated free pages
	size_t page_size;
	unsigned int version;				// global version counter
	unsigned int last_io_thread;		// round robin the IO threads
	unsigned int io_threadcount;		// count of IO threads
	unsigned int page_count;
	unsigned int page_free;				// unallocated pages
	unsigned int page_bucketcount;	// count of potential page buckets
	unsigned int free_page_bucketcount; // count of free page buckets
	unsigned int io_depth;				// FIXME: Might cache into thr struct
	pthread_mutex_t stats_mutex;
	struct extstore_stats stats;
};

// IO线程使用的结构体
typedef struct {
	pthread_mutex_t mutex;
	pthread_cond_t cond;
	obj_io *queue;
	store_engine *e;
	unsigned int depth;		// queue depth
} store_io_thread;

// 外存维护线程使用的结构体
typedef struct {
	pthread_mutex_t mutex;
	pthread_cond_t cond;
	store_engine *e;
} store_maint_thread;
```
上述结构体中最为重要的结构体为`struct store_engine`，此结构体负责管理所有的`struct __store_wbuf`、`struct _store_page`以及抽象的`bucket`。此结构体也是在`IO`线程和`maintain`线程中使用的重要结构体，后续将会有详细的介绍。

## 2. 外存初始化
首先查看外存的初始化过程，其过程在`memcached.c`文件中。其源代码如下:

```
// memcached.c文件中
int main (int argc, char **argv) {
	int retval = EXIT_SUCCESS;
	// 其他代码
	....
#ifdef EXTSTORE
	void *storage = NULL;			// 指向struct store_engine结构体
	struct extstore_conf_file *storage_file = NULL; // 外存配置文件指针
	struct extstore_conf ext_cf;  // 外存配置结构体
#endif

	enum {
		....
#ifdef EXTSTORE
		EXT_PAGE_SIZE,				// page页面大小
		EXT_WBUF_SIZE,				// wbuf的缓冲区大小
		EXT_THREADS,					// 外存写出线程
		EXT_IO_DEPTH,					// 外存IO线程
		EXT_PATH,						// 外存文件路径
		EXT_ITEM_SIZE,				// 存放在外存中item的最小长度
		EXT_ITEM_AGE,					// 
		EXT_LOW_TTL,
		EXT_RECACHE_RATE,
		EXT_COMPACT_UNDER,			// 外存紧缩时最小的page存活占比
		EXT_DROP_UNDER,				// 外存丢弃的比例
		EXT_MAX_FRAG,
		EXT_DROP_UNREAD,
		SLAB_AUTOMOVE_FREERATIO,	// 外存空闲转移比例
#endif
	};
	char *const subopts_tokens[] = {
		....
#ifdef EXTSTORE
		[EXT_PAGE_SIZE] = "ext_page_size",
		[EXT_WBUF_SIZE] = "ext_wbuf_size",
		[EXT_THREADS] = "ext_threads",
		[EXT_IO_DEPTH] = "ext_io_depth",
		[EXT_PATH] = "ext_path",
		[EXT_ITEM_SIZE] = "ext_item_size",
		[EXT_ITEM_AGE] = "ext_item_age",
		[EXT_LOW_TTL] = "ext_low_ttl",
		[EXT_RECACHE_RATE] = "ext_recache_rate",
		[EXT_COMPACT_UNDER] = "ext_compact_under",
		[EXT_DROP_UNDER] = "ext_drop_under",
		[EXT_MAX_FRAG] = "ext_max_frag",
		[EXT_DROP_UNREAD] = "ext_drop_unread",
		[SLAB_AUTOMOVE_FREERATIO] = "slab_automove_freeratio",
#endif
		NULL
	};
	
	....
#ifdef EXTSTORE
	settings.ext_item_size = 512;		// 存放在外存中item的最小长度
	settings.ext_item_age = UINT_MAX;	// 
	settings.ext_low_ttl = 0;
	settings.ext_recache_rate = 2000;
	settings.ext_max_frag = 0.8;
	settings.ext_drop_unread = false;
	settings.ext_wbuf_size = 1024 * 1024 * 4; // 写出外存的缓冲区大小为4M
	settings.ext_compact_under = 0;
	settings.ext_drop_under = 0;
	settings.slab_automove_freeratio = 0.01;  // 外存移动的比例
	
	ext_cf.page_size = 1024 * 1024 * 64;	  // 页面默认大小为64M
	ext_cf.wbuf_size = settings.ext_wbuf_size;  // 外存缓冲区大小
	ext_cf.io_threadcount = 1;				  // IO线程个数
	ext_cf.io_depth = 1;					  // 
	ext_cf.page_buckets = 4;				  // 逻辑bucket的个数
	ext_cf.wbuf_count = ext_cf.page_buckets; // 外存缓冲区的个数
#endif

// 设置外存参数并初始化外存文件
#ifdef HAVE_GETOPT_LONG
	....
	while (-1 != (c = getopt_long(argc, argv, shortopts,
							longopts, &optindex))) {
#else
	while (-1 != (c = getopt(argc, argv, shortopts))) {
#endif
		switch (c) {
		....
		case 'o': // It's sub-opts time!
			subopts_orig = subopts = strdup(optarg); // getsubopt() changes the original args
			while (*subopts != '\0') {
			switch (getsubopt(&subopts, subopts_tokens, &subopts_value)) {
			....
#ifdef EXTSTORE
			case EXT_PAGE_SIZE:
				if (storage_file) {
					fprintf(stderr, "Must specify ext_page_size before any ext_path arguments\n");
					return 1;
				}
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_page_size argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &ext_cf.page_size)) {
					fprintf(stderr, "could not parse argument to ext_page_size\n");
					return 1;
				}
				ext_cf.page_size *= 1024 * 1024;  // megabytes
				break;
			case EXT_WBUF_SIZE:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_wbuf_size argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &ext_cf.wbuf_size)) {
					fprintf(stderr, "could not parse argument to ext_wbuf_size\n");
					return 1;
				}
				ext_cf.wbuf_size *= 1024 * 1024; // megabytes
				settings.ext_wbuf_size = ext_cf.wbuf_size;
				break;
			case EXT_THREADS:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_threads argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &ext_cf.io_threadcount)) {
					fprintf(stderr, "could not parse argument to ext_threads\n");
					return 1;
				}
				break;
			case EXT_IO_DEPTH:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_io_depth argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &ext_cf.io_depth)) {
					fprintf(stderr, "could not parse argument to ext_io_depth\n");
					return 1;
				}
				break;
			case EXT_ITEM_SIZE:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_item_size argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &settings.ext_item_size)) {
					fprintf(stderr, "could not parse argument to ext_item_size\n");
					return 1;
				}
				break;
			case EXT_ITEM_AGE:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_item_age argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &settings.ext_item_age)) {
					fprintf(stderr, "could not parse argument to ext_item_age\n");
					return 1;
				}
				break;
			case EXT_LOW_TTL:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_low_ttl argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &settings.ext_low_ttl)) {
					fprintf(stderr, "could not parse argument to ext_low_ttl\n");
					return 1;
				}
				break;
			case EXT_RECACHE_RATE:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_recache_rate arugment\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &settings.ext_recache_rate)) {
					fprintf(stderr, "could not parse argument to ext_recache_rate\n");
					return 1;
				}
				break;
			case EXT_COMPACT_UNDER:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_compact_under argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &settings.ext_compact_under)) {
					fprintf(stderr, "could not parse argument to ext_compact_under\n");
					return 1;
				}
				break;
			case EXT_DROP_UNDER:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_drop_under argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &settings.ext_drop_under)) {
					fprintf(stderr, "could not parse argument to ext_drop_under\n");
					return 1;
				}
				break;
			case EXT_MAX_FRAG:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing ext_max_frag argument\n");
					return 1;
				}
				if (!safe_strtoul(subopts_value, &settings.ext_max_frag)) {
					fprintf(stderr, "could not parse argument to ext_max_frag\n");
					return 1;
				}
				break;
			case SLAB_AUTOMOVE_FREERATIO:
				if (subopts_value == NULL) {
					fprintf(stderr, "Missing slab_automove_freeratio argument\n");
					return 1;
				}
				if (!safe_strtod(subopts_value, &settings.slab_automove_freeratio)) {
					fprintf(stderr, "could not parse argument to slab_automove_freeratio\n");
					return 1;
				}
				break;
			case EXT_DROP_UNREAD:
				settings.ext_drop_unread = true;
				break;
			case EXT_PATH:
				if (subopts_value) {
					struct extstore_conf_file *tmp = storage_conf_parse(subopts_value, ext_cf.page_size);
					if (tmp == NULL) {
						fprintf(stderr, "failed to parse ext_path argument\n");
						return 1;
					}
					if (storage_file != NULL) {
						tmp->next = storage_file;
					}
					storage_file = tmp;
				} else {
					fprintf(stderr, "missing argument to ext_path, ie: ext_path=/d/file:5G\n");
					return 1;
				}
				break;
#endif
			....
			}
			}
		}
	}

// 判断初始化参数是否合法
#ifdef EXTSTORE
	if (storage_file) {
		if (settings.item_size_max > ext_cf.wbuf_size) {
			fprintf(stderr, "-I (item_size_max: %d) cannot be larger than ext_wbuf_size: %d\n", 
				settings.item_size_max, ext_cf.wbuf_size);
			exit(EX_USAGE);
		}
		
		if (settings.udpport) {
			fprintf(stderr, "Cannot use UDP with extstore enalbed (-U 0 to disable)\n");
			exit(EX_USAGE);
		}
	}
#endif
	
	....
#ifdef EXTSTORE
	if (storage_file) {
		enum extstore_res eres;
		if (settings.ext_compact_under == 0) {
			settings.ext_compact_under = storage_file->page_count / 4;
			// Only rescues non-COLD items if below this threshold
			settings.ext_drop_under = storage_file->page_count / 4;
		}
		crc32_init();
		// Init free chunks to zero
		for (int x = 0; x < MAX_NUMBER_OF_SLAB_CLASSES; x++) {
			settings.ext_free_memchunks[x] = 0;
		}
		storage = extstore_init(storage_file, &ext_cf, &eres);
		if (storage == NULL) {
			fprintf(stderr, "Failed to initialize external storage: %s\n",
					extstore_err(eres));
			if (eres == EXTSTORE_INIT_OPEN_FAIL) {
				perror("extstore open");
			}
			exit(EXIT_FAILURE);
		}
		ext_storage = storage;
		// page mover algorithm for extstore needs memory prefilled
		slabs_prefill_global();
	}
#endif
	/**
	 * ignore SIGPIPE signlas; we can use errno == EPIPE if we
	 * need that information
	 */
	if (sigignore(SIGPIPE) == -1) {
		perror("failed to ignore SIGPIPE: sigaction");
		exit(EX_OSERR);
	}
	// start up worker threads if MT mode
	// 使用storage初始化其他线程
#ifdef EXTSTORE
	slabs_set_storage(storage);
	memcached_thread_init(settings.num_threads, storage);
	init_lru_crawler(storage);
#else
	memcached_thread_init(settings.num_threads, NULL);
	init_lru_crawler(NULL);
#endif
	
	....
#ifdef EXTSTORE
	if (storage && start_storage_compact_thread(storage) != 0) {
		fprintf(stderr, "Failed to start storage compaction thread\n");
		exit(EXIT_FAILURE);
	}
	if (storage && start_storage_write_thread(storage) != 0) {
		fprintf(stderr, "Failed to start storage writer thread\n");
		exit(EXIT_FAILURE);
	}
	
	if (start_lru_maintainer && start_lru_maintainer_thread(storage) != 0) {
#else
	if (start_lru_maintainer && start_lru_maintainer_thread(NULL) != 0) {
#endif
		fprintf(stderr, "Failed to enable LRU maintainer thread\n");
		return 1;
	}
	
	....
	return retval;
}
```